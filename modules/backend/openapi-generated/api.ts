/* tslint:disable */
/* eslint-disable */
/**
 * PAAS MPA backend
 * BPA
 *
 * The version of the OpenAPI document: 1.0
 * Contact: inovacie@bratislava.sk
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base'

/**
 *
 * @export
 * @interface AnnouncementDto
 */
export interface AnnouncementDto {
  /**
   * Title of the announcement
   * @type {string}
   * @memberof AnnouncementDto
   */
  title: string
  /**
   * Content of the announcement
   * @type {string}
   * @memberof AnnouncementDto
   */
  content: string
  /**
   * Language of the announcement in ISO 639-1 language code
   * @type {string}
   * @memberof AnnouncementDto
   */
  language: string
  /**
   *
   * @type {AnnouncementType}
   * @memberof AnnouncementDto
   */
  type: AnnouncementType
  /**
   * External url to route the user on CTA
   * @type {string}
   * @memberof AnnouncementDto
   */
  externalUrl?: string
  /**
   * Database id of the announcement
   * @type {number}
   * @memberof AnnouncementDto
   */
  id: number
  /**
   * Date of the creation
   * @type {string}
   * @memberof AnnouncementDto
   */
  createdAt: string
}

/**
 *
 * @export
 * @enum {string}
 */

export const AnnouncementType = {
  Info: 'INFO',
  Warn: 'WARN',
  Error: 'ERROR',
} as const

export type AnnouncementType = (typeof AnnouncementType)[keyof typeof AnnouncementType]

/**
 *
 * @export
 * @interface AnnouncementsResponseDto
 */
export interface AnnouncementsResponseDto {
  /**
   * List of announcements
   * @type {Array<AnnouncementDto>}
   * @memberof AnnouncementsResponseDto
   */
  announcements: Array<AnnouncementDto>
  /**
   *
   * @type {PaginationInfo}
   * @memberof AnnouncementsResponseDto
   */
  paginationInfo: PaginationInfo
}
/**
 *
 * @export
 * @interface CreateVehicleDto
 */
export interface CreateVehicleDto {
  /**
   * License plate number
   * @type {string}
   * @memberof CreateVehicleDto
   */
  vehiclePlateNumber: string
  /**
   * Name of the vehicle (user input)
   * @type {string}
   * @memberof CreateVehicleDto
   */
  name?: string
  /**
   * Set to true to be the default car
   * @type {boolean}
   * @memberof CreateVehicleDto
   */
  isDefault: boolean
}
/**
 *
 * @export
 * @interface DeleteResponseDto
 */
export interface DeleteResponseDto {
  /**
   * ID of the deleted object
   * @type {number}
   * @memberof DeleteResponseDto
   */
  id: number
  /**
   * True if the delete was successful
   * @type {boolean}
   * @memberof DeleteResponseDto
   */
  deleted: boolean
}
/**
 *
 * @export
 * @interface EmailVerificationResult
 */
export interface EmailVerificationResult {
  /**
   * Verified email address
   * @type {string}
   * @memberof EmailVerificationResult
   */
  email: string
  /**
   * Status signaling if the email was sent successfuly
   * @type {boolean}
   * @memberof EmailVerificationResult
   */
  sent: boolean
}
/**
 *
 * @export
 * @interface FeedbackDto
 */
export interface FeedbackDto {
  /**
   *
   * @type {FeedbackType}
   * @memberof FeedbackDto
   */
  type: FeedbackType
  /**
   * Email of the feedback reporter
   * @type {string}
   * @memberof FeedbackDto
   */
  email: string
  /**
   * Message of the feedback
   * @type {string}
   * @memberof FeedbackDto
   */
  message: string
}

/**
 *
 * @export
 * @enum {string}
 */

export const FeedbackType = {
  _0: '0',
  _1: '1',
} as const

export type FeedbackType = (typeof FeedbackType)[keyof typeof FeedbackType]

/**
 *
 * @export
 * @interface GetTicketPriceRequestDto
 */
export interface GetTicketPriceRequestDto {
  /**
   * Value of NPK UUID
   * @type {string}
   * @memberof GetTicketPriceRequestDto
   */
  npkId?: string
  /**
   *
   * @type {GetTicketPriceTicketInfoRequestDto}
   * @memberof GetTicketPriceRequestDto
   */
  ticket: GetTicketPriceTicketInfoRequestDto
}
/**
 *
 * @export
 * @interface GetTicketPriceResponseDto
 */
export interface GetTicketPriceResponseDto {
  /**
   * Total ticket price considering all discounts and credits. Tax inculded if there is any
   * @type {number}
   * @memberof GetTicketPriceResponseDto
   */
  priceTotal: number
  /**
   * Tax in euros from total price.
   * @type {number}
   * @memberof GetTicketPriceResponseDto
   */
  tax?: number
  /**
   * Total ticket price considering all discounts and credits.
   * @type {number}
   * @memberof GetTicketPriceResponseDto
   */
  priceWithoutTax?: number
  /**
   * Total price without discounts. Tax included if there is any
   * @type {number}
   * @memberof GetTicketPriceResponseDto
   */
  priceWithoutDiscount: number
  /**
   * Credits used in case of bonus parking in seconds
   * @type {number}
   * @memberof GetTicketPriceResponseDto
   */
  creditBpkUsedSeconds: number
  /**
   * Credits remaining in case of bonus parking in seconds
   * @type {number}
   * @memberof GetTicketPriceResponseDto
   */
  creditBpkRemaining: number
  /**
   * Credits used in case of bonus parking in seconds
   * @type {number}
   * @memberof GetTicketPriceResponseDto
   */
  creditNpkUsedSeconds: number
  /**
   * Credits remaining in case of bonus parking in seconds
   * @type {number}
   * @memberof GetTicketPriceResponseDto
   */
  creditNpkRemaining: number
  /**
   * The date and time when parking starts (UTC time in ISO8601 format)
   * @type {string}
   * @memberof GetTicketPriceResponseDto
   */
  ticketStart: string
  /**
   * Parking only allowed up to this date/time. Can be different from requested ParkingEnd. Limited by maximum parking time in current parking regulation section.
   * @type {string}
   * @memberof GetTicketPriceResponseDto
   */
  ticketEnd: string
  /**
   * UUID
   * @type {string}
   * @memberof GetTicketPriceResponseDto
   */
  bpkId?: string
  /**
   * End of card validity. ISO8601 formatted UTC timestamp.
   * @type {string}
   * @memberof GetTicketPriceResponseDto
   */
  bpkValidTo?: string
  /**
   * Original balance available on the visitor card in seconds
   * @type {number}
   * @memberof GetTicketPriceResponseDto
   */
  bpkOriginalBalanceSeconds?: number
}
/**
 *
 * @export
 * @interface GetTicketPriceTicketInfoRequestDto
 */
export interface GetTicketPriceTicketInfoRequestDto {
  /**
   * Parking vehicle registration number
   * @type {string}
   * @memberof GetTicketPriceTicketInfoRequestDto
   */
  ecv: string
  /**
   * Unique identification of parking slot (specific section of parking regulation)
   * @type {string}
   * @memberof GetTicketPriceTicketInfoRequestDto
   */
  udr: string
  /**
   * GUID - Unique identification of parking slot (specific section of parking regulation)
   * @type {string}
   * @memberof GetTicketPriceTicketInfoRequestDto
   */
  udrUuid?: string
  /**
   * The date and time when parking ends (UTC time in ISO8601 format)
   * @type {string}
   * @memberof GetTicketPriceTicketInfoRequestDto
   */
  parkingEnd: string
  /**
   * The date and time when parking ends (UTC time in ISO8601 format)
   * @type {string}
   * @memberof GetTicketPriceTicketInfoRequestDto
   */
  parkingStart: string
}
/**
 *
 * @export
 * @interface GetTicketProlongationPriceRequestDto
 */
export interface GetTicketProlongationPriceRequestDto {
  /**
   * The date and time when parking ends (UTC time in ISO8601 format)
   * @type {string}
   * @memberof GetTicketProlongationPriceRequestDto
   */
  newParkingEnd: string
  /**
   * Id of the ticket to be prolonged
   * @type {number}
   * @memberof GetTicketProlongationPriceRequestDto
   */
  ticketId: number
}
/**
 *
 * @export
 * @interface InitiatePaymentRequestDto
 */
export interface InitiatePaymentRequestDto {
  /**
   * Value of NPK UUID
   * @type {string}
   * @memberof InitiatePaymentRequestDto
   */
  npkId?: string
  /**
   *
   * @type {GetTicketPriceTicketInfoRequestDto}
   * @memberof InitiatePaymentRequestDto
   */
  ticket: GetTicketPriceTicketInfoRequestDto
  /**
   * Latitude of the parking pin from the application
   * @type {number}
   * @memberof InitiatePaymentRequestDto
   */
  latitude?: number
  /**
   * Longitude of the parking pin from the application
   * @type {number}
   * @memberof InitiatePaymentRequestDto
   */
  longitude?: number
}
/**
 *
 * @export
 * @interface InitiateProlongationRequestDto
 */
export interface InitiateProlongationRequestDto {
  /**
   * The date and time when parking ends (UTC time in ISO8601 format)
   * @type {string}
   * @memberof InitiateProlongationRequestDto
   */
  newParkingEnd: string
  /**
   * Id of the ticket to be prolonged
   * @type {number}
   * @memberof InitiateProlongationRequestDto
   */
  ticketId: number
}
/**
 *
 * @export
 * @interface MobileAppVersionUpdateDto
 */
export interface MobileAppVersionUpdateDto {
  /**
   * Version required from the user
   * @type {string}
   * @memberof MobileAppVersionUpdateDto
   */
  version: string
}
/**
 *
 * @export
 * @interface MobileDeviceDto
 */
export interface MobileDeviceDto {
  /**
   * Mobile device token for sending push messages
   * @type {string}
   * @memberof MobileDeviceDto
   */
  token: string
  /**
   *
   * @type {MobileDevicePlatform}
   * @memberof MobileDeviceDto
   */
  platform: MobileDevicePlatform
  /**
   * Database id of the mobile device
   * @type {number}
   * @memberof MobileDeviceDto
   */
  id: number
  /**
   * Date of the creation
   * @type {string}
   * @memberof MobileDeviceDto
   */
  createdAt: string
  /**
   * Date of the last change
   * @type {string}
   * @memberof MobileDeviceDto
   */
  updatedAt: string
}

/**
 *
 * @export
 * @enum {string}
 */

export const MobileDevicePlatform = {
  Apple: 'APPLE',
  Android: 'ANDROID',
} as const

export type MobileDevicePlatform = (typeof MobileDevicePlatform)[keyof typeof MobileDevicePlatform]

/**
 *
 * @export
 * @interface MobileDeviceResponseDto
 */
export interface MobileDeviceResponseDto {
  /**
   * List of mobile devices
   * @type {Array<MobileDeviceDto>}
   * @memberof MobileDeviceResponseDto
   */
  devices: Array<MobileDeviceDto>
  /**
   *
   * @type {PaginationInfo}
   * @memberof MobileDeviceResponseDto
   */
  paginationInfo: PaginationInfo
}
/**
 *
 * @export
 * @enum {string}
 */

export const PRICINGAPIERROR = {
  InvalidParkingStart: 'InvalidParkingStart',
  InvalidParkingEnd: 'InvalidParkingEnd',
  InvalidParkingTime: 'InvalidParkingTime',
  TooLongParkingTime: 'TooLongParkingTime',
  TooShortParkingTime: 'TooShortParkingTime',
  FreeTicket: 'FreeTicket',
  InsufficientCredit: 'InsufficientCredit',
  NoUsableParkingCardFound: 'NoUsableParkingCardFound',
  PermitCardActive: 'PermitCardActive',
  TicketAlreadyExists: 'TicketAlreadyExists',
  BadDateFormat: 'BadDateFormat',
  CardNotValid: 'CardNotValid',
  TicketAlreadyShortened: 'TicketAlreadyShortened',
  BadRequest: 'BadRequest',
} as const

export type PRICINGAPIERROR = (typeof PRICINGAPIERROR)[keyof typeof PRICINGAPIERROR]

/**
 *
 * @export
 * @interface PaginationInfo
 */
export interface PaginationInfo {
  /**
   * Total number of entities
   * @type {number}
   * @memberof PaginationInfo
   */
  total: number
  /**
   * Current page
   * @type {number}
   * @memberof PaginationInfo
   */
  currentPage: number
  /**
   * Current page size
   * @type {number}
   * @memberof PaginationInfo
   */
  pageSize: number
}
/**
 *
 * @export
 * @interface ParkingCardDto
 */
export interface ParkingCardDto {
  /**
   * Database id of the verified email
   * @type {number}
   * @memberof ParkingCardDto
   */
  id: number
  /**
   * Identificator from parkdots (npkid)
   * @type {string}
   * @memberof ParkingCardDto
   */
  identificator: string
  /**
   *
   * @type {ParkingCardType}
   * @memberof ParkingCardDto
   */
  type: ParkingCardType
  /**
   * Name of the card cheme
   * @type {string}
   * @memberof ParkingCardDto
   */
  name?: string
  /**
   * The vehicle plate number for which the card was issued. (Some cards are not issued to the vehicle. Therefore, it may be missing.)
   * @type {string}
   * @memberof ParkingCardDto
   */
  vehiclePlateNumber?: string
  /**
   * Start of card validity. ISO8601 formatted UTC timestamp
   * @type {string}
   * @memberof ParkingCardDto
   */
  validFrom?: string
  /**
   * End of card validity. ISO8601 formatted UTC timestamp.
   * @type {string}
   * @memberof ParkingCardDto
   */
  validTo?: string
  /**
   * Balance available on the visitor card (PT means \'Period of Time\'. The time format is standardized according to ISO 8601. For example PT1H30M15S - 1 hour 30 minutes 15 seconds.)
   * @type {string}
   * @memberof ParkingCardDto
   */
  balance?: string
  /**
   * Balance available on the visitor card in seconds
   * @type {number}
   * @memberof ParkingCardDto
   */
  balanceSeconds?: number
  /**
   * Original balance available on the visitor card (PT means \'Period of Time\'. The time format is standardized according to ISO 8601. For example PT1H30M15S - 1 hour 30 minutes 15 seconds.)
   * @type {string}
   * @memberof ParkingCardDto
   */
  originalBalance?: string
  /**
   * Original balance available on the visitor card in seconds
   * @type {number}
   * @memberof ParkingCardDto
   */
  originalBalanceSeconds?: number
  /**
   * List of Internal ids of the parking space.
   * @type {Array<string>}
   * @memberof ParkingCardDto
   */
  parkingZones?: Array<string>
  /**
   * Date of the creation
   * @type {string}
   * @memberof ParkingCardDto
   */
  createdAt: string
  /**
   * Date of the last change
   * @type {string}
   * @memberof ParkingCardDto
   */
  updatedAt: string
}

/**
 *
 * @export
 * @enum {string}
 */

export const ParkingCardType = {
  Abonent: 'ABONENT',
  Rezident: 'REZIDENT',
  Bpk: 'BPK',
  Npk: 'NPK',
  Tzp: 'TZP',
  Elektromobil: 'ELEKTROMOBIL',
  Other: 'OTHER',
} as const

export type ParkingCardType = (typeof ParkingCardType)[keyof typeof ParkingCardType]

/**
 *
 * @export
 * @interface ParkingCardsResponseDto
 */
export interface ParkingCardsResponseDto {
  /**
   * List of parking cards
   * @type {Array<ParkingCardDto>}
   * @memberof ParkingCardsResponseDto
   */
  parkingCards: Array<ParkingCardDto>
  /**
   *
   * @type {PaginationInfo}
   * @memberof ParkingCardsResponseDto
   */
  paginationInfo: PaginationInfo
}
/**
 *
 * @export
 * @enum {string}
 */

export const PaymentStatus = {
  Success: 'SUCCESS',
  Pending: 'PENDING',
  Fail: 'FAIL',
  Error: 'ERROR',
} as const

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]

/**
 *
 * @export
 * @interface PaymentUrls
 */
export interface PaymentUrls {
  /**
   * URL address of the payment for Card
   * @type {string}
   * @memberof PaymentUrls
   */
  paymentUrlCard: string
  /**
   * URL address of the payment for APAY
   * @type {string}
   * @memberof PaymentUrls
   */
  paymentUrlAPAY: string
  /**
   * URL address of the payment for GPAY
   * @type {string}
   * @memberof PaymentUrls
   */
  paymentUrlGPAY: string
}
/**
 *
 * @export
 * @enum {string}
 */

export const SERVICEERROR = {
  PricingApiError: 'PRICING_API_ERROR',
  ParkdotsError: 'PARKDOTS_ERROR',
  ParkdotsTokenError: 'PARKDOTS_TOKEN_ERROR',
  PaymentInit: 'PAYMENT_INIT',
  PaymentValidation: 'PAYMENT_VALIDATION',
  EmailVerificationTokenIncorrect: 'EMAIL_VERIFICATION_TOKEN_INCORRECT',
  EmailVerificationTokenExpired: 'EMAIL_VERIFICATION_TOKEN_EXPIRED',
  EmailAlreadyVerified: 'EMAIL_ALREADY_VERIFIED',
  TicketProlongationNonActive: 'TICKET_PROLONGATION_NON_ACTIVE',
  TicketMissingParkdotsId: 'TICKET_MISSING_PARKDOTS_ID',
  PaymentResponseIncorrect: 'PAYMENT_RESPONSE_INCORRECT',
} as const

export type SERVICEERROR = (typeof SERVICEERROR)[keyof typeof SERVICEERROR]

/**
 *
 * @export
 * @enum {string}
 */

export const SYSTEMERROR = {
  DatabaseError: 'DATABASE_ERROR',
  MailgunError: 'MAILGUN_ERROR',
  RabbitMqError: 'RABBIT_MQ_ERROR',
} as const

export type SYSTEMERROR = (typeof SYSTEMERROR)[keyof typeof SYSTEMERROR]

/**
 *
 * @export
 * @interface SaveAnnouncementDto
 */
export interface SaveAnnouncementDto {
  /**
   * Title of the announcement
   * @type {string}
   * @memberof SaveAnnouncementDto
   */
  title: string
  /**
   * Content of the announcement
   * @type {string}
   * @memberof SaveAnnouncementDto
   */
  content: string
  /**
   * Language of the announcement in ISO 639-1 language code
   * @type {string}
   * @memberof SaveAnnouncementDto
   */
  language: string
  /**
   *
   * @type {AnnouncementType}
   * @memberof SaveAnnouncementDto
   */
  type: AnnouncementType
  /**
   * External url to route the user on CTA
   * @type {string}
   * @memberof SaveAnnouncementDto
   */
  externalUrl?: string
}

/**
 *
 * @export
 * @interface SaveMobileDeviceDto
 */
export interface SaveMobileDeviceDto {
  /**
   * Mobile device token for sending push messages
   * @type {string}
   * @memberof SaveMobileDeviceDto
   */
  token: string
  /**
   *
   * @type {MobileDevicePlatform}
   * @memberof SaveMobileDeviceDto
   */
  platform: MobileDevicePlatform
}

/**
 *
 * @export
 * @interface SaveUserSettingsDto
 */
export interface SaveUserSettingsDto {
  /**
   * Set true to send push notifications for tickets about to end
   * @type {boolean}
   * @memberof SaveUserSettingsDto
   */
  pushNotificationsAboutToEnd?: boolean
  /**
   * Set true to send push notifications for tickets about to end
   * @type {boolean}
   * @memberof SaveUserSettingsDto
   */
  pushNotificationsToEnd?: boolean
  /**
   * Set true to send push notifications for tickets about to end
   * @type {boolean}
   * @memberof SaveUserSettingsDto
   */
  emailNotificationsAboutToEnd?: boolean
  /**
   * Set true to send push notifications for tickets about to end
   * @type {boolean}
   * @memberof SaveUserSettingsDto
   */
  emailNotificationsToEnd?: boolean
  /**
   * Set language from front-end to match notifications
   * @type {string}
   * @memberof SaveUserSettingsDto
   */
  language?: string
}
/**
 *
 * @export
 * @interface ServiceErrorDto
 */
export interface ServiceErrorDto {
  /**
   * Status in text
   * @type {string}
   * @memberof ServiceErrorDto
   */
  status: string
  /**
   * Detail error message
   * @type {string}
   * @memberof ServiceErrorDto
   */
  message: string
  /**
   * Status Code
   * @type {number}
   * @memberof ServiceErrorDto
   */
  statusCode: number
  /**
   *
   * @type {SERVICEERROR}
   * @memberof ServiceErrorDto
   */
  errorName: SERVICEERROR
}

/**
 *
 * @export
 * @interface ServicePricingErrorDto
 */
export interface ServicePricingErrorDto {
  /**
   * Status in text
   * @type {string}
   * @memberof ServicePricingErrorDto
   */
  status: string
  /**
   * Detail error message
   * @type {string}
   * @memberof ServicePricingErrorDto
   */
  message: string
  /**
   * Status Code
   * @type {number}
   * @memberof ServicePricingErrorDto
   */
  statusCode: number
  /**
   *
   * @type {PRICINGAPIERROR}
   * @memberof ServicePricingErrorDto
   */
  errorName: PRICINGAPIERROR
}

/**
 *
 * @export
 * @interface SystemErrorDto
 */
export interface SystemErrorDto {
  /**
   * Status in text
   * @type {string}
   * @memberof SystemErrorDto
   */
  status: string
  /**
   * Detail error message
   * @type {string}
   * @memberof SystemErrorDto
   */
  message: string
  /**
   * Status Code
   * @type {number}
   * @memberof SystemErrorDto
   */
  statusCode: number
  /**
   *
   * @type {SYSTEMERROR}
   * @memberof SystemErrorDto
   */
  errorName: SYSTEMERROR
}

/**
 *
 * @export
 * @interface TicketDto
 */
export interface TicketDto {
  /**
   * Database id of the vehicle
   * @type {number}
   * @memberof TicketDto
   */
  id: number
  /**
   * Unique identification of parking slot (specific section of parking regulation)
   * @type {string}
   * @memberof TicketDto
   */
  udr: string
  /**
   * Parking vehicle registration number
   * @type {string}
   * @memberof TicketDto
   */
  ecv: string
  /**
   * Start of the parking
   * @type {string}
   * @memberof TicketDto
   */
  parkingStart: string
  /**
   * End of the parking
   * @type {string}
   * @memberof TicketDto
   */
  parkingEnd: string
  /**
   * Price of the parking
   * @type {number}
   * @memberof TicketDto
   */
  price?: number
  /**
   * Credits used in case of bonus parking in seconds
   * @type {number}
   * @memberof TicketDto
   */
  bpkCreditUsedSeconds: number
  /**
   * Credits used in case of visitor parking in seconds
   * @type {number}
   * @memberof TicketDto
   */
  npkCreditUsedSeconds: number
  /**
   * ID of the visitor card (GUID)
   * @type {string}
   * @memberof TicketDto
   */
  npkId?: string
  /**
   * ID of the bonus card (GUID)
   * @type {string}
   * @memberof TicketDto
   */
  bpkId?: string
  /**
   * ID of the payment in paygate
   * @type {string}
   * @memberof TicketDto
   */
  paymentId?: string
  /**
   *
   * @type {PaymentStatus}
   * @memberof TicketDto
   */
  paymentStatus?: PaymentStatus
  /**
   * Reason of the payment failure. For example: The cardholder canceled the payment
   * @type {string}
   * @memberof TicketDto
   */
  paymentFailReason?: string
  /**
   * Date of the cancellation
   * @type {string}
   * @memberof TicketDto
   */
  canceledAt?: string
  /**
   * ID of the last prolongation ticket.
   * @type {number}
   * @memberof TicketDto
   */
  lastProlongationTicketId?: number
  /**
   * Date of the last change
   * @type {string}
   * @memberof TicketDto
   */
  updatedAt: string
  /**
   * Date of the creation
   * @type {string}
   * @memberof TicketDto
   */
  createdAt: string
}

/**
 *
 * @export
 * @interface TicketInitDto
 */
export interface TicketInitDto {
  /**
   * Database id of the vehicle
   * @type {number}
   * @memberof TicketInitDto
   */
  id: number
  /**
   * Unique identification of parking slot (specific section of parking regulation)
   * @type {string}
   * @memberof TicketInitDto
   */
  udr: string
  /**
   * Parking vehicle registration number
   * @type {string}
   * @memberof TicketInitDto
   */
  ecv: string
  /**
   * Start of the parking
   * @type {string}
   * @memberof TicketInitDto
   */
  parkingStart: string
  /**
   * End of the parking
   * @type {string}
   * @memberof TicketInitDto
   */
  parkingEnd: string
  /**
   * Price of the parking
   * @type {number}
   * @memberof TicketInitDto
   */
  price?: number
  /**
   * Credits used in case of bonus parking in seconds
   * @type {number}
   * @memberof TicketInitDto
   */
  bpkCreditUsedSeconds: number
  /**
   * Credits used in case of visitor parking in seconds
   * @type {number}
   * @memberof TicketInitDto
   */
  npkCreditUsedSeconds: number
  /**
   * ID of the visitor card (GUID)
   * @type {string}
   * @memberof TicketInitDto
   */
  npkId?: string
  /**
   * ID of the bonus card (GUID)
   * @type {string}
   * @memberof TicketInitDto
   */
  bpkId?: string
  /**
   * ID of the payment in paygate
   * @type {string}
   * @memberof TicketInitDto
   */
  paymentId?: string
  /**
   *
   * @type {PaymentStatus}
   * @memberof TicketInitDto
   */
  paymentStatus?: PaymentStatus
  /**
   * Reason of the payment failure. For example: The cardholder canceled the payment
   * @type {string}
   * @memberof TicketInitDto
   */
  paymentFailReason?: string
  /**
   * Date of the cancellation
   * @type {string}
   * @memberof TicketInitDto
   */
  canceledAt?: string
  /**
   * ID of the last prolongation ticket.
   * @type {number}
   * @memberof TicketInitDto
   */
  lastProlongationTicketId?: number
  /**
   * Date of the last change
   * @type {string}
   * @memberof TicketInitDto
   */
  updatedAt: string
  /**
   * Date of the creation
   * @type {string}
   * @memberof TicketInitDto
   */
  createdAt: string
  /**
   *
   * @type {PaymentUrls}
   * @memberof TicketInitDto
   */
  paymentUrls?: PaymentUrls
  /**
   * End of card validity. ISO8601 formatted UTC timestamp.
   * @type {string}
   * @memberof TicketInitDto
   */
  validTo?: string
  /**
   * Balance available on the visitor card in seconds
   * @type {number}
   * @memberof TicketInitDto
   */
  balanceSeconds?: number
  /**
   * Original balance available on the visitor card in seconds
   * @type {number}
   * @memberof TicketInitDto
   */
  originalBalanceSeconds?: number
}

/**
 *
 * @export
 * @interface TicketsControllerGetTicketPrice422Response
 */
export interface TicketsControllerGetTicketPrice422Response {
  /**
   * Status in text
   * @type {string}
   * @memberof TicketsControllerGetTicketPrice422Response
   */
  status: string
  /**
   * Detail error message
   * @type {string}
   * @memberof TicketsControllerGetTicketPrice422Response
   */
  message: string
  /**
   * Status Code
   * @type {number}
   * @memberof TicketsControllerGetTicketPrice422Response
   */
  statusCode: number
  /**
   *
   * @type {PRICINGAPIERROR}
   * @memberof TicketsControllerGetTicketPrice422Response
   */
  errorName: PRICINGAPIERROR
}

/**
 *
 * @export
 * @interface TicketsResponseDto
 */
export interface TicketsResponseDto {
  /**
   * List of tickets
   * @type {Array<TicketDto>}
   * @memberof TicketsResponseDto
   */
  tickets: Array<TicketDto>
  /**
   *
   * @type {PaginationInfo}
   * @memberof TicketsResponseDto
   */
  paginationInfo: PaginationInfo
}
/**
 *
 * @export
 * @interface UnexpectedErrorDto
 */
export interface UnexpectedErrorDto {
  /**
   * Status in text
   * @type {string}
   * @memberof UnexpectedErrorDto
   */
  status: string
  /**
   * Detail error message
   * @type {string}
   * @memberof UnexpectedErrorDto
   */
  message: string
  /**
   * Status Code
   * @type {number}
   * @memberof UnexpectedErrorDto
   */
  statusCode: number
  /**
   * Exact error name
   * @type {string}
   * @memberof UnexpectedErrorDto
   */
  errorName: string
}
/**
 *
 * @export
 * @interface UpdateVehicleDto
 */
export interface UpdateVehicleDto {
  /**
   * License plate number
   * @type {string}
   * @memberof UpdateVehicleDto
   */
  vehiclePlateNumber?: string
  /**
   * Name of the vehicle (user input)
   * @type {string}
   * @memberof UpdateVehicleDto
   */
  name?: string
  /**
   * Set to true to be the default car
   * @type {boolean}
   * @memberof UpdateVehicleDto
   */
  isDefault?: boolean
}
/**
 *
 * @export
 * @interface UserSettingsDto
 */
export interface UserSettingsDto {
  /**
   * Set true to send push notifications for tickets about to end
   * @type {boolean}
   * @memberof UserSettingsDto
   */
  pushNotificationsAboutToEnd: boolean
  /**
   * Set true to send push notifications for tickets about to end
   * @type {boolean}
   * @memberof UserSettingsDto
   */
  pushNotificationsToEnd: boolean
  /**
   * Set true to send push notifications for tickets about to end
   * @type {boolean}
   * @memberof UserSettingsDto
   */
  emailNotificationsAboutToEnd: boolean
  /**
   * Set true to send push notifications for tickets about to end
   * @type {boolean}
   * @memberof UserSettingsDto
   */
  emailNotificationsToEnd: boolean
  /**
   * Language of the application
   * @type {string}
   * @memberof UserSettingsDto
   */
  language?: string
  /**
   * Date of the first creation
   * @type {string}
   * @memberof UserSettingsDto
   */
  createdAt: string
  /**
   * Date of the last modificaiton
   * @type {string}
   * @memberof UserSettingsDto
   */
  updatedAt: string
}
/**
 *
 * @export
 * @interface VehicleDto
 */
export interface VehicleDto {
  /**
   * License plate number
   * @type {string}
   * @memberof VehicleDto
   */
  vehiclePlateNumber: string
  /**
   * Name of the vehicle (user input)
   * @type {string}
   * @memberof VehicleDto
   */
  name?: string
  /**
   * Set to true to be the default car
   * @type {boolean}
   * @memberof VehicleDto
   */
  isDefault: boolean
  /**
   * Database id of the vehicle
   * @type {number}
   * @memberof VehicleDto
   */
  id: number
  /**
   * Date of the creation
   * @type {string}
   * @memberof VehicleDto
   */
  createdAt: string
  /**
   * Date of the last change
   * @type {string}
   * @memberof VehicleDto
   */
  updatedAt: string
}
/**
 *
 * @export
 * @interface VehiclesResponseDto
 */
export interface VehiclesResponseDto {
  /**
   * List of vehicles
   * @type {Array<VehicleDto>}
   * @memberof VehiclesResponseDto
   */
  vehicles: Array<VehicleDto>
  /**
   *
   * @type {PaginationInfo}
   * @memberof VehiclesResponseDto
   */
  paginationInfo: PaginationInfo
}
/**
 *
 * @export
 * @interface VerifiedEmailDto
 */
export interface VerifiedEmailDto {
  /**
   * Database id of the verified email
   * @type {number}
   * @memberof VerifiedEmailDto
   */
  id: number
  /**
   * Email address
   * @type {string}
   * @memberof VerifiedEmailDto
   */
  email: string
  /**
   * Date of the creation
   * @type {string}
   * @memberof VerifiedEmailDto
   */
  createdAt: string
  /**
   * Date of the last change
   * @type {string}
   * @memberof VerifiedEmailDto
   */
  updatedAt: string
}
/**
 *
 * @export
 * @interface VerifiedEmailsResponseDto
 */
export interface VerifiedEmailsResponseDto {
  /**
   * List of verified emails
   * @type {Array<VerifiedEmailDto>}
   * @memberof VerifiedEmailsResponseDto
   */
  verifiedEmails: Array<VerifiedEmailDto>
  /**
   *
   * @type {PaginationInfo}
   * @memberof VerifiedEmailsResponseDto
   */
  paginationInfo: PaginationInfo
}
/**
 *
 * @export
 * @interface VerifyEmailsDto
 */
export interface VerifyEmailsDto {
  /**
   * List of emails to verify
   * @type {Array<string>}
   * @memberof VerifyEmailsDto
   */
  emails: Array<string>
}

/**
 * AnnouncementsApi - axios parameter creator
 * @export
 */
export const AnnouncementsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get all announcements paginated
     * @param {string} language Language of the announcement in ISO 639-1 language code
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    announcementsControllerAnnouncementsGetMany: async (
      language: string,
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'language' is not null or undefined
      assertParamExists('announcementsControllerAnnouncementsGetMany', 'language', language)
      const localVarPath = `/announcements`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (language !== undefined) {
        localVarQueryParameter['language'] = language
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Delete a specific announcement
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    announcementsControllerDeleteAnnouncement: async (
      id: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('announcementsControllerDeleteAnnouncement', 'id', id)
      const localVarPath = `/announcements/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication azure required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Inserts new vehicle
     * @param {SaveAnnouncementDto} saveAnnouncementDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    announcementsControllerInsertAnnouncement: async (
      saveAnnouncementDto: SaveAnnouncementDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'saveAnnouncementDto' is not null or undefined
      assertParamExists(
        'announcementsControllerInsertAnnouncement',
        'saveAnnouncementDto',
        saveAnnouncementDto,
      )
      const localVarPath = `/announcements`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication azure required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        saveAnnouncementDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AnnouncementsApi - functional programming interface
 * @export
 */
export const AnnouncementsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AnnouncementsApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Get all announcements paginated
     * @param {string} language Language of the announcement in ISO 639-1 language code
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async announcementsControllerAnnouncementsGetMany(
      language: string,
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouncementsResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.announcementsControllerAnnouncementsGetMany(
          language,
          page,
          pageSize,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Delete a specific announcement
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async announcementsControllerDeleteAnnouncement(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteResponseDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.announcementsControllerDeleteAnnouncement(id, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Inserts new vehicle
     * @param {SaveAnnouncementDto} saveAnnouncementDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async announcementsControllerInsertAnnouncement(
      saveAnnouncementDto: SaveAnnouncementDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouncementDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.announcementsControllerInsertAnnouncement(
          saveAnnouncementDto,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * AnnouncementsApi - factory interface
 * @export
 */
export const AnnouncementsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AnnouncementsApiFp(configuration)
  return {
    /**
     *
     * @summary Get all announcements paginated
     * @param {string} language Language of the announcement in ISO 639-1 language code
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    announcementsControllerAnnouncementsGetMany(
      language: string,
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<AnnouncementsResponseDto> {
      return localVarFp
        .announcementsControllerAnnouncementsGetMany(language, page, pageSize, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Delete a specific announcement
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    announcementsControllerDeleteAnnouncement(
      id: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<DeleteResponseDto> {
      return localVarFp
        .announcementsControllerDeleteAnnouncement(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Inserts new vehicle
     * @param {SaveAnnouncementDto} saveAnnouncementDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    announcementsControllerInsertAnnouncement(
      saveAnnouncementDto: SaveAnnouncementDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<AnnouncementDto> {
      return localVarFp
        .announcementsControllerInsertAnnouncement(saveAnnouncementDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * AnnouncementsApi - object-oriented interface
 * @export
 * @class AnnouncementsApi
 * @extends {BaseAPI}
 */
export class AnnouncementsApi extends BaseAPI {
  /**
   *
   * @summary Get all announcements paginated
   * @param {string} language Language of the announcement in ISO 639-1 language code
   * @param {number} [page] Page number
   * @param {number} [pageSize] Items per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AnnouncementsApi
   */
  public announcementsControllerAnnouncementsGetMany(
    language: string,
    page?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return AnnouncementsApiFp(this.configuration)
      .announcementsControllerAnnouncementsGetMany(language, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Delete a specific announcement
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AnnouncementsApi
   */
  public announcementsControllerDeleteAnnouncement(id: number, options?: AxiosRequestConfig) {
    return AnnouncementsApiFp(this.configuration)
      .announcementsControllerDeleteAnnouncement(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Inserts new vehicle
   * @param {SaveAnnouncementDto} saveAnnouncementDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AnnouncementsApi
   */
  public announcementsControllerInsertAnnouncement(
    saveAnnouncementDto: SaveAnnouncementDto,
    options?: AxiosRequestConfig,
  ) {
    return AnnouncementsApiFp(this.configuration)
      .announcementsControllerInsertAnnouncement(saveAnnouncementDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Get information about the status of the mpa-backend.
     * @summary Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerHealth: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/healthcheck`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get information about the status of the parking system.
     * @summary Healthcheck for parking system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerHealthParkingSystem: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/healthcheck/parking-sytem`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
  return {
    /**
     * Get information about the status of the mpa-backend.
     * @summary Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async appControllerHealth(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerHealth(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get information about the status of the parking system.
     * @summary Healthcheck for parking system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async appControllerHealthParkingSystem(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerHealthParkingSystem(
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DefaultApiFp(configuration)
  return {
    /**
     * Get information about the status of the mpa-backend.
     * @summary Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerHealth(options?: AxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.appControllerHealth(options).then((request) => request(axios, basePath))
    },
    /**
     * Get information about the status of the parking system.
     * @summary Healthcheck for parking system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerHealthParkingSystem(options?: AxiosRequestConfig): AxiosPromise<void> {
      return localVarFp
        .appControllerHealthParkingSystem(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   * Get information about the status of the mpa-backend.
   * @summary Healthcheck
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public appControllerHealth(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .appControllerHealth(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get information about the status of the parking system.
   * @summary Healthcheck for parking system
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public appControllerHealthParkingSystem(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .appControllerHealthParkingSystem(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * MobileDevicesApi - axios parameter creator
 * @export
 */
export const MobileDevicesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete a specific mobile device
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mobileDevicesControllerDeleteMobileDevice: async (
      id: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('mobileDevicesControllerDeleteMobileDevice', 'id', id)
      const localVarPath = `/mobile-devices/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get all mobile devices associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mobileDevicesControllerDevicesGetMany: async (
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/mobile-devices`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Inserts new mobile device
     * @param {SaveMobileDeviceDto} saveMobileDeviceDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mobileDevicesControllerInsertMobileDevice: async (
      saveMobileDeviceDto: SaveMobileDeviceDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'saveMobileDeviceDto' is not null or undefined
      assertParamExists(
        'mobileDevicesControllerInsertMobileDevice',
        'saveMobileDeviceDto',
        saveMobileDeviceDto,
      )
      const localVarPath = `/mobile-devices`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        saveMobileDeviceDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * MobileDevicesApi - functional programming interface
 * @export
 */
export const MobileDevicesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = MobileDevicesApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Delete a specific mobile device
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mobileDevicesControllerDeleteMobileDevice(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteResponseDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.mobileDevicesControllerDeleteMobileDevice(id, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all mobile devices associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mobileDevicesControllerDevicesGetMany(
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MobileDeviceResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.mobileDevicesControllerDevicesGetMany(
          page,
          pageSize,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Inserts new mobile device
     * @param {SaveMobileDeviceDto} saveMobileDeviceDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mobileDevicesControllerInsertMobileDevice(
      saveMobileDeviceDto: SaveMobileDeviceDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MobileDeviceDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.mobileDevicesControllerInsertMobileDevice(
          saveMobileDeviceDto,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * MobileDevicesApi - factory interface
 * @export
 */
export const MobileDevicesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = MobileDevicesApiFp(configuration)
  return {
    /**
     *
     * @summary Delete a specific mobile device
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mobileDevicesControllerDeleteMobileDevice(
      id: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<DeleteResponseDto> {
      return localVarFp
        .mobileDevicesControllerDeleteMobileDevice(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get all mobile devices associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mobileDevicesControllerDevicesGetMany(
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<MobileDeviceResponseDto> {
      return localVarFp
        .mobileDevicesControllerDevicesGetMany(page, pageSize, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Inserts new mobile device
     * @param {SaveMobileDeviceDto} saveMobileDeviceDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mobileDevicesControllerInsertMobileDevice(
      saveMobileDeviceDto: SaveMobileDeviceDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<MobileDeviceDto> {
      return localVarFp
        .mobileDevicesControllerInsertMobileDevice(saveMobileDeviceDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * MobileDevicesApi - object-oriented interface
 * @export
 * @class MobileDevicesApi
 * @extends {BaseAPI}
 */
export class MobileDevicesApi extends BaseAPI {
  /**
   *
   * @summary Delete a specific mobile device
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MobileDevicesApi
   */
  public mobileDevicesControllerDeleteMobileDevice(id: number, options?: AxiosRequestConfig) {
    return MobileDevicesApiFp(this.configuration)
      .mobileDevicesControllerDeleteMobileDevice(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all mobile devices associated with the user
   * @param {number} [page] Page number
   * @param {number} [pageSize] Items per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MobileDevicesApi
   */
  public mobileDevicesControllerDevicesGetMany(
    page?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return MobileDevicesApiFp(this.configuration)
      .mobileDevicesControllerDevicesGetMany(page, pageSize, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Inserts new mobile device
   * @param {SaveMobileDeviceDto} saveMobileDeviceDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MobileDevicesApi
   */
  public mobileDevicesControllerInsertMobileDevice(
    saveMobileDeviceDto: SaveMobileDeviceDto,
    options?: AxiosRequestConfig,
  ) {
    return MobileDevicesApiFp(this.configuration)
      .mobileDevicesControllerInsertMobileDevice(saveMobileDeviceDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ParkingCardsApi - axios parameter creator
 * @export
 */
export const ParkingCardsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get all active visitor cards associated with the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    parkingCardsControllerGetActiveVisitorCards: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/parking-cards/visitor-cards`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get all parking cards associated with the user
     * @param {string} email Email
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    parkingCardsControllerGetParkingCards: async (
      email: string,
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'email' is not null or undefined
      assertParamExists('parkingCardsControllerGetParkingCards', 'email', email)
      const localVarPath = `/parking-cards`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (email !== undefined) {
        localVarQueryParameter['email'] = email
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ParkingCardsApi - functional programming interface
 * @export
 */
export const ParkingCardsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ParkingCardsApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Get all active visitor cards associated with the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async parkingCardsControllerGetActiveVisitorCards(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ParkingCardDto>>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.parkingCardsControllerGetActiveVisitorCards(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all parking cards associated with the user
     * @param {string} email Email
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async parkingCardsControllerGetParkingCards(
      email: string,
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParkingCardsResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.parkingCardsControllerGetParkingCards(
          email,
          page,
          pageSize,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * ParkingCardsApi - factory interface
 * @export
 */
export const ParkingCardsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ParkingCardsApiFp(configuration)
  return {
    /**
     *
     * @summary Get all active visitor cards associated with the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    parkingCardsControllerGetActiveVisitorCards(
      options?: AxiosRequestConfig,
    ): AxiosPromise<Array<ParkingCardDto>> {
      return localVarFp
        .parkingCardsControllerGetActiveVisitorCards(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get all parking cards associated with the user
     * @param {string} email Email
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    parkingCardsControllerGetParkingCards(
      email: string,
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<ParkingCardsResponseDto> {
      return localVarFp
        .parkingCardsControllerGetParkingCards(email, page, pageSize, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ParkingCardsApi - object-oriented interface
 * @export
 * @class ParkingCardsApi
 * @extends {BaseAPI}
 */
export class ParkingCardsApi extends BaseAPI {
  /**
   *
   * @summary Get all active visitor cards associated with the user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ParkingCardsApi
   */
  public parkingCardsControllerGetActiveVisitorCards(options?: AxiosRequestConfig) {
    return ParkingCardsApiFp(this.configuration)
      .parkingCardsControllerGetActiveVisitorCards(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all parking cards associated with the user
   * @param {string} email Email
   * @param {number} [page] Page number
   * @param {number} [pageSize] Items per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ParkingCardsApi
   */
  public parkingCardsControllerGetParkingCards(
    email: string,
    page?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return ParkingCardsApiFp(this.configuration)
      .parkingCardsControllerGetParkingCards(email, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * SystemApi - axios parameter creator
 * @export
 */
export const SystemApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get mobile app version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    systemControllerGetMobileAppVersion: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/system/version`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Send feedback
     * @param {FeedbackDto} feedbackDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    systemControllerSendFeedback: async (
      feedbackDto: FeedbackDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'feedbackDto' is not null or undefined
      assertParamExists('systemControllerSendFeedback', 'feedbackDto', feedbackDto)
      const localVarPath = `/system/feedback`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        feedbackDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update mobile app version
     * @param {MobileAppVersionUpdateDto} mobileAppVersionUpdateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    systemControllerUpdateMobileAppVersion: async (
      mobileAppVersionUpdateDto: MobileAppVersionUpdateDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'mobileAppVersionUpdateDto' is not null or undefined
      assertParamExists(
        'systemControllerUpdateMobileAppVersion',
        'mobileAppVersionUpdateDto',
        mobileAppVersionUpdateDto,
      )
      const localVarPath = `/system/version`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication azure required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        mobileAppVersionUpdateDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SystemApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Get mobile app version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async systemControllerGetMobileAppVersion(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.systemControllerGetMobileAppVersion(
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Send feedback
     * @param {FeedbackDto} feedbackDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async systemControllerSendFeedback(
      feedbackDto: FeedbackDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.systemControllerSendFeedback(
        feedbackDto,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Update mobile app version
     * @param {MobileAppVersionUpdateDto} mobileAppVersionUpdateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async systemControllerUpdateMobileAppVersion(
      mobileAppVersionUpdateDto: MobileAppVersionUpdateDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.systemControllerUpdateMobileAppVersion(
          mobileAppVersionUpdateDto,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SystemApiFp(configuration)
  return {
    /**
     *
     * @summary Get mobile app version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    systemControllerGetMobileAppVersion(options?: AxiosRequestConfig): AxiosPromise<string> {
      return localVarFp
        .systemControllerGetMobileAppVersion(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Send feedback
     * @param {FeedbackDto} feedbackDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    systemControllerSendFeedback(
      feedbackDto: FeedbackDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<boolean> {
      return localVarFp
        .systemControllerSendFeedback(feedbackDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update mobile app version
     * @param {MobileAppVersionUpdateDto} mobileAppVersionUpdateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    systemControllerUpdateMobileAppVersion(
      mobileAppVersionUpdateDto: MobileAppVersionUpdateDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<string> {
      return localVarFp
        .systemControllerUpdateMobileAppVersion(mobileAppVersionUpdateDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
  /**
   *
   * @summary Get mobile app version
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public systemControllerGetMobileAppVersion(options?: AxiosRequestConfig) {
    return SystemApiFp(this.configuration)
      .systemControllerGetMobileAppVersion(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Send feedback
   * @param {FeedbackDto} feedbackDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public systemControllerSendFeedback(feedbackDto: FeedbackDto, options?: AxiosRequestConfig) {
    return SystemApiFp(this.configuration)
      .systemControllerSendFeedback(feedbackDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update mobile app version
   * @param {MobileAppVersionUpdateDto} mobileAppVersionUpdateDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public systemControllerUpdateMobileAppVersion(
    mobileAppVersionUpdateDto: MobileAppVersionUpdateDto,
    options?: AxiosRequestConfig,
  ) {
    return SystemApiFp(this.configuration)
      .systemControllerUpdateMobileAppVersion(mobileAppVersionUpdateDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * TicketsApi - axios parameter creator
 * @export
 */
export const TicketsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Admin endpoint: Capture payment
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerCapturePayment: async (
      id: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('ticketsControllerCapturePayment', 'id', id)
      const localVarPath = `/tickets/capture-payment/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication azure required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get URL to ticket receipt
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerGetReceipt: async (
      id: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('ticketsControllerGetReceipt', 'id', id)
      const localVarPath = `/tickets/receipt/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get price of the ticket after a potenial ticket shortening
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerGetShortenTicketPrice: async (
      id: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('ticketsControllerGetShortenTicketPrice', 'id', id)
      const localVarPath = `/tickets/shorten/{id}/price`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get ticket price
     * @param {GetTicketPriceRequestDto} getTicketPriceRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerGetTicketPrice: async (
      getTicketPriceRequestDto: GetTicketPriceRequestDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getTicketPriceRequestDto' is not null or undefined
      assertParamExists(
        'ticketsControllerGetTicketPrice',
        'getTicketPriceRequestDto',
        getTicketPriceRequestDto,
      )
      const localVarPath = `/tickets/price`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        getTicketPriceRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get ticket prolongation price
     * @param {GetTicketProlongationPriceRequestDto} getTicketProlongationPriceRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerGetTicketProlongationPrice: async (
      getTicketProlongationPriceRequestDto: GetTicketProlongationPriceRequestDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getTicketProlongationPriceRequestDto' is not null or undefined
      assertParamExists(
        'ticketsControllerGetTicketProlongationPrice',
        'getTicketProlongationPriceRequestDto',
        getTicketProlongationPriceRequestDto,
      )
      const localVarPath = `/tickets/prolongation/price`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        getTicketProlongationPriceRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Initiate ticket payment
     * @param {InitiatePaymentRequestDto} initiatePaymentRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerInitiateTicketPayment: async (
      initiatePaymentRequestDto: InitiatePaymentRequestDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'initiatePaymentRequestDto' is not null or undefined
      assertParamExists(
        'ticketsControllerInitiateTicketPayment',
        'initiatePaymentRequestDto',
        initiatePaymentRequestDto,
      )
      const localVarPath = `/tickets/payment`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        initiatePaymentRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Initiate prolongation ticket payment
     * @param {InitiateProlongationRequestDto} initiateProlongationRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerInitiateTicketProlongationPayment: async (
      initiateProlongationRequestDto: InitiateProlongationRequestDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'initiateProlongationRequestDto' is not null or undefined
      assertParamExists(
        'ticketsControllerInitiateTicketProlongationPayment',
        'initiateProlongationRequestDto',
        initiateProlongationRequestDto,
      )
      const localVarPath = `/tickets/prolongation/payment`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        initiateProlongationRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Process ticket payment. This endpoint is called by the payment gate.
     * @param {string} oPERATION Operation text coming from the paygate return url query param
     * @param {string} oRDERNUMBER Ordernumber text coming from the paygate return url query param (13 characters long number)
     * @param {string} pRCODE Prcode text coming from the paygate return url query param
     * @param {string} sRCODE Srcode text coming from the paygate return url query param
     * @param {string} dIGEST Digest text coming from the paygate return url query param
     * @param {string} dIGEST1 Digest1 text coming from the paygate return url query param
     * @param {string} rESULTTEXT Result text coming from the paygate return url query param
     * @param {string} mD Custom data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerProcessTicketPayment: async (
      oPERATION: string,
      oRDERNUMBER: string,
      pRCODE: string,
      sRCODE: string,
      dIGEST: string,
      dIGEST1: string,
      rESULTTEXT: string,
      mD: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'oPERATION' is not null or undefined
      assertParamExists('ticketsControllerProcessTicketPayment', 'oPERATION', oPERATION)
      // verify required parameter 'oRDERNUMBER' is not null or undefined
      assertParamExists('ticketsControllerProcessTicketPayment', 'oRDERNUMBER', oRDERNUMBER)
      // verify required parameter 'pRCODE' is not null or undefined
      assertParamExists('ticketsControllerProcessTicketPayment', 'pRCODE', pRCODE)
      // verify required parameter 'sRCODE' is not null or undefined
      assertParamExists('ticketsControllerProcessTicketPayment', 'sRCODE', sRCODE)
      // verify required parameter 'dIGEST' is not null or undefined
      assertParamExists('ticketsControllerProcessTicketPayment', 'dIGEST', dIGEST)
      // verify required parameter 'dIGEST1' is not null or undefined
      assertParamExists('ticketsControllerProcessTicketPayment', 'dIGEST1', dIGEST1)
      // verify required parameter 'rESULTTEXT' is not null or undefined
      assertParamExists('ticketsControllerProcessTicketPayment', 'rESULTTEXT', rESULTTEXT)
      // verify required parameter 'mD' is not null or undefined
      assertParamExists('ticketsControllerProcessTicketPayment', 'mD', mD)
      const localVarPath = `/tickets/payment/process`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (oPERATION !== undefined) {
        localVarQueryParameter['OPERATION'] = oPERATION
      }

      if (oRDERNUMBER !== undefined) {
        localVarQueryParameter['ORDERNUMBER'] = oRDERNUMBER
      }

      if (pRCODE !== undefined) {
        localVarQueryParameter['PRCODE'] = pRCODE
      }

      if (sRCODE !== undefined) {
        localVarQueryParameter['SRCODE'] = sRCODE
      }

      if (dIGEST !== undefined) {
        localVarQueryParameter['DIGEST'] = dIGEST
      }

      if (dIGEST1 !== undefined) {
        localVarQueryParameter['DIGEST1'] = dIGEST1
      }

      if (rESULTTEXT !== undefined) {
        localVarQueryParameter['RESULTTEXT'] = rESULTTEXT
      }

      if (mD !== undefined) {
        localVarQueryParameter['MD'] = mD
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Process ticket prolongation payment. This endpoint is called by the payment gate.
     * @param {string} oPERATION Operation text coming from the paygate return url query param
     * @param {string} oRDERNUMBER Ordernumber text coming from the paygate return url query param (13 characters long number)
     * @param {string} pRCODE Prcode text coming from the paygate return url query param
     * @param {string} sRCODE Srcode text coming from the paygate return url query param
     * @param {string} dIGEST Digest text coming from the paygate return url query param
     * @param {string} dIGEST1 Digest1 text coming from the paygate return url query param
     * @param {string} rESULTTEXT Result text coming from the paygate return url query param
     * @param {string} mD Custom data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerProcessTicketProlongationPayment: async (
      oPERATION: string,
      oRDERNUMBER: string,
      pRCODE: string,
      sRCODE: string,
      dIGEST: string,
      dIGEST1: string,
      rESULTTEXT: string,
      mD: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'oPERATION' is not null or undefined
      assertParamExists('ticketsControllerProcessTicketProlongationPayment', 'oPERATION', oPERATION)
      // verify required parameter 'oRDERNUMBER' is not null or undefined
      assertParamExists(
        'ticketsControllerProcessTicketProlongationPayment',
        'oRDERNUMBER',
        oRDERNUMBER,
      )
      // verify required parameter 'pRCODE' is not null or undefined
      assertParamExists('ticketsControllerProcessTicketProlongationPayment', 'pRCODE', pRCODE)
      // verify required parameter 'sRCODE' is not null or undefined
      assertParamExists('ticketsControllerProcessTicketProlongationPayment', 'sRCODE', sRCODE)
      // verify required parameter 'dIGEST' is not null or undefined
      assertParamExists('ticketsControllerProcessTicketProlongationPayment', 'dIGEST', dIGEST)
      // verify required parameter 'dIGEST1' is not null or undefined
      assertParamExists('ticketsControllerProcessTicketProlongationPayment', 'dIGEST1', dIGEST1)
      // verify required parameter 'rESULTTEXT' is not null or undefined
      assertParamExists(
        'ticketsControllerProcessTicketProlongationPayment',
        'rESULTTEXT',
        rESULTTEXT,
      )
      // verify required parameter 'mD' is not null or undefined
      assertParamExists('ticketsControllerProcessTicketProlongationPayment', 'mD', mD)
      const localVarPath = `/tickets/payment/prolongation/process`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (oPERATION !== undefined) {
        localVarQueryParameter['OPERATION'] = oPERATION
      }

      if (oRDERNUMBER !== undefined) {
        localVarQueryParameter['ORDERNUMBER'] = oRDERNUMBER
      }

      if (pRCODE !== undefined) {
        localVarQueryParameter['PRCODE'] = pRCODE
      }

      if (sRCODE !== undefined) {
        localVarQueryParameter['SRCODE'] = sRCODE
      }

      if (dIGEST !== undefined) {
        localVarQueryParameter['DIGEST'] = dIGEST
      }

      if (dIGEST1 !== undefined) {
        localVarQueryParameter['DIGEST1'] = dIGEST1
      }

      if (rESULTTEXT !== undefined) {
        localVarQueryParameter['RESULTTEXT'] = rESULTTEXT
      }

      if (mD !== undefined) {
        localVarQueryParameter['MD'] = mD
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Shorten existing ticket
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerShortenTicket: async (
      id: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('ticketsControllerShortenTicket', 'id', id)
      const localVarPath = `/tickets/shorten/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get tickets paginated
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {string} [ecv] ECV of the vehicle which has the ticket (support a list of values, separated by comma)
     * @param {string} [parkingStartFrom] Lower bound for parking start
     * @param {string} [parkingStartTo] Upper bound for parking start
     * @param {string} [parkingEndFrom] Lower bound for parking end
     * @param {string} [parkingEndTo] Upper bound for parking end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerTicketsGetMany: async (
      page?: number,
      pageSize?: number,
      ecv?: string,
      parkingStartFrom?: string,
      parkingStartTo?: string,
      parkingEndFrom?: string,
      parkingEndTo?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/tickets`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (ecv !== undefined) {
        localVarQueryParameter['ecv'] = ecv
      }

      if (parkingStartFrom !== undefined) {
        localVarQueryParameter['parkingStartFrom'] = parkingStartFrom
      }

      if (parkingStartTo !== undefined) {
        localVarQueryParameter['parkingStartTo'] = parkingStartTo
      }

      if (parkingEndFrom !== undefined) {
        localVarQueryParameter['parkingEndFrom'] = parkingEndFrom
      }

      if (parkingEndTo !== undefined) {
        localVarQueryParameter['parkingEndTo'] = parkingEndTo
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get single ticket
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerTicketsGetOne: async (
      id: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('ticketsControllerTicketsGetOne', 'id', id)
      const localVarPath = `/tickets/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * TicketsApi - functional programming interface
 * @export
 */
export const TicketsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TicketsApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Admin endpoint: Capture payment
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerCapturePayment(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ticketsControllerCapturePayment(
        id,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get URL to ticket receipt
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerGetReceipt(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ticketsControllerGetReceipt(
        id,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get price of the ticket after a potenial ticket shortening
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerGetShortenTicketPrice(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTicketPriceResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.ticketsControllerGetShortenTicketPrice(id, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get ticket price
     * @param {GetTicketPriceRequestDto} getTicketPriceRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerGetTicketPrice(
      getTicketPriceRequestDto: GetTicketPriceRequestDto,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTicketPriceResponseDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ticketsControllerGetTicketPrice(
        getTicketPriceRequestDto,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get ticket prolongation price
     * @param {GetTicketProlongationPriceRequestDto} getTicketProlongationPriceRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerGetTicketProlongationPrice(
      getTicketProlongationPriceRequestDto: GetTicketProlongationPriceRequestDto,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTicketPriceResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.ticketsControllerGetTicketProlongationPrice(
          getTicketProlongationPriceRequestDto,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Initiate ticket payment
     * @param {InitiatePaymentRequestDto} initiatePaymentRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerInitiateTicketPayment(
      initiatePaymentRequestDto: InitiatePaymentRequestDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketInitDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.ticketsControllerInitiateTicketPayment(
          initiatePaymentRequestDto,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Initiate prolongation ticket payment
     * @param {InitiateProlongationRequestDto} initiateProlongationRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerInitiateTicketProlongationPayment(
      initiateProlongationRequestDto: InitiateProlongationRequestDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketInitDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.ticketsControllerInitiateTicketProlongationPayment(
          initiateProlongationRequestDto,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Process ticket payment. This endpoint is called by the payment gate.
     * @param {string} oPERATION Operation text coming from the paygate return url query param
     * @param {string} oRDERNUMBER Ordernumber text coming from the paygate return url query param (13 characters long number)
     * @param {string} pRCODE Prcode text coming from the paygate return url query param
     * @param {string} sRCODE Srcode text coming from the paygate return url query param
     * @param {string} dIGEST Digest text coming from the paygate return url query param
     * @param {string} dIGEST1 Digest1 text coming from the paygate return url query param
     * @param {string} rESULTTEXT Result text coming from the paygate return url query param
     * @param {string} mD Custom data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerProcessTicketPayment(
      oPERATION: string,
      oRDERNUMBER: string,
      pRCODE: string,
      sRCODE: string,
      dIGEST: string,
      dIGEST1: string,
      rESULTTEXT: string,
      mD: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.ticketsControllerProcessTicketPayment(
          oPERATION,
          oRDERNUMBER,
          pRCODE,
          sRCODE,
          dIGEST,
          dIGEST1,
          rESULTTEXT,
          mD,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Process ticket prolongation payment. This endpoint is called by the payment gate.
     * @param {string} oPERATION Operation text coming from the paygate return url query param
     * @param {string} oRDERNUMBER Ordernumber text coming from the paygate return url query param (13 characters long number)
     * @param {string} pRCODE Prcode text coming from the paygate return url query param
     * @param {string} sRCODE Srcode text coming from the paygate return url query param
     * @param {string} dIGEST Digest text coming from the paygate return url query param
     * @param {string} dIGEST1 Digest1 text coming from the paygate return url query param
     * @param {string} rESULTTEXT Result text coming from the paygate return url query param
     * @param {string} mD Custom data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerProcessTicketProlongationPayment(
      oPERATION: string,
      oRDERNUMBER: string,
      pRCODE: string,
      sRCODE: string,
      dIGEST: string,
      dIGEST1: string,
      rESULTTEXT: string,
      mD: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.ticketsControllerProcessTicketProlongationPayment(
          oPERATION,
          oRDERNUMBER,
          pRCODE,
          sRCODE,
          dIGEST,
          dIGEST1,
          rESULTTEXT,
          mD,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Shorten existing ticket
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerShortenTicket(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ticketsControllerShortenTicket(
        id,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get tickets paginated
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {string} [ecv] ECV of the vehicle which has the ticket (support a list of values, separated by comma)
     * @param {string} [parkingStartFrom] Lower bound for parking start
     * @param {string} [parkingStartTo] Upper bound for parking start
     * @param {string} [parkingEndFrom] Lower bound for parking end
     * @param {string} [parkingEndTo] Upper bound for parking end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerTicketsGetMany(
      page?: number,
      pageSize?: number,
      ecv?: string,
      parkingStartFrom?: string,
      parkingStartTo?: string,
      parkingEndFrom?: string,
      parkingEndTo?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketsResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ticketsControllerTicketsGetMany(
        page,
        pageSize,
        ecv,
        parkingStartFrom,
        parkingStartTo,
        parkingEndFrom,
        parkingEndTo,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get single ticket
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerTicketsGetOne(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ticketsControllerTicketsGetOne(
        id,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * TicketsApi - factory interface
 * @export
 */
export const TicketsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = TicketsApiFp(configuration)
  return {
    /**
     *
     * @summary Admin endpoint: Capture payment
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerCapturePayment(id: number, options?: AxiosRequestConfig): AxiosPromise<void> {
      return localVarFp
        .ticketsControllerCapturePayment(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get URL to ticket receipt
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerGetReceipt(id: number, options?: AxiosRequestConfig): AxiosPromise<string> {
      return localVarFp
        .ticketsControllerGetReceipt(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get price of the ticket after a potenial ticket shortening
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerGetShortenTicketPrice(
      id: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<GetTicketPriceResponseDto> {
      return localVarFp
        .ticketsControllerGetShortenTicketPrice(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get ticket price
     * @param {GetTicketPriceRequestDto} getTicketPriceRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerGetTicketPrice(
      getTicketPriceRequestDto: GetTicketPriceRequestDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<GetTicketPriceResponseDto> {
      return localVarFp
        .ticketsControllerGetTicketPrice(getTicketPriceRequestDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get ticket prolongation price
     * @param {GetTicketProlongationPriceRequestDto} getTicketProlongationPriceRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerGetTicketProlongationPrice(
      getTicketProlongationPriceRequestDto: GetTicketProlongationPriceRequestDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<GetTicketPriceResponseDto> {
      return localVarFp
        .ticketsControllerGetTicketProlongationPrice(getTicketProlongationPriceRequestDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Initiate ticket payment
     * @param {InitiatePaymentRequestDto} initiatePaymentRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerInitiateTicketPayment(
      initiatePaymentRequestDto: InitiatePaymentRequestDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<TicketInitDto> {
      return localVarFp
        .ticketsControllerInitiateTicketPayment(initiatePaymentRequestDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Initiate prolongation ticket payment
     * @param {InitiateProlongationRequestDto} initiateProlongationRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerInitiateTicketProlongationPayment(
      initiateProlongationRequestDto: InitiateProlongationRequestDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<TicketInitDto> {
      return localVarFp
        .ticketsControllerInitiateTicketProlongationPayment(initiateProlongationRequestDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Process ticket payment. This endpoint is called by the payment gate.
     * @param {string} oPERATION Operation text coming from the paygate return url query param
     * @param {string} oRDERNUMBER Ordernumber text coming from the paygate return url query param (13 characters long number)
     * @param {string} pRCODE Prcode text coming from the paygate return url query param
     * @param {string} sRCODE Srcode text coming from the paygate return url query param
     * @param {string} dIGEST Digest text coming from the paygate return url query param
     * @param {string} dIGEST1 Digest1 text coming from the paygate return url query param
     * @param {string} rESULTTEXT Result text coming from the paygate return url query param
     * @param {string} mD Custom data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerProcessTicketPayment(
      oPERATION: string,
      oRDERNUMBER: string,
      pRCODE: string,
      sRCODE: string,
      dIGEST: string,
      dIGEST1: string,
      rESULTTEXT: string,
      mD: string,
      options?: AxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .ticketsControllerProcessTicketPayment(
          oPERATION,
          oRDERNUMBER,
          pRCODE,
          sRCODE,
          dIGEST,
          dIGEST1,
          rESULTTEXT,
          mD,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Process ticket prolongation payment. This endpoint is called by the payment gate.
     * @param {string} oPERATION Operation text coming from the paygate return url query param
     * @param {string} oRDERNUMBER Ordernumber text coming from the paygate return url query param (13 characters long number)
     * @param {string} pRCODE Prcode text coming from the paygate return url query param
     * @param {string} sRCODE Srcode text coming from the paygate return url query param
     * @param {string} dIGEST Digest text coming from the paygate return url query param
     * @param {string} dIGEST1 Digest1 text coming from the paygate return url query param
     * @param {string} rESULTTEXT Result text coming from the paygate return url query param
     * @param {string} mD Custom data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerProcessTicketProlongationPayment(
      oPERATION: string,
      oRDERNUMBER: string,
      pRCODE: string,
      sRCODE: string,
      dIGEST: string,
      dIGEST1: string,
      rESULTTEXT: string,
      mD: string,
      options?: AxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .ticketsControllerProcessTicketProlongationPayment(
          oPERATION,
          oRDERNUMBER,
          pRCODE,
          sRCODE,
          dIGEST,
          dIGEST1,
          rESULTTEXT,
          mD,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Shorten existing ticket
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerShortenTicket(
      id: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<TicketDto> {
      return localVarFp
        .ticketsControllerShortenTicket(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get tickets paginated
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {string} [ecv] ECV of the vehicle which has the ticket (support a list of values, separated by comma)
     * @param {string} [parkingStartFrom] Lower bound for parking start
     * @param {string} [parkingStartTo] Upper bound for parking start
     * @param {string} [parkingEndFrom] Lower bound for parking end
     * @param {string} [parkingEndTo] Upper bound for parking end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerTicketsGetMany(
      page?: number,
      pageSize?: number,
      ecv?: string,
      parkingStartFrom?: string,
      parkingStartTo?: string,
      parkingEndFrom?: string,
      parkingEndTo?: string,
      options?: AxiosRequestConfig,
    ): AxiosPromise<TicketsResponseDto> {
      return localVarFp
        .ticketsControllerTicketsGetMany(
          page,
          pageSize,
          ecv,
          parkingStartFrom,
          parkingStartTo,
          parkingEndFrom,
          parkingEndTo,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get single ticket
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerTicketsGetOne(
      id: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<TicketDto> {
      return localVarFp
        .ticketsControllerTicketsGetOne(id, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * TicketsApi - object-oriented interface
 * @export
 * @class TicketsApi
 * @extends {BaseAPI}
 */
export class TicketsApi extends BaseAPI {
  /**
   *
   * @summary Admin endpoint: Capture payment
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerCapturePayment(id: number, options?: AxiosRequestConfig) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerCapturePayment(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get URL to ticket receipt
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerGetReceipt(id: number, options?: AxiosRequestConfig) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerGetReceipt(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get price of the ticket after a potenial ticket shortening
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerGetShortenTicketPrice(id: number, options?: AxiosRequestConfig) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerGetShortenTicketPrice(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get ticket price
   * @param {GetTicketPriceRequestDto} getTicketPriceRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerGetTicketPrice(
    getTicketPriceRequestDto: GetTicketPriceRequestDto,
    options?: AxiosRequestConfig,
  ) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerGetTicketPrice(getTicketPriceRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get ticket prolongation price
   * @param {GetTicketProlongationPriceRequestDto} getTicketProlongationPriceRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerGetTicketProlongationPrice(
    getTicketProlongationPriceRequestDto: GetTicketProlongationPriceRequestDto,
    options?: AxiosRequestConfig,
  ) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerGetTicketProlongationPrice(getTicketProlongationPriceRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Initiate ticket payment
   * @param {InitiatePaymentRequestDto} initiatePaymentRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerInitiateTicketPayment(
    initiatePaymentRequestDto: InitiatePaymentRequestDto,
    options?: AxiosRequestConfig,
  ) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerInitiateTicketPayment(initiatePaymentRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Initiate prolongation ticket payment
   * @param {InitiateProlongationRequestDto} initiateProlongationRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerInitiateTicketProlongationPayment(
    initiateProlongationRequestDto: InitiateProlongationRequestDto,
    options?: AxiosRequestConfig,
  ) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerInitiateTicketProlongationPayment(initiateProlongationRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Process ticket payment. This endpoint is called by the payment gate.
   * @param {string} oPERATION Operation text coming from the paygate return url query param
   * @param {string} oRDERNUMBER Ordernumber text coming from the paygate return url query param (13 characters long number)
   * @param {string} pRCODE Prcode text coming from the paygate return url query param
   * @param {string} sRCODE Srcode text coming from the paygate return url query param
   * @param {string} dIGEST Digest text coming from the paygate return url query param
   * @param {string} dIGEST1 Digest1 text coming from the paygate return url query param
   * @param {string} rESULTTEXT Result text coming from the paygate return url query param
   * @param {string} mD Custom data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerProcessTicketPayment(
    oPERATION: string,
    oRDERNUMBER: string,
    pRCODE: string,
    sRCODE: string,
    dIGEST: string,
    dIGEST1: string,
    rESULTTEXT: string,
    mD: string,
    options?: AxiosRequestConfig,
  ) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerProcessTicketPayment(
        oPERATION,
        oRDERNUMBER,
        pRCODE,
        sRCODE,
        dIGEST,
        dIGEST1,
        rESULTTEXT,
        mD,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Process ticket prolongation payment. This endpoint is called by the payment gate.
   * @param {string} oPERATION Operation text coming from the paygate return url query param
   * @param {string} oRDERNUMBER Ordernumber text coming from the paygate return url query param (13 characters long number)
   * @param {string} pRCODE Prcode text coming from the paygate return url query param
   * @param {string} sRCODE Srcode text coming from the paygate return url query param
   * @param {string} dIGEST Digest text coming from the paygate return url query param
   * @param {string} dIGEST1 Digest1 text coming from the paygate return url query param
   * @param {string} rESULTTEXT Result text coming from the paygate return url query param
   * @param {string} mD Custom data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerProcessTicketProlongationPayment(
    oPERATION: string,
    oRDERNUMBER: string,
    pRCODE: string,
    sRCODE: string,
    dIGEST: string,
    dIGEST1: string,
    rESULTTEXT: string,
    mD: string,
    options?: AxiosRequestConfig,
  ) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerProcessTicketProlongationPayment(
        oPERATION,
        oRDERNUMBER,
        pRCODE,
        sRCODE,
        dIGEST,
        dIGEST1,
        rESULTTEXT,
        mD,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Shorten existing ticket
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerShortenTicket(id: number, options?: AxiosRequestConfig) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerShortenTicket(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get tickets paginated
   * @param {number} [page] Page number
   * @param {number} [pageSize] Items per page
   * @param {string} [ecv] ECV of the vehicle which has the ticket (support a list of values, separated by comma)
   * @param {string} [parkingStartFrom] Lower bound for parking start
   * @param {string} [parkingStartTo] Upper bound for parking start
   * @param {string} [parkingEndFrom] Lower bound for parking end
   * @param {string} [parkingEndTo] Upper bound for parking end
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerTicketsGetMany(
    page?: number,
    pageSize?: number,
    ecv?: string,
    parkingStartFrom?: string,
    parkingStartTo?: string,
    parkingEndFrom?: string,
    parkingEndTo?: string,
    options?: AxiosRequestConfig,
  ) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerTicketsGetMany(
        page,
        pageSize,
        ecv,
        parkingStartFrom,
        parkingStartTo,
        parkingEndFrom,
        parkingEndTo,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get single ticket
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerTicketsGetOne(id: number, options?: AxiosRequestConfig) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerTicketsGetOne(id, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerDeleteUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/user`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get user settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerGetUserSettings: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/user/settings`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Save user settings
     * @param {SaveUserSettingsDto} saveUserSettingsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerSaveUserSettings: async (
      saveUserSettingsDto: SaveUserSettingsDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'saveUserSettingsDto' is not null or undefined
      assertParamExists(
        'usersControllerSaveUserSettings',
        'saveUserSettingsDto',
        saveUserSettingsDto,
      )
      const localVarPath = `/user/settings`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        saveUserSettingsDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Delete user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersControllerDeleteUser(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerDeleteUser(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get user settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersControllerGetUserSettings(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSettingsDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetUserSettings(
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Save user settings
     * @param {SaveUserSettingsDto} saveUserSettingsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersControllerSaveUserSettings(
      saveUserSettingsDto: SaveUserSettingsDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSettingsDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerSaveUserSettings(
        saveUserSettingsDto,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UserApiFp(configuration)
  return {
    /**
     *
     * @summary Delete user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerDeleteUser(options?: AxiosRequestConfig): AxiosPromise<boolean> {
      return localVarFp
        .usersControllerDeleteUser(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get user settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerGetUserSettings(options?: AxiosRequestConfig): AxiosPromise<UserSettingsDto> {
      return localVarFp
        .usersControllerGetUserSettings(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Save user settings
     * @param {SaveUserSettingsDto} saveUserSettingsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerSaveUserSettings(
      saveUserSettingsDto: SaveUserSettingsDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<UserSettingsDto> {
      return localVarFp
        .usersControllerSaveUserSettings(saveUserSettingsDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
  /**
   *
   * @summary Delete user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public usersControllerDeleteUser(options?: AxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .usersControllerDeleteUser(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get user settings
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public usersControllerGetUserSettings(options?: AxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .usersControllerGetUserSettings(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Save user settings
   * @param {SaveUserSettingsDto} saveUserSettingsDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public usersControllerSaveUserSettings(
    saveUserSettingsDto: SaveUserSettingsDto,
    options?: AxiosRequestConfig,
  ) {
    return UserApiFp(this.configuration)
      .usersControllerSaveUserSettings(saveUserSettingsDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * VehiclesApi - axios parameter creator
 * @export
 */
export const VehiclesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete a specific vehicle
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehiclesControllerDeleteVehicle: async (
      id: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('vehiclesControllerDeleteVehicle', 'id', id)
      const localVarPath = `/vehicles/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Inserts new vehicle
     * @param {CreateVehicleDto} createVehicleDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehiclesControllerInsertVehicle: async (
      createVehicleDto: CreateVehicleDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createVehicleDto' is not null or undefined
      assertParamExists('vehiclesControllerInsertVehicle', 'createVehicleDto', createVehicleDto)
      const localVarPath = `/vehicles`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createVehicleDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Updates a specific vehicle
     * @param {number} id
     * @param {UpdateVehicleDto} updateVehicleDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehiclesControllerUpdateVehicle: async (
      id: number,
      updateVehicleDto: UpdateVehicleDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('vehiclesControllerUpdateVehicle', 'id', id)
      // verify required parameter 'updateVehicleDto' is not null or undefined
      assertParamExists('vehiclesControllerUpdateVehicle', 'updateVehicleDto', updateVehicleDto)
      const localVarPath = `/vehicles/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateVehicleDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get all vehicles associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehiclesControllerVehiclesGetMany: async (
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/vehicles`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * VehiclesApi - functional programming interface
 * @export
 */
export const VehiclesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = VehiclesApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Delete a specific vehicle
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vehiclesControllerDeleteVehicle(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.vehiclesControllerDeleteVehicle(
        id,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Inserts new vehicle
     * @param {CreateVehicleDto} createVehicleDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vehiclesControllerInsertVehicle(
      createVehicleDto: CreateVehicleDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VehicleDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.vehiclesControllerInsertVehicle(
        createVehicleDto,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Updates a specific vehicle
     * @param {number} id
     * @param {UpdateVehicleDto} updateVehicleDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vehiclesControllerUpdateVehicle(
      id: number,
      updateVehicleDto: UpdateVehicleDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VehicleDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.vehiclesControllerUpdateVehicle(
        id,
        updateVehicleDto,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all vehicles associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vehiclesControllerVehiclesGetMany(
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VehiclesResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.vehiclesControllerVehiclesGetMany(
        page,
        pageSize,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * VehiclesApi - factory interface
 * @export
 */
export const VehiclesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = VehiclesApiFp(configuration)
  return {
    /**
     *
     * @summary Delete a specific vehicle
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehiclesControllerDeleteVehicle(
      id: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<DeleteResponseDto> {
      return localVarFp
        .vehiclesControllerDeleteVehicle(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Inserts new vehicle
     * @param {CreateVehicleDto} createVehicleDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehiclesControllerInsertVehicle(
      createVehicleDto: CreateVehicleDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<VehicleDto> {
      return localVarFp
        .vehiclesControllerInsertVehicle(createVehicleDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Updates a specific vehicle
     * @param {number} id
     * @param {UpdateVehicleDto} updateVehicleDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehiclesControllerUpdateVehicle(
      id: number,
      updateVehicleDto: UpdateVehicleDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<VehicleDto> {
      return localVarFp
        .vehiclesControllerUpdateVehicle(id, updateVehicleDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get all vehicles associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehiclesControllerVehiclesGetMany(
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<VehiclesResponseDto> {
      return localVarFp
        .vehiclesControllerVehiclesGetMany(page, pageSize, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * VehiclesApi - object-oriented interface
 * @export
 * @class VehiclesApi
 * @extends {BaseAPI}
 */
export class VehiclesApi extends BaseAPI {
  /**
   *
   * @summary Delete a specific vehicle
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VehiclesApi
   */
  public vehiclesControllerDeleteVehicle(id: number, options?: AxiosRequestConfig) {
    return VehiclesApiFp(this.configuration)
      .vehiclesControllerDeleteVehicle(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Inserts new vehicle
   * @param {CreateVehicleDto} createVehicleDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VehiclesApi
   */
  public vehiclesControllerInsertVehicle(
    createVehicleDto: CreateVehicleDto,
    options?: AxiosRequestConfig,
  ) {
    return VehiclesApiFp(this.configuration)
      .vehiclesControllerInsertVehicle(createVehicleDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Updates a specific vehicle
   * @param {number} id
   * @param {UpdateVehicleDto} updateVehicleDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VehiclesApi
   */
  public vehiclesControllerUpdateVehicle(
    id: number,
    updateVehicleDto: UpdateVehicleDto,
    options?: AxiosRequestConfig,
  ) {
    return VehiclesApiFp(this.configuration)
      .vehiclesControllerUpdateVehicle(id, updateVehicleDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all vehicles associated with the user
   * @param {number} [page] Page number
   * @param {number} [pageSize] Items per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VehiclesApi
   */
  public vehiclesControllerVehiclesGetMany(
    page?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return VehiclesApiFp(this.configuration)
      .vehiclesControllerVehiclesGetMany(page, pageSize, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * VerifiedEmailsApi - axios parameter creator
 * @export
 */
export const VerifiedEmailsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete a specific verified email
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerDeleteVerifiedEmail: async (
      id: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('verifiedEmailsControllerDeleteVerifiedEmail', 'id', id)
      const localVarPath = `/verified-emails/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Refreshes all parking cards for the email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerRefreshVerifiedEmail: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/verified-emails/refresh`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Send out emails for each email for verification
     * @param {VerifyEmailsDto} verifyEmailsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerSendEmailVerificationEmails: async (
      verifyEmailsDto: VerifyEmailsDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'verifyEmailsDto' is not null or undefined
      assertParamExists(
        'verifiedEmailsControllerSendEmailVerificationEmails',
        'verifyEmailsDto',
        verifyEmailsDto,
      )
      const localVarPath = `/verified-emails`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        verifyEmailsDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get all verified emails associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerVerifiedEmailsGetMany: async (
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/verified-emails`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Verifies an email with token
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerVerifyEmail: async (
      token: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'token' is not null or undefined
      assertParamExists('verifiedEmailsControllerVerifyEmail', 'token', token)
      const localVarPath = `/verified-emails/verify`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (token !== undefined) {
        localVarQueryParameter['token'] = token
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * VerifiedEmailsApi - functional programming interface
 * @export
 */
export const VerifiedEmailsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = VerifiedEmailsApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Delete a specific verified email
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verifiedEmailsControllerDeleteVerifiedEmail(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteResponseDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.verifiedEmailsControllerDeleteVerifiedEmail(id, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Refreshes all parking cards for the email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verifiedEmailsControllerRefreshVerifiedEmail(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.verifiedEmailsControllerRefreshVerifiedEmail(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Send out emails for each email for verification
     * @param {VerifyEmailsDto} verifyEmailsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verifiedEmailsControllerSendEmailVerificationEmails(
      verifyEmailsDto: VerifyEmailsDto,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EmailVerificationResult>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.verifiedEmailsControllerSendEmailVerificationEmails(
          verifyEmailsDto,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all verified emails associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verifiedEmailsControllerVerifiedEmailsGetMany(
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerifiedEmailsResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.verifiedEmailsControllerVerifiedEmailsGetMany(
          page,
          pageSize,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Verifies an email with token
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verifiedEmailsControllerVerifyEmail(
      token: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ParkingCardDto>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.verifiedEmailsControllerVerifyEmail(
        token,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * VerifiedEmailsApi - factory interface
 * @export
 */
export const VerifiedEmailsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = VerifiedEmailsApiFp(configuration)
  return {
    /**
     *
     * @summary Delete a specific verified email
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerDeleteVerifiedEmail(
      id: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<DeleteResponseDto> {
      return localVarFp
        .verifiedEmailsControllerDeleteVerifiedEmail(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Refreshes all parking cards for the email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerRefreshVerifiedEmail(
      options?: AxiosRequestConfig,
    ): AxiosPromise<boolean> {
      return localVarFp
        .verifiedEmailsControllerRefreshVerifiedEmail(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Send out emails for each email for verification
     * @param {VerifyEmailsDto} verifyEmailsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerSendEmailVerificationEmails(
      verifyEmailsDto: VerifyEmailsDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<Array<EmailVerificationResult>> {
      return localVarFp
        .verifiedEmailsControllerSendEmailVerificationEmails(verifyEmailsDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get all verified emails associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerVerifiedEmailsGetMany(
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<VerifiedEmailsResponseDto> {
      return localVarFp
        .verifiedEmailsControllerVerifiedEmailsGetMany(page, pageSize, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Verifies an email with token
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerVerifyEmail(
      token: string,
      options?: AxiosRequestConfig,
    ): AxiosPromise<Array<ParkingCardDto>> {
      return localVarFp
        .verifiedEmailsControllerVerifyEmail(token, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * VerifiedEmailsApi - object-oriented interface
 * @export
 * @class VerifiedEmailsApi
 * @extends {BaseAPI}
 */
export class VerifiedEmailsApi extends BaseAPI {
  /**
   *
   * @summary Delete a specific verified email
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VerifiedEmailsApi
   */
  public verifiedEmailsControllerDeleteVerifiedEmail(id: number, options?: AxiosRequestConfig) {
    return VerifiedEmailsApiFp(this.configuration)
      .verifiedEmailsControllerDeleteVerifiedEmail(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Refreshes all parking cards for the email
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VerifiedEmailsApi
   */
  public verifiedEmailsControllerRefreshVerifiedEmail(options?: AxiosRequestConfig) {
    return VerifiedEmailsApiFp(this.configuration)
      .verifiedEmailsControllerRefreshVerifiedEmail(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Send out emails for each email for verification
   * @param {VerifyEmailsDto} verifyEmailsDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VerifiedEmailsApi
   */
  public verifiedEmailsControllerSendEmailVerificationEmails(
    verifyEmailsDto: VerifyEmailsDto,
    options?: AxiosRequestConfig,
  ) {
    return VerifiedEmailsApiFp(this.configuration)
      .verifiedEmailsControllerSendEmailVerificationEmails(verifyEmailsDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all verified emails associated with the user
   * @param {number} [page] Page number
   * @param {number} [pageSize] Items per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VerifiedEmailsApi
   */
  public verifiedEmailsControllerVerifiedEmailsGetMany(
    page?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return VerifiedEmailsApiFp(this.configuration)
      .verifiedEmailsControllerVerifiedEmailsGetMany(page, pageSize, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Verifies an email with token
   * @param {string} token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VerifiedEmailsApi
   */
  public verifiedEmailsControllerVerifyEmail(token: string, options?: AxiosRequestConfig) {
    return VerifiedEmailsApiFp(this.configuration)
      .verifiedEmailsControllerVerifyEmail(token, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
