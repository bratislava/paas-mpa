/* tslint:disable */
/* eslint-disable */
/**
 * PAAS MPA backend
 * BPA
 *
 * The version of the OpenAPI document: 1.0
 * Contact: inovacie@bratislava.sk
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base'

/**
 *
 * @export
 * @interface AnnouncementDto
 */
export interface AnnouncementDto {
  /**
   * Title of the announcement
   * @type {string}
   * @memberof AnnouncementDto
   */
  title: string
  /**
   * Content of the announcement
   * @type {string}
   * @memberof AnnouncementDto
   */
  content: string
  /**
   *
   * @type {AnnouncementType}
   * @memberof AnnouncementDto
   */
  type: AnnouncementType
  /**
   * External url to route the user on CTA
   * @type {string}
   * @memberof AnnouncementDto
   */
  externalUrl?: string
  /**
   * Database id of the announcement
   * @type {number}
   * @memberof AnnouncementDto
   */
  id: number
  /**
   * Date of the creation
   * @type {string}
   * @memberof AnnouncementDto
   */
  createdAt: string
}

/**
 *
 * @export
 * @enum {string}
 */

export const AnnouncementType = {
  Info: 'INFO',
  Warn: 'WARN',
  Error: 'ERROR',
} as const

export type AnnouncementType = (typeof AnnouncementType)[keyof typeof AnnouncementType]

/**
 *
 * @export
 * @interface AnnouncementsResponseDto
 */
export interface AnnouncementsResponseDto {
  /**
   * List of announcements
   * @type {Array<AnnouncementDto>}
   * @memberof AnnouncementsResponseDto
   */
  announcements: Array<AnnouncementDto>
  /**
   *
   * @type {PaginationInfo}
   * @memberof AnnouncementsResponseDto
   */
  paginationInfo: PaginationInfo
}
/**
 *
 * @export
 * @interface CreateVehicleDto
 */
export interface CreateVehicleDto {
  /**
   * License plate number
   * @type {string}
   * @memberof CreateVehicleDto
   */
  vehiclePlateNumber: string
  /**
   * Name of the vehicle (user input)
   * @type {string}
   * @memberof CreateVehicleDto
   */
  name: string
  /**
   * Set to true to be the default car
   * @type {boolean}
   * @memberof CreateVehicleDto
   */
  isDefault: boolean
}
/**
 *
 * @export
 * @interface DeleteResponseDto
 */
export interface DeleteResponseDto {
  /**
   * ID of the deleted object
   * @type {number}
   * @memberof DeleteResponseDto
   */
  id: number
  /**
   * True if the delete was successful
   * @type {boolean}
   * @memberof DeleteResponseDto
   */
  deleted: boolean
}
/**
 *
 * @export
 * @enum {string}
 */

export const ERRORNAMES = {
  DatabaseError: 'DATABASE ERROR',
  MailgunError: 'MAILGUN_ERROR',
  RabbitMqError: 'RABBIT_MQ_ERROR',
} as const

export type ERRORNAMES = (typeof ERRORNAMES)[keyof typeof ERRORNAMES]

/**
 *
 * @export
 * @interface EmailVerificationResult
 */
export interface EmailVerificationResult {
  /**
   * Verified email address
   * @type {string}
   * @memberof EmailVerificationResult
   */
  email: string
  /**
   * Status signaling if the email was sent successfuly
   * @type {boolean}
   * @memberof EmailVerificationResult
   */
  sent: boolean
  /**
   * Token which is sent to the email - only avaialble for test purposes
   * @type {string}
   * @memberof EmailVerificationResult
   * @deprecated
   */
  token: string
}
/**
 *
 * @export
 * @interface ExpectedErrorDto
 */
export interface ExpectedErrorDto {
  /**
   * Status Code
   * @type {number}
   * @memberof ExpectedErrorDto
   */
  statusCode: number
  /**
   * Status in text
   * @type {string}
   * @memberof ExpectedErrorDto
   */
  status: string
  /**
   * Detail error message
   * @type {string}
   * @memberof ExpectedErrorDto
   */
  message: string
  /**
   *
   * @type {ERRORNAMES}
   * @memberof ExpectedErrorDto
   */
  errorName: ERRORNAMES
}

/**
 *
 * @export
 * @interface FeedbackDto
 */
export interface FeedbackDto {
  /**
   *
   * @type {FeedbackType}
   * @memberof FeedbackDto
   */
  type: FeedbackType
  /**
   * Email of the feedback reporter
   * @type {string}
   * @memberof FeedbackDto
   */
  email: string
  /**
   * Message of the feedback
   * @type {string}
   * @memberof FeedbackDto
   */
  message: string
}

/**
 *
 * @export
 * @enum {string}
 */

export const FeedbackType = {
  _0: '0',
  _1: '1',
} as const

export type FeedbackType = (typeof FeedbackType)[keyof typeof FeedbackType]

/**
 *
 * @export
 * @interface GetTicketPriceRequestDto
 */
export interface GetTicketPriceRequestDto {
  /**
   * Value of NPK UUID
   * @type {string}
   * @memberof GetTicketPriceRequestDto
   */
  npkId?: string
  /**
   *
   * @type {GetTicketPriceTicketInfoRequestDto}
   * @memberof GetTicketPriceRequestDto
   */
  ticket: GetTicketPriceTicketInfoRequestDto
}
/**
 *
 * @export
 * @interface GetTicketPriceResponseDto
 */
export interface GetTicketPriceResponseDto {
  /**
   * Total ticket price considering all discounts and credits. Tax inculded if there is any
   * @type {number}
   * @memberof GetTicketPriceResponseDto
   */
  priceTotal: number
  /**
   * Tax in euros from total price.
   * @type {number}
   * @memberof GetTicketPriceResponseDto
   */
  tax?: number
  /**
   * Total ticket price considering all discounts and credits.
   * @type {number}
   * @memberof GetTicketPriceResponseDto
   */
  priceWithoutTax?: number
  /**
   * Total price without discounts. Tax included if there is any
   * @type {number}
   * @memberof GetTicketPriceResponseDto
   */
  priceWithoutDiscount: number
  /**
   * Bonus minutes used (PT means \'Period of Time\'. The time format is standardized according to ISO 8601. For example PT1H30M15S - 1 hour 30 minutes 15 seconds.)
   * @type {string}
   * @memberof GetTicketPriceResponseDto
   */
  creditBPKUsed: string
  /**
   * NPK - Bonus minutes used (PT means \'Period of Time\'. The time format is standardized according to ISO 8601. For example PT1H30M15S - 1 hour 30 minutes 15 seconds.)
   * @type {string}
   * @memberof GetTicketPriceResponseDto
   */
  creditNpkUsed?: string
  /**
   * The date and time when parking starts (UTC time in ISO8601 format)
   * @type {string}
   * @memberof GetTicketPriceResponseDto
   */
  ticketStart: string
  /**
   * Parking only allowed up to this date/time. Can be different from requested ParkingEnd. Limited by maximum parking time in current parking regulation section.
   * @type {string}
   * @memberof GetTicketPriceResponseDto
   */
  ticketEnd: string
  /**
   * UUID
   * @type {string}
   * @memberof GetTicketPriceResponseDto
   */
  bpkId?: string
}
/**
 *
 * @export
 * @interface GetTicketPriceTicketInfoRequestDto
 */
export interface GetTicketPriceTicketInfoRequestDto {
  /**
   * Parking vehicle registration number
   * @type {string}
   * @memberof GetTicketPriceTicketInfoRequestDto
   */
  ecv: string
  /**
   * Unique identification of parking slot (specific section of parking regulation)
   * @type {string}
   * @memberof GetTicketPriceTicketInfoRequestDto
   */
  udr: string
  /**
   * GUID - Unique identification of parking slot (specific section of parking regulation)
   * @type {string}
   * @memberof GetTicketPriceTicketInfoRequestDto
   */
  udrUuid: string
  /**
   * The date and time when parking ends (UTC time in ISO8601 format)
   * @type {string}
   * @memberof GetTicketPriceTicketInfoRequestDto
   */
  parkingEnd: string
}
/**
 *
 * @export
 * @interface GetTicketProlongationPriceRequestDto
 */
export interface GetTicketProlongationPriceRequestDto {
  /**
   * The date and time when parking ends (UTC time in ISO8601 format)
   * @type {string}
   * @memberof GetTicketProlongationPriceRequestDto
   */
  newParkingEnd: string
  /**
   * Id of the ticket to be prolonged
   * @type {number}
   * @memberof GetTicketProlongationPriceRequestDto
   */
  ticketId: number
}
/**
 *
 * @export
 * @interface InitiatePaymentRequestDto
 */
export interface InitiatePaymentRequestDto {
  /**
   *
   * @type {GetTicketPriceRequestDto}
   * @memberof InitiatePaymentRequestDto
   */
  ticket: GetTicketPriceRequestDto
  /**
   * Price coming from the FE what the user seen last time and accepted to pay for the ticket
   * @type {number}
   * @memberof InitiatePaymentRequestDto
   */
  price: number
  /**
   * Price coming from the FE what the user seen last time and accepted to pay for the ticket from the BPK credit (PT means \'Period of Time\'. The time format is standardized according to ISO 8601. For example PT1H30M15S - 1 hour 30 minutes 15 seconds.)
   * @type {string}
   * @memberof InitiatePaymentRequestDto
   */
  priceBpk: string
  /**
   * Price coming from the FE what the user seen last time and accepted to pay for the ticket from the NPK credit (PT means \'Period of Time\'. The time format is standardized according to ISO 8601. For example PT1H30M15S - 1 hour 30 minutes 15 seconds.)
   * @type {string}
   * @memberof InitiatePaymentRequestDto
   */
  priceNpk: string
}
/**
 *
 * @export
 * @interface InitiateProlongationRequestDto
 */
export interface InitiateProlongationRequestDto {
  /**
   *
   * @type {GetTicketProlongationPriceRequestDto}
   * @memberof InitiateProlongationRequestDto
   */
  ticket: GetTicketProlongationPriceRequestDto
  /**
   * Price coming from the FE what the user seen last time and accepted to pay for the ticket
   * @type {number}
   * @memberof InitiateProlongationRequestDto
   */
  price: number
  /**
   * Price coming from the FE what the user seen last time and accepted to pay for the ticket from the BPK credit (PT means \'Period of Time\'. The time format is standardized according to ISO 8601. For example PT1H30M15S - 1 hour 30 minutes 15 seconds.)
   * @type {string}
   * @memberof InitiateProlongationRequestDto
   */
  priceBpk: string
  /**
   * Price coming from the FE what the user seen last time and accepted to pay for the ticket from the NPK credit (PT means \'Period of Time\'. The time format is standardized according to ISO 8601. For example PT1H30M15S - 1 hour 30 minutes 15 seconds.)
   * @type {string}
   * @memberof InitiateProlongationRequestDto
   */
  priceNpk: string
}
/**
 *
 * @export
 * @interface MobileDeviceDto
 */
export interface MobileDeviceDto {
  /**
   * Mobile device token for sending push messages
   * @type {string}
   * @memberof MobileDeviceDto
   */
  token: string
  /**
   *
   * @type {MobileDevicePlatform}
   * @memberof MobileDeviceDto
   */
  platform: MobileDevicePlatform
  /**
   * Database id of the mobile device
   * @type {number}
   * @memberof MobileDeviceDto
   */
  id: number
  /**
   * Date of the creation
   * @type {string}
   * @memberof MobileDeviceDto
   */
  createdAt: string
  /**
   * Date of the last change
   * @type {string}
   * @memberof MobileDeviceDto
   */
  updatedAt: string
}

/**
 *
 * @export
 * @enum {string}
 */

export const MobileDevicePlatform = {
  Apple: 'APPLE',
  Android: 'ANDROID',
} as const

export type MobileDevicePlatform = (typeof MobileDevicePlatform)[keyof typeof MobileDevicePlatform]

/**
 *
 * @export
 * @interface MobileDeviceResponseDto
 */
export interface MobileDeviceResponseDto {
  /**
   * List of mobile devices
   * @type {Array<MobileDeviceDto>}
   * @memberof MobileDeviceResponseDto
   */
  devices: Array<MobileDeviceDto>
  /**
   *
   * @type {PaginationInfo}
   * @memberof MobileDeviceResponseDto
   */
  paginationInfo: PaginationInfo
}
/**
 *
 * @export
 * @interface PaginationInfo
 */
export interface PaginationInfo {
  /**
   * Total number of entities
   * @type {number}
   * @memberof PaginationInfo
   */
  total: number
  /**
   * Current page
   * @type {number}
   * @memberof PaginationInfo
   */
  currentPage: number
  /**
   * Current page size
   * @type {number}
   * @memberof PaginationInfo
   */
  pageSize: number
}
/**
 *
 * @export
 * @interface ParkingCardDto
 */
export interface ParkingCardDto {
  /**
   * Database id of the verified email
   * @type {number}
   * @memberof ParkingCardDto
   */
  id: number
  /**
   * Identificator from parkdots (npkid)
   * @type {string}
   * @memberof ParkingCardDto
   */
  identificator: string
  /**
   *
   * @type {ParkingCardType}
   * @memberof ParkingCardDto
   */
  type: ParkingCardType
  /**
   * Name of the card cheme
   * @type {string}
   * @memberof ParkingCardDto
   */
  name?: string
  /**
   * The vehicle plate number for which the card was issued. (Some cards are not issued to the vehicle. Therefore, it may be missing.)
   * @type {string}
   * @memberof ParkingCardDto
   */
  vehiclePlateNumber?: string
  /**
   * Start of card validity. ISO8601 formatted UTC timestamp
   * @type {string}
   * @memberof ParkingCardDto
   */
  validFrom?: string
  /**
   * End of card validity. ISO8601 formatted UTC timestamp.
   * @type {string}
   * @memberof ParkingCardDto
   */
  validTo?: string
  /**
   * Balance available on the visitor card (PT means \'Period of Time\'. The time format is standardized according to ISO 8601. For example PT1H30M15S - 1 hour 30 minutes 15 seconds.)
   * @type {string}
   * @memberof ParkingCardDto
   */
  balance?: string
  /**
   * Balance available on the visitor card (PT means \'Period of Time\'. The time format is standardized according to ISO 8601. For example PT1H30M15S - 1 hour 30 minutes 15 seconds.)
   * @type {string}
   * @memberof ParkingCardDto
   */
  originalBalance?: string
  /**
   * List of Internal ids of the parking space.
   * @type {Array<string>}
   * @memberof ParkingCardDto
   */
  parkingSpaces?: Array<string>
  /**
   * Date of the creation
   * @type {string}
   * @memberof ParkingCardDto
   */
  createdAt: string
  /**
   * Date of the last change
   * @type {string}
   * @memberof ParkingCardDto
   */
  updatedAt: string
}

/**
 *
 * @export
 * @enum {string}
 */

export const ParkingCardType = {
  Abonent: 'ABONENT',
  Rezident: 'REZIDENT',
  Bpk: 'BPK',
  Npk: 'NPK',
  Tzp: 'TZP',
  Elektromobil: 'ELEKTROMOBIL',
  Other: 'OTHER',
} as const

export type ParkingCardType = (typeof ParkingCardType)[keyof typeof ParkingCardType]

/**
 *
 * @export
 * @interface ParkingCardsResponseDto
 */
export interface ParkingCardsResponseDto {
  /**
   * List of parking cards
   * @type {Array<ParkingCardDto>}
   * @memberof ParkingCardsResponseDto
   */
  parkingCards: Array<ParkingCardDto>
  /**
   *
   * @type {PaginationInfo}
   * @memberof ParkingCardsResponseDto
   */
  paginationInfo: PaginationInfo
}
/**
 *
 * @export
 * @interface PaymentResponseQueryDto
 */
export interface PaymentResponseQueryDto {
  /**
   * Operation text coming from the paygate return url query param
   * @type {string}
   * @memberof PaymentResponseQueryDto
   */
  OPERATION: string
  /**
   * Ordernumber text coming from the paygate return url query param (13 characters long number)
   * @type {string}
   * @memberof PaymentResponseQueryDto
   */
  ORDERNUMBER: string
  /**
   * Prcode text coming from the paygate return url query param
   * @type {string}
   * @memberof PaymentResponseQueryDto
   */
  PRCODE: string
  /**
   * Srcode text coming from the paygate return url query param
   * @type {string}
   * @memberof PaymentResponseQueryDto
   */
  SRCODE: string
  /**
   * Digest text coming from the paygate return url query param
   * @type {string}
   * @memberof PaymentResponseQueryDto
   */
  DIGEST: string
  /**
   * Digest1 text coming from the paygate return url query param
   * @type {string}
   * @memberof PaymentResponseQueryDto
   */
  DIGEST1: string
  /**
   * Result text coming from the paygate return url query param
   * @type {string}
   * @memberof PaymentResponseQueryDto
   */
  RESULTTEXT: string
}
/**
 *
 * @export
 * @interface SaveAnnouncementDto
 */
export interface SaveAnnouncementDto {
  /**
   * Title of the announcement
   * @type {string}
   * @memberof SaveAnnouncementDto
   */
  title: string
  /**
   * Content of the announcement
   * @type {string}
   * @memberof SaveAnnouncementDto
   */
  content: string
  /**
   *
   * @type {AnnouncementType}
   * @memberof SaveAnnouncementDto
   */
  type: AnnouncementType
  /**
   * External url to route the user on CTA
   * @type {string}
   * @memberof SaveAnnouncementDto
   */
  externalUrl?: string
}

/**
 *
 * @export
 * @interface SaveMobileDeviceDto
 */
export interface SaveMobileDeviceDto {
  /**
   * Mobile device token for sending push messages
   * @type {string}
   * @memberof SaveMobileDeviceDto
   */
  token: string
  /**
   *
   * @type {MobileDevicePlatform}
   * @memberof SaveMobileDeviceDto
   */
  platform: MobileDevicePlatform
}

/**
 *
 * @export
 * @interface SaveUserSettingsDto
 */
export interface SaveUserSettingsDto {
  /**
   * Set true to send push notifications for tickets about to end
   * @type {boolean}
   * @memberof SaveUserSettingsDto
   */
  pushNotificationsAboutToEnd?: boolean
  /**
   * Set true to send push notifications for tickets about to end
   * @type {boolean}
   * @memberof SaveUserSettingsDto
   */
  pushNotificationsToEnd?: boolean
  /**
   * Set true to send push notifications for tickets about to end
   * @type {boolean}
   * @memberof SaveUserSettingsDto
   */
  emailNotificationsAboutToEnd?: boolean
  /**
   * Set true to send push notifications for tickets about to end
   * @type {boolean}
   * @memberof SaveUserSettingsDto
   */
  emailNotificationsToEnd?: boolean
}
/**
 *
 * @export
 * @interface TicketDto
 */
export interface TicketDto {
  /**
   * Unique identification of parking slot (specific section of parking regulation)
   * @type {string}
   * @memberof TicketDto
   */
  udr: string
  /**
   * Start of the parking
   * @type {string}
   * @memberof TicketDto
   */
  parkingStart: string
  /**
   * End of the parking
   * @type {string}
   * @memberof TicketDto
   */
  parkingEnd: string
  /**
   * Price of the parking
   * @type {number}
   * @memberof TicketDto
   */
  price?: number
  /**
   * Credits used in case of bonnus parking (PT means \'Period of Time\'. The time format is standardized according to ISO 8601. For example PT1H30M15S - 1 hour 30 minutes 15 seconds.)
   * @type {string}
   * @memberof TicketDto
   */
  bpkCreditUsed?: string
  /**
   * Credits used in case of visitor parking (PT means \'Period of Time\'. The time format is standardized according to ISO 8601. For example PT1H30M15S - 1 hour 30 minutes 15 seconds.)
   * @type {string}
   * @memberof TicketDto
   */
  npkCreditUsed?: string
  /**
   * ID of the visitor card (GUID)
   * @type {string}
   * @memberof TicketDto
   */
  npkId?: string
  /**
   * ID of the bonus card (GUID)
   * @type {string}
   * @memberof TicketDto
   */
  bpkId?: string
  /**
   * Date of the last change
   * @type {string}
   * @memberof TicketDto
   */
  updatedAt: string
  /**
   * Date of the creation
   * @type {string}
   * @memberof TicketDto
   */
  createdAt: string
}
/**
 *
 * @export
 * @interface TicketsResponseDto
 */
export interface TicketsResponseDto {
  /**
   * List of tickets
   * @type {Array<TicketDto>}
   * @memberof TicketsResponseDto
   */
  tickets: Array<TicketDto>
  /**
   *
   * @type {PaginationInfo}
   * @memberof TicketsResponseDto
   */
  paginationInfo: PaginationInfo
}
/**
 *
 * @export
 * @interface UnexpectedErrorDto
 */
export interface UnexpectedErrorDto {
  /**
   * Status Code
   * @type {number}
   * @memberof UnexpectedErrorDto
   */
  statusCode: number
  /**
   * Status in text
   * @type {string}
   * @memberof UnexpectedErrorDto
   */
  status: string
  /**
   * Detail error message
   * @type {string}
   * @memberof UnexpectedErrorDto
   */
  message: string
  /**
   * Exact error name
   * @type {string}
   * @memberof UnexpectedErrorDto
   */
  errorName: string
}
/**
 *
 * @export
 * @interface UpdateVehicleDto
 */
export interface UpdateVehicleDto {
  /**
   * License plate number
   * @type {string}
   * @memberof UpdateVehicleDto
   */
  vehiclePlateNumber?: string
  /**
   * Name of the vehicle (user input)
   * @type {string}
   * @memberof UpdateVehicleDto
   */
  name?: string
  /**
   * Set to true to be the default car
   * @type {boolean}
   * @memberof UpdateVehicleDto
   */
  isDefault?: boolean
}
/**
 *
 * @export
 * @interface UserSettingsDto
 */
export interface UserSettingsDto {
  /**
   * Set true to send push notifications for tickets about to end
   * @type {boolean}
   * @memberof UserSettingsDto
   */
  pushNotificationsAboutToEnd: boolean
  /**
   * Set true to send push notifications for tickets about to end
   * @type {boolean}
   * @memberof UserSettingsDto
   */
  pushNotificationsToEnd: boolean
  /**
   * Set true to send push notifications for tickets about to end
   * @type {boolean}
   * @memberof UserSettingsDto
   */
  emailNotificationsAboutToEnd: boolean
  /**
   * Set true to send push notifications for tickets about to end
   * @type {boolean}
   * @memberof UserSettingsDto
   */
  emailNotificationsToEnd: boolean
  /**
   * Date of the first creation
   * @type {string}
   * @memberof UserSettingsDto
   */
  createdAt: string
  /**
   * Date of the last modificaiton
   * @type {string}
   * @memberof UserSettingsDto
   */
  updatedAt: string
}
/**
 *
 * @export
 * @interface VehicleDto
 */
export interface VehicleDto {
  /**
   * License plate number
   * @type {string}
   * @memberof VehicleDto
   */
  vehiclePlateNumber: string
  /**
   * Name of the vehicle (user input)
   * @type {string}
   * @memberof VehicleDto
   */
  name: string
  /**
   * Set to true to be the default car
   * @type {boolean}
   * @memberof VehicleDto
   */
  isDefault: boolean
  /**
   * Database id of the vehicle
   * @type {number}
   * @memberof VehicleDto
   */
  id: number
  /**
   * Date of the creation
   * @type {string}
   * @memberof VehicleDto
   */
  createdAt: string
  /**
   * Date of the last change
   * @type {string}
   * @memberof VehicleDto
   */
  updatedAt: string
}
/**
 *
 * @export
 * @interface VehiclesResponseDto
 */
export interface VehiclesResponseDto {
  /**
   * List of vehicles
   * @type {Array<VehicleDto>}
   * @memberof VehiclesResponseDto
   */
  vehicles: Array<VehicleDto>
  /**
   *
   * @type {PaginationInfo}
   * @memberof VehiclesResponseDto
   */
  paginationInfo: PaginationInfo
}
/**
 *
 * @export
 * @interface VerifiedEmailDto
 */
export interface VerifiedEmailDto {
  /**
   * Database id of the verified email
   * @type {number}
   * @memberof VerifiedEmailDto
   */
  id: number
  /**
   * Email address
   * @type {string}
   * @memberof VerifiedEmailDto
   */
  email: string
  /**
   * Date of the creation
   * @type {string}
   * @memberof VerifiedEmailDto
   */
  createdAt: string
  /**
   * Date of the last change
   * @type {string}
   * @memberof VerifiedEmailDto
   */
  updatedAt: string
}
/**
 *
 * @export
 * @interface VerifiedEmailsResponseDto
 */
export interface VerifiedEmailsResponseDto {
  /**
   * List of verified emails
   * @type {Array<VerifiedEmailDto>}
   * @memberof VerifiedEmailsResponseDto
   */
  verifiedEmails: Array<VerifiedEmailDto>
  /**
   *
   * @type {PaginationInfo}
   * @memberof VerifiedEmailsResponseDto
   */
  paginationInfo: PaginationInfo
}
/**
 *
 * @export
 * @interface VerifyEmailsDto
 */
export interface VerifyEmailsDto {
  /**
   * List of emails to verify
   * @type {Array<string>}
   * @memberof VerifyEmailsDto
   */
  emails: Array<string>
}

/**
 * AnnouncementsApi - axios parameter creator
 * @export
 */
export const AnnouncementsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get all announcements paginated
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    announcementsControllerAnnouncementsGetMany: async (
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/announcements`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Delete a specific announcement
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    announcementsControllerDeleteAnnouncement: async (
      id: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('announcementsControllerDeleteAnnouncement', 'id', id)
      const localVarPath = `/announcements/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication azure required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Inserts new vehicle
     * @param {SaveAnnouncementDto} saveAnnouncementDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    announcementsControllerInsertAnnouncement: async (
      saveAnnouncementDto: SaveAnnouncementDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'saveAnnouncementDto' is not null or undefined
      assertParamExists(
        'announcementsControllerInsertAnnouncement',
        'saveAnnouncementDto',
        saveAnnouncementDto,
      )
      const localVarPath = `/announcements`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication azure required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        saveAnnouncementDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AnnouncementsApi - functional programming interface
 * @export
 */
export const AnnouncementsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AnnouncementsApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Get all announcements paginated
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async announcementsControllerAnnouncementsGetMany(
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouncementsResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.announcementsControllerAnnouncementsGetMany(
          page,
          pageSize,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Delete a specific announcement
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async announcementsControllerDeleteAnnouncement(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteResponseDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.announcementsControllerDeleteAnnouncement(id, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Inserts new vehicle
     * @param {SaveAnnouncementDto} saveAnnouncementDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async announcementsControllerInsertAnnouncement(
      saveAnnouncementDto: SaveAnnouncementDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouncementDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.announcementsControllerInsertAnnouncement(
          saveAnnouncementDto,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * AnnouncementsApi - factory interface
 * @export
 */
export const AnnouncementsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AnnouncementsApiFp(configuration)
  return {
    /**
     *
     * @summary Get all announcements paginated
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    announcementsControllerAnnouncementsGetMany(
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<AnnouncementsResponseDto> {
      return localVarFp
        .announcementsControllerAnnouncementsGetMany(page, pageSize, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Delete a specific announcement
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    announcementsControllerDeleteAnnouncement(
      id: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<DeleteResponseDto> {
      return localVarFp
        .announcementsControllerDeleteAnnouncement(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Inserts new vehicle
     * @param {SaveAnnouncementDto} saveAnnouncementDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    announcementsControllerInsertAnnouncement(
      saveAnnouncementDto: SaveAnnouncementDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<AnnouncementDto> {
      return localVarFp
        .announcementsControllerInsertAnnouncement(saveAnnouncementDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * AnnouncementsApi - object-oriented interface
 * @export
 * @class AnnouncementsApi
 * @extends {BaseAPI}
 */
export class AnnouncementsApi extends BaseAPI {
  /**
   *
   * @summary Get all announcements paginated
   * @param {number} [page] Page number
   * @param {number} [pageSize] Items per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AnnouncementsApi
   */
  public announcementsControllerAnnouncementsGetMany(
    page?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return AnnouncementsApiFp(this.configuration)
      .announcementsControllerAnnouncementsGetMany(page, pageSize, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Delete a specific announcement
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AnnouncementsApi
   */
  public announcementsControllerDeleteAnnouncement(id: number, options?: AxiosRequestConfig) {
    return AnnouncementsApiFp(this.configuration)
      .announcementsControllerDeleteAnnouncement(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Inserts new vehicle
   * @param {SaveAnnouncementDto} saveAnnouncementDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AnnouncementsApi
   */
  public announcementsControllerInsertAnnouncement(
    saveAnnouncementDto: SaveAnnouncementDto,
    options?: AxiosRequestConfig,
  ) {
    return AnnouncementsApiFp(this.configuration)
      .announcementsControllerInsertAnnouncement(saveAnnouncementDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Get information about the status of the mpa-backend.
     * @summary Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerHealth: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/healthcheck`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
  return {
    /**
     * Get information about the status of the mpa-backend.
     * @summary Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async appControllerHealth(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerHealth(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DefaultApiFp(configuration)
  return {
    /**
     * Get information about the status of the mpa-backend.
     * @summary Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerHealth(options?: AxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.appControllerHealth(options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   * Get information about the status of the mpa-backend.
   * @summary Healthcheck
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public appControllerHealth(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .appControllerHealth(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * MobileDevicesApi - axios parameter creator
 * @export
 */
export const MobileDevicesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete a specific mobile device
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mobileDevicesControllerDeleteMobileDevice: async (
      id: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('mobileDevicesControllerDeleteMobileDevice', 'id', id)
      const localVarPath = `/mobile-devices/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get all mobile devices associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mobileDevicesControllerDevicesGetMany: async (
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/mobile-devices`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Inserts new mobile device
     * @param {SaveMobileDeviceDto} saveMobileDeviceDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mobileDevicesControllerInsertMobileDevice: async (
      saveMobileDeviceDto: SaveMobileDeviceDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'saveMobileDeviceDto' is not null or undefined
      assertParamExists(
        'mobileDevicesControllerInsertMobileDevice',
        'saveMobileDeviceDto',
        saveMobileDeviceDto,
      )
      const localVarPath = `/mobile-devices`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        saveMobileDeviceDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * MobileDevicesApi - functional programming interface
 * @export
 */
export const MobileDevicesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = MobileDevicesApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Delete a specific mobile device
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mobileDevicesControllerDeleteMobileDevice(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteResponseDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.mobileDevicesControllerDeleteMobileDevice(id, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all mobile devices associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mobileDevicesControllerDevicesGetMany(
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MobileDeviceResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.mobileDevicesControllerDevicesGetMany(
          page,
          pageSize,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Inserts new mobile device
     * @param {SaveMobileDeviceDto} saveMobileDeviceDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mobileDevicesControllerInsertMobileDevice(
      saveMobileDeviceDto: SaveMobileDeviceDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MobileDeviceDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.mobileDevicesControllerInsertMobileDevice(
          saveMobileDeviceDto,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * MobileDevicesApi - factory interface
 * @export
 */
export const MobileDevicesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = MobileDevicesApiFp(configuration)
  return {
    /**
     *
     * @summary Delete a specific mobile device
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mobileDevicesControllerDeleteMobileDevice(
      id: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<DeleteResponseDto> {
      return localVarFp
        .mobileDevicesControllerDeleteMobileDevice(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get all mobile devices associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mobileDevicesControllerDevicesGetMany(
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<MobileDeviceResponseDto> {
      return localVarFp
        .mobileDevicesControllerDevicesGetMany(page, pageSize, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Inserts new mobile device
     * @param {SaveMobileDeviceDto} saveMobileDeviceDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mobileDevicesControllerInsertMobileDevice(
      saveMobileDeviceDto: SaveMobileDeviceDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<MobileDeviceDto> {
      return localVarFp
        .mobileDevicesControllerInsertMobileDevice(saveMobileDeviceDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * MobileDevicesApi - object-oriented interface
 * @export
 * @class MobileDevicesApi
 * @extends {BaseAPI}
 */
export class MobileDevicesApi extends BaseAPI {
  /**
   *
   * @summary Delete a specific mobile device
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MobileDevicesApi
   */
  public mobileDevicesControllerDeleteMobileDevice(id: number, options?: AxiosRequestConfig) {
    return MobileDevicesApiFp(this.configuration)
      .mobileDevicesControllerDeleteMobileDevice(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all mobile devices associated with the user
   * @param {number} [page] Page number
   * @param {number} [pageSize] Items per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MobileDevicesApi
   */
  public mobileDevicesControllerDevicesGetMany(
    page?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return MobileDevicesApiFp(this.configuration)
      .mobileDevicesControllerDevicesGetMany(page, pageSize, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Inserts new mobile device
   * @param {SaveMobileDeviceDto} saveMobileDeviceDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MobileDevicesApi
   */
  public mobileDevicesControllerInsertMobileDevice(
    saveMobileDeviceDto: SaveMobileDeviceDto,
    options?: AxiosRequestConfig,
  ) {
    return MobileDevicesApiFp(this.configuration)
      .mobileDevicesControllerInsertMobileDevice(saveMobileDeviceDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ParkingCardsApi - axios parameter creator
 * @export
 */
export const ParkingCardsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get all active visitor cards associated with the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    parkingCardsControllerGetActiveVisitorCards: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/parking-cards/visitor-cards`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get all parking cards associated with the user
     * @param {string} email Email
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    parkingCardsControllerGetParkingCards: async (
      email: string,
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'email' is not null or undefined
      assertParamExists('parkingCardsControllerGetParkingCards', 'email', email)
      const localVarPath = `/parking-cards`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (email !== undefined) {
        localVarQueryParameter['email'] = email
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ParkingCardsApi - functional programming interface
 * @export
 */
export const ParkingCardsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ParkingCardsApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Get all active visitor cards associated with the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async parkingCardsControllerGetActiveVisitorCards(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ParkingCardDto>>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.parkingCardsControllerGetActiveVisitorCards(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all parking cards associated with the user
     * @param {string} email Email
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async parkingCardsControllerGetParkingCards(
      email: string,
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParkingCardsResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.parkingCardsControllerGetParkingCards(
          email,
          page,
          pageSize,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * ParkingCardsApi - factory interface
 * @export
 */
export const ParkingCardsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ParkingCardsApiFp(configuration)
  return {
    /**
     *
     * @summary Get all active visitor cards associated with the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    parkingCardsControllerGetActiveVisitorCards(
      options?: AxiosRequestConfig,
    ): AxiosPromise<Array<ParkingCardDto>> {
      return localVarFp
        .parkingCardsControllerGetActiveVisitorCards(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get all parking cards associated with the user
     * @param {string} email Email
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    parkingCardsControllerGetParkingCards(
      email: string,
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<ParkingCardsResponseDto> {
      return localVarFp
        .parkingCardsControllerGetParkingCards(email, page, pageSize, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ParkingCardsApi - object-oriented interface
 * @export
 * @class ParkingCardsApi
 * @extends {BaseAPI}
 */
export class ParkingCardsApi extends BaseAPI {
  /**
   *
   * @summary Get all active visitor cards associated with the user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ParkingCardsApi
   */
  public parkingCardsControllerGetActiveVisitorCards(options?: AxiosRequestConfig) {
    return ParkingCardsApiFp(this.configuration)
      .parkingCardsControllerGetActiveVisitorCards(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all parking cards associated with the user
   * @param {string} email Email
   * @param {number} [page] Page number
   * @param {number} [pageSize] Items per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ParkingCardsApi
   */
  public parkingCardsControllerGetParkingCards(
    email: string,
    page?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return ParkingCardsApiFp(this.configuration)
      .parkingCardsControllerGetParkingCards(email, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * SystemApi - axios parameter creator
 * @export
 */
export const SystemApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Send feedback
     * @param {FeedbackDto} feedbackDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    systemControllerSendFeedback: async (
      feedbackDto: FeedbackDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'feedbackDto' is not null or undefined
      assertParamExists('systemControllerSendFeedback', 'feedbackDto', feedbackDto)
      const localVarPath = `/system`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        feedbackDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SystemApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Send feedback
     * @param {FeedbackDto} feedbackDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async systemControllerSendFeedback(
      feedbackDto: FeedbackDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.systemControllerSendFeedback(
        feedbackDto,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SystemApiFp(configuration)
  return {
    /**
     *
     * @summary Send feedback
     * @param {FeedbackDto} feedbackDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    systemControllerSendFeedback(
      feedbackDto: FeedbackDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<boolean> {
      return localVarFp
        .systemControllerSendFeedback(feedbackDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
  /**
   *
   * @summary Send feedback
   * @param {FeedbackDto} feedbackDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public systemControllerSendFeedback(feedbackDto: FeedbackDto, options?: AxiosRequestConfig) {
    return SystemApiFp(this.configuration)
      .systemControllerSendFeedback(feedbackDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * TicketsApi - axios parameter creator
 * @export
 */
export const TicketsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get ticket price
     * @param {GetTicketPriceRequestDto} getTicketPriceRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerGetTicketPrice: async (
      getTicketPriceRequestDto: GetTicketPriceRequestDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getTicketPriceRequestDto' is not null or undefined
      assertParamExists(
        'ticketsControllerGetTicketPrice',
        'getTicketPriceRequestDto',
        getTicketPriceRequestDto,
      )
      const localVarPath = `/tickets/price`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        getTicketPriceRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get ticket prolongation price
     * @param {GetTicketProlongationPriceRequestDto} getTicketProlongationPriceRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerGetTicketProlongationPrice: async (
      getTicketProlongationPriceRequestDto: GetTicketProlongationPriceRequestDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getTicketProlongationPriceRequestDto' is not null or undefined
      assertParamExists(
        'ticketsControllerGetTicketProlongationPrice',
        'getTicketProlongationPriceRequestDto',
        getTicketProlongationPriceRequestDto,
      )
      const localVarPath = `/tickets/prolongation/price`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        getTicketProlongationPriceRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Initiate ticket payment
     * @param {InitiatePaymentRequestDto} initiatePaymentRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerInitiateTicketPayment: async (
      initiatePaymentRequestDto: InitiatePaymentRequestDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'initiatePaymentRequestDto' is not null or undefined
      assertParamExists(
        'ticketsControllerInitiateTicketPayment',
        'initiatePaymentRequestDto',
        initiatePaymentRequestDto,
      )
      const localVarPath = `/tickets/payment`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        initiatePaymentRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Initiate prolongation ticket payment
     * @param {InitiateProlongationRequestDto} initiateProlongationRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerInitiateTicketProlongationPayment: async (
      initiateProlongationRequestDto: InitiateProlongationRequestDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'initiateProlongationRequestDto' is not null or undefined
      assertParamExists(
        'ticketsControllerInitiateTicketProlongationPayment',
        'initiateProlongationRequestDto',
        initiateProlongationRequestDto,
      )
      const localVarPath = `/tickets/prolongation/payment`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        initiateProlongationRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Process ticket payment
     * @param {PaymentResponseQueryDto} paymentResponseQueryDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerProcessTicketPayment: async (
      paymentResponseQueryDto: PaymentResponseQueryDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'paymentResponseQueryDto' is not null or undefined
      assertParamExists(
        'ticketsControllerProcessTicketPayment',
        'paymentResponseQueryDto',
        paymentResponseQueryDto,
      )
      const localVarPath = `/tickets/payment/process`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        paymentResponseQueryDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get tickets paginated
     * @param {boolean} active True to load active tickets, false to load past tickets
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerTicketsGetMany: async (
      active: boolean,
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'active' is not null or undefined
      assertParamExists('ticketsControllerTicketsGetMany', 'active', active)
      const localVarPath = `/tickets`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (active !== undefined) {
        localVarQueryParameter['active'] = active
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * TicketsApi - functional programming interface
 * @export
 */
export const TicketsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TicketsApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Get ticket price
     * @param {GetTicketPriceRequestDto} getTicketPriceRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerGetTicketPrice(
      getTicketPriceRequestDto: GetTicketPriceRequestDto,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTicketPriceResponseDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ticketsControllerGetTicketPrice(
        getTicketPriceRequestDto,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get ticket prolongation price
     * @param {GetTicketProlongationPriceRequestDto} getTicketProlongationPriceRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerGetTicketProlongationPrice(
      getTicketProlongationPriceRequestDto: GetTicketProlongationPriceRequestDto,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTicketPriceResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.ticketsControllerGetTicketProlongationPrice(
          getTicketProlongationPriceRequestDto,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Initiate ticket payment
     * @param {InitiatePaymentRequestDto} initiatePaymentRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerInitiateTicketPayment(
      initiatePaymentRequestDto: InitiatePaymentRequestDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.ticketsControllerInitiateTicketPayment(
          initiatePaymentRequestDto,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Initiate prolongation ticket payment
     * @param {InitiateProlongationRequestDto} initiateProlongationRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerInitiateTicketProlongationPayment(
      initiateProlongationRequestDto: InitiateProlongationRequestDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.ticketsControllerInitiateTicketProlongationPayment(
          initiateProlongationRequestDto,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Process ticket payment
     * @param {PaymentResponseQueryDto} paymentResponseQueryDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerProcessTicketPayment(
      paymentResponseQueryDto: PaymentResponseQueryDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.ticketsControllerProcessTicketPayment(
          paymentResponseQueryDto,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get tickets paginated
     * @param {boolean} active True to load active tickets, false to load past tickets
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerTicketsGetMany(
      active: boolean,
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketsResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ticketsControllerTicketsGetMany(
        active,
        page,
        pageSize,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * TicketsApi - factory interface
 * @export
 */
export const TicketsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = TicketsApiFp(configuration)
  return {
    /**
     *
     * @summary Get ticket price
     * @param {GetTicketPriceRequestDto} getTicketPriceRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerGetTicketPrice(
      getTicketPriceRequestDto: GetTicketPriceRequestDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<GetTicketPriceResponseDto> {
      return localVarFp
        .ticketsControllerGetTicketPrice(getTicketPriceRequestDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get ticket prolongation price
     * @param {GetTicketProlongationPriceRequestDto} getTicketProlongationPriceRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerGetTicketProlongationPrice(
      getTicketProlongationPriceRequestDto: GetTicketProlongationPriceRequestDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<GetTicketPriceResponseDto> {
      return localVarFp
        .ticketsControllerGetTicketProlongationPrice(getTicketProlongationPriceRequestDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Initiate ticket payment
     * @param {InitiatePaymentRequestDto} initiatePaymentRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerInitiateTicketPayment(
      initiatePaymentRequestDto: InitiatePaymentRequestDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<TicketDto> {
      return localVarFp
        .ticketsControllerInitiateTicketPayment(initiatePaymentRequestDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Initiate prolongation ticket payment
     * @param {InitiateProlongationRequestDto} initiateProlongationRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerInitiateTicketProlongationPayment(
      initiateProlongationRequestDto: InitiateProlongationRequestDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<TicketDto> {
      return localVarFp
        .ticketsControllerInitiateTicketProlongationPayment(initiateProlongationRequestDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Process ticket payment
     * @param {PaymentResponseQueryDto} paymentResponseQueryDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerProcessTicketPayment(
      paymentResponseQueryDto: PaymentResponseQueryDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<TicketDto> {
      return localVarFp
        .ticketsControllerProcessTicketPayment(paymentResponseQueryDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get tickets paginated
     * @param {boolean} active True to load active tickets, false to load past tickets
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerTicketsGetMany(
      active: boolean,
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<TicketsResponseDto> {
      return localVarFp
        .ticketsControllerTicketsGetMany(active, page, pageSize, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * TicketsApi - object-oriented interface
 * @export
 * @class TicketsApi
 * @extends {BaseAPI}
 */
export class TicketsApi extends BaseAPI {
  /**
   *
   * @summary Get ticket price
   * @param {GetTicketPriceRequestDto} getTicketPriceRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerGetTicketPrice(
    getTicketPriceRequestDto: GetTicketPriceRequestDto,
    options?: AxiosRequestConfig,
  ) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerGetTicketPrice(getTicketPriceRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get ticket prolongation price
   * @param {GetTicketProlongationPriceRequestDto} getTicketProlongationPriceRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerGetTicketProlongationPrice(
    getTicketProlongationPriceRequestDto: GetTicketProlongationPriceRequestDto,
    options?: AxiosRequestConfig,
  ) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerGetTicketProlongationPrice(getTicketProlongationPriceRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Initiate ticket payment
   * @param {InitiatePaymentRequestDto} initiatePaymentRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerInitiateTicketPayment(
    initiatePaymentRequestDto: InitiatePaymentRequestDto,
    options?: AxiosRequestConfig,
  ) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerInitiateTicketPayment(initiatePaymentRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Initiate prolongation ticket payment
   * @param {InitiateProlongationRequestDto} initiateProlongationRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerInitiateTicketProlongationPayment(
    initiateProlongationRequestDto: InitiateProlongationRequestDto,
    options?: AxiosRequestConfig,
  ) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerInitiateTicketProlongationPayment(initiateProlongationRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Process ticket payment
   * @param {PaymentResponseQueryDto} paymentResponseQueryDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerProcessTicketPayment(
    paymentResponseQueryDto: PaymentResponseQueryDto,
    options?: AxiosRequestConfig,
  ) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerProcessTicketPayment(paymentResponseQueryDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get tickets paginated
   * @param {boolean} active True to load active tickets, false to load past tickets
   * @param {number} [page] Page number
   * @param {number} [pageSize] Items per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerTicketsGetMany(
    active: boolean,
    page?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerTicketsGetMany(active, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get user settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerGetUserSettings: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/user/settings`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Save user settings
     * @param {SaveUserSettingsDto} saveUserSettingsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerSaveUserSettings: async (
      saveUserSettingsDto: SaveUserSettingsDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'saveUserSettingsDto' is not null or undefined
      assertParamExists(
        'usersControllerSaveUserSettings',
        'saveUserSettingsDto',
        saveUserSettingsDto,
      )
      const localVarPath = `/user/settings`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        saveUserSettingsDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Get user settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersControllerGetUserSettings(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSettingsDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetUserSettings(
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Save user settings
     * @param {SaveUserSettingsDto} saveUserSettingsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersControllerSaveUserSettings(
      saveUserSettingsDto: SaveUserSettingsDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSettingsDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerSaveUserSettings(
        saveUserSettingsDto,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UserApiFp(configuration)
  return {
    /**
     *
     * @summary Get user settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerGetUserSettings(options?: AxiosRequestConfig): AxiosPromise<UserSettingsDto> {
      return localVarFp
        .usersControllerGetUserSettings(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Save user settings
     * @param {SaveUserSettingsDto} saveUserSettingsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerSaveUserSettings(
      saveUserSettingsDto: SaveUserSettingsDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<UserSettingsDto> {
      return localVarFp
        .usersControllerSaveUserSettings(saveUserSettingsDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
  /**
   *
   * @summary Get user settings
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public usersControllerGetUserSettings(options?: AxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .usersControllerGetUserSettings(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Save user settings
   * @param {SaveUserSettingsDto} saveUserSettingsDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public usersControllerSaveUserSettings(
    saveUserSettingsDto: SaveUserSettingsDto,
    options?: AxiosRequestConfig,
  ) {
    return UserApiFp(this.configuration)
      .usersControllerSaveUserSettings(saveUserSettingsDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * VehiclesApi - axios parameter creator
 * @export
 */
export const VehiclesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete a specific vehicle
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehiclesControllerDeleteVehicle: async (
      id: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('vehiclesControllerDeleteVehicle', 'id', id)
      const localVarPath = `/vehicles/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Inserts new vehicle
     * @param {CreateVehicleDto} createVehicleDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehiclesControllerInsertVehicle: async (
      createVehicleDto: CreateVehicleDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createVehicleDto' is not null or undefined
      assertParamExists('vehiclesControllerInsertVehicle', 'createVehicleDto', createVehicleDto)
      const localVarPath = `/vehicles`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createVehicleDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Updates a specific vehicle
     * @param {number} id
     * @param {UpdateVehicleDto} updateVehicleDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehiclesControllerUpdateVehicle: async (
      id: number,
      updateVehicleDto: UpdateVehicleDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('vehiclesControllerUpdateVehicle', 'id', id)
      // verify required parameter 'updateVehicleDto' is not null or undefined
      assertParamExists('vehiclesControllerUpdateVehicle', 'updateVehicleDto', updateVehicleDto)
      const localVarPath = `/vehicles/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateVehicleDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get all vehicles associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehiclesControllerVehiclesGetMany: async (
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/vehicles`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * VehiclesApi - functional programming interface
 * @export
 */
export const VehiclesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = VehiclesApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Delete a specific vehicle
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vehiclesControllerDeleteVehicle(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.vehiclesControllerDeleteVehicle(
        id,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Inserts new vehicle
     * @param {CreateVehicleDto} createVehicleDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vehiclesControllerInsertVehicle(
      createVehicleDto: CreateVehicleDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VehicleDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.vehiclesControllerInsertVehicle(
        createVehicleDto,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Updates a specific vehicle
     * @param {number} id
     * @param {UpdateVehicleDto} updateVehicleDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vehiclesControllerUpdateVehicle(
      id: number,
      updateVehicleDto: UpdateVehicleDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VehicleDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.vehiclesControllerUpdateVehicle(
        id,
        updateVehicleDto,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all vehicles associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vehiclesControllerVehiclesGetMany(
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VehiclesResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.vehiclesControllerVehiclesGetMany(
        page,
        pageSize,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * VehiclesApi - factory interface
 * @export
 */
export const VehiclesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = VehiclesApiFp(configuration)
  return {
    /**
     *
     * @summary Delete a specific vehicle
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehiclesControllerDeleteVehicle(
      id: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<DeleteResponseDto> {
      return localVarFp
        .vehiclesControllerDeleteVehicle(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Inserts new vehicle
     * @param {CreateVehicleDto} createVehicleDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehiclesControllerInsertVehicle(
      createVehicleDto: CreateVehicleDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<VehicleDto> {
      return localVarFp
        .vehiclesControllerInsertVehicle(createVehicleDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Updates a specific vehicle
     * @param {number} id
     * @param {UpdateVehicleDto} updateVehicleDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehiclesControllerUpdateVehicle(
      id: number,
      updateVehicleDto: UpdateVehicleDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<VehicleDto> {
      return localVarFp
        .vehiclesControllerUpdateVehicle(id, updateVehicleDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get all vehicles associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehiclesControllerVehiclesGetMany(
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<VehiclesResponseDto> {
      return localVarFp
        .vehiclesControllerVehiclesGetMany(page, pageSize, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * VehiclesApi - object-oriented interface
 * @export
 * @class VehiclesApi
 * @extends {BaseAPI}
 */
export class VehiclesApi extends BaseAPI {
  /**
   *
   * @summary Delete a specific vehicle
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VehiclesApi
   */
  public vehiclesControllerDeleteVehicle(id: number, options?: AxiosRequestConfig) {
    return VehiclesApiFp(this.configuration)
      .vehiclesControllerDeleteVehicle(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Inserts new vehicle
   * @param {CreateVehicleDto} createVehicleDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VehiclesApi
   */
  public vehiclesControllerInsertVehicle(
    createVehicleDto: CreateVehicleDto,
    options?: AxiosRequestConfig,
  ) {
    return VehiclesApiFp(this.configuration)
      .vehiclesControllerInsertVehicle(createVehicleDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Updates a specific vehicle
   * @param {number} id
   * @param {UpdateVehicleDto} updateVehicleDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VehiclesApi
   */
  public vehiclesControllerUpdateVehicle(
    id: number,
    updateVehicleDto: UpdateVehicleDto,
    options?: AxiosRequestConfig,
  ) {
    return VehiclesApiFp(this.configuration)
      .vehiclesControllerUpdateVehicle(id, updateVehicleDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all vehicles associated with the user
   * @param {number} [page] Page number
   * @param {number} [pageSize] Items per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VehiclesApi
   */
  public vehiclesControllerVehiclesGetMany(
    page?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return VehiclesApiFp(this.configuration)
      .vehiclesControllerVehiclesGetMany(page, pageSize, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * VerifiedEmailsApi - axios parameter creator
 * @export
 */
export const VerifiedEmailsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete a specific verified email
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerDeleteVerifiedEmail: async (
      id: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('verifiedEmailsControllerDeleteVerifiedEmail', 'id', id)
      const localVarPath = `/verified-emails/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Refreshes all parking cards for the email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerRefreshVerifiedEmail: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/verified-emails/refresh`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Send out emails for each email for verification
     * @param {VerifyEmailsDto} verifyEmailsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerSendEmailVerificationEmails: async (
      verifyEmailsDto: VerifyEmailsDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'verifyEmailsDto' is not null or undefined
      assertParamExists(
        'verifiedEmailsControllerSendEmailVerificationEmails',
        'verifyEmailsDto',
        verifyEmailsDto,
      )
      const localVarPath = `/verified-emails`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        verifyEmailsDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get all verified emails associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerVerifiedEmailsGetMany: async (
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/verified-emails`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Verifies an email with token
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerVerifyEmail: async (
      token: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'token' is not null or undefined
      assertParamExists('verifiedEmailsControllerVerifyEmail', 'token', token)
      const localVarPath = `/verified-emails/verify`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (token !== undefined) {
        localVarQueryParameter['token'] = token
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * VerifiedEmailsApi - functional programming interface
 * @export
 */
export const VerifiedEmailsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = VerifiedEmailsApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Delete a specific verified email
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verifiedEmailsControllerDeleteVerifiedEmail(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteResponseDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.verifiedEmailsControllerDeleteVerifiedEmail(id, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Refreshes all parking cards for the email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verifiedEmailsControllerRefreshVerifiedEmail(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.verifiedEmailsControllerRefreshVerifiedEmail(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Send out emails for each email for verification
     * @param {VerifyEmailsDto} verifyEmailsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verifiedEmailsControllerSendEmailVerificationEmails(
      verifyEmailsDto: VerifyEmailsDto,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EmailVerificationResult>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.verifiedEmailsControllerSendEmailVerificationEmails(
          verifyEmailsDto,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all verified emails associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verifiedEmailsControllerVerifiedEmailsGetMany(
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerifiedEmailsResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.verifiedEmailsControllerVerifiedEmailsGetMany(
          page,
          pageSize,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Verifies an email with token
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verifiedEmailsControllerVerifyEmail(
      token: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ParkingCardDto>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.verifiedEmailsControllerVerifyEmail(
        token,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * VerifiedEmailsApi - factory interface
 * @export
 */
export const VerifiedEmailsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = VerifiedEmailsApiFp(configuration)
  return {
    /**
     *
     * @summary Delete a specific verified email
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerDeleteVerifiedEmail(
      id: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<DeleteResponseDto> {
      return localVarFp
        .verifiedEmailsControllerDeleteVerifiedEmail(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Refreshes all parking cards for the email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerRefreshVerifiedEmail(
      options?: AxiosRequestConfig,
    ): AxiosPromise<boolean> {
      return localVarFp
        .verifiedEmailsControllerRefreshVerifiedEmail(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Send out emails for each email for verification
     * @param {VerifyEmailsDto} verifyEmailsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerSendEmailVerificationEmails(
      verifyEmailsDto: VerifyEmailsDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<Array<EmailVerificationResult>> {
      return localVarFp
        .verifiedEmailsControllerSendEmailVerificationEmails(verifyEmailsDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get all verified emails associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerVerifiedEmailsGetMany(
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<VerifiedEmailsResponseDto> {
      return localVarFp
        .verifiedEmailsControllerVerifiedEmailsGetMany(page, pageSize, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Verifies an email with token
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerVerifyEmail(
      token: string,
      options?: AxiosRequestConfig,
    ): AxiosPromise<Array<ParkingCardDto>> {
      return localVarFp
        .verifiedEmailsControllerVerifyEmail(token, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * VerifiedEmailsApi - object-oriented interface
 * @export
 * @class VerifiedEmailsApi
 * @extends {BaseAPI}
 */
export class VerifiedEmailsApi extends BaseAPI {
  /**
   *
   * @summary Delete a specific verified email
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VerifiedEmailsApi
   */
  public verifiedEmailsControllerDeleteVerifiedEmail(id: number, options?: AxiosRequestConfig) {
    return VerifiedEmailsApiFp(this.configuration)
      .verifiedEmailsControllerDeleteVerifiedEmail(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Refreshes all parking cards for the email
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VerifiedEmailsApi
   */
  public verifiedEmailsControllerRefreshVerifiedEmail(options?: AxiosRequestConfig) {
    return VerifiedEmailsApiFp(this.configuration)
      .verifiedEmailsControllerRefreshVerifiedEmail(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Send out emails for each email for verification
   * @param {VerifyEmailsDto} verifyEmailsDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VerifiedEmailsApi
   */
  public verifiedEmailsControllerSendEmailVerificationEmails(
    verifyEmailsDto: VerifyEmailsDto,
    options?: AxiosRequestConfig,
  ) {
    return VerifiedEmailsApiFp(this.configuration)
      .verifiedEmailsControllerSendEmailVerificationEmails(verifyEmailsDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all verified emails associated with the user
   * @param {number} [page] Page number
   * @param {number} [pageSize] Items per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VerifiedEmailsApi
   */
  public verifiedEmailsControllerVerifiedEmailsGetMany(
    page?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return VerifiedEmailsApiFp(this.configuration)
      .verifiedEmailsControllerVerifiedEmailsGetMany(page, pageSize, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Verifies an email with token
   * @param {string} token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VerifiedEmailsApi
   */
  public verifiedEmailsControllerVerifyEmail(token: string, options?: AxiosRequestConfig) {
    return VerifiedEmailsApiFp(this.configuration)
      .verifiedEmailsControllerVerifyEmail(token, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
