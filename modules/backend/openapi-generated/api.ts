/* tslint:disable */
/* eslint-disable */
/**
 * PAAS MPA backend
 * BPA
 *
 * The version of the OpenAPI document: 1.0
 * Contact: inovacie@bratislava.sk
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base'

/**
 *
 * @export
 * @interface AnnouncementDto
 */
export interface AnnouncementDto {
  /**
   * Title of the announcement
   * @type {string}
   * @memberof AnnouncementDto
   */
  title: string
  /**
   * Content of the announcement
   * @type {string}
   * @memberof AnnouncementDto
   */
  content: string
  /**
   * External url to route the user on CTA
   * @type {object}
   * @memberof AnnouncementDto
   */
  externalUrl?: object
  /**
   * Database id of the announcement
   * @type {number}
   * @memberof AnnouncementDto
   */
  id: number
  /**
   * Date of the creation
   * @type {string}
   * @memberof AnnouncementDto
   */
  createdAt: string
}
/**
 *
 * @export
 * @interface AnnouncementsResponseDto
 */
export interface AnnouncementsResponseDto {
  /**
   * List of announcements
   * @type {Array<AnnouncementDto>}
   * @memberof AnnouncementsResponseDto
   */
  announcements: Array<AnnouncementDto>
  /**
   *
   * @type {PaginationInfo}
   * @memberof AnnouncementsResponseDto
   */
  paginationInfo: PaginationInfo
}
/**
 *
 * @export
 * @interface DeleteResponseDto
 */
export interface DeleteResponseDto {
  /**
   * ID of the deleted object
   * @type {number}
   * @memberof DeleteResponseDto
   */
  id: number
  /**
   * True if the delete was successful
   * @type {boolean}
   * @memberof DeleteResponseDto
   */
  deleted: boolean
}
/**
 *
 * @export
 * @enum {string}
 */

export const ERRORNAMES = {
  DatabaseError: 'DATABASE ERROR',
  MailgunError: 'MAILGUN_ERROR',
  RabbitMqError: 'RABBIT_MQ_ERROR',
} as const

export type ERRORNAMES = (typeof ERRORNAMES)[keyof typeof ERRORNAMES]

/**
 *
 * @export
 * @interface EmailVerificationResult
 */
export interface EmailVerificationResult {
  /**
   * Verified email address
   * @type {string}
   * @memberof EmailVerificationResult
   */
  email: string
  /**
   * Status signaling if the email was sent successfuly
   * @type {boolean}
   * @memberof EmailVerificationResult
   */
  sent: boolean
  /**
   * Token which is sent to the email - only avaialble for test purposes
   * @type {object}
   * @memberof EmailVerificationResult
   * @deprecated
   */
  token: object
}
/**
 *
 * @export
 * @interface ExpectedErrorDto
 */
export interface ExpectedErrorDto {
  /**
   * Status Code
   * @type {number}
   * @memberof ExpectedErrorDto
   */
  statusCode: number
  /**
   * Status in text
   * @type {string}
   * @memberof ExpectedErrorDto
   */
  status: string
  /**
   * Detail error message
   * @type {string}
   * @memberof ExpectedErrorDto
   */
  message: string
  /**
   *
   * @type {ERRORNAMES}
   * @memberof ExpectedErrorDto
   */
  errorName: ERRORNAMES
}

/**
 *
 * @export
 * @interface FeedbackDto
 */
export interface FeedbackDto {
  /**
   *
   * @type {FeedbackType}
   * @memberof FeedbackDto
   */
  type: FeedbackType
  /**
   * Email of the feedback reporter
   * @type {string}
   * @memberof FeedbackDto
   */
  email: string
  /**
   * Message of the feedback
   * @type {string}
   * @memberof FeedbackDto
   */
  message: string
}

/**
 *
 * @export
 * @enum {string}
 */

export const FeedbackType = {
  _0: '0',
  _1: '1',
} as const

export type FeedbackType = (typeof FeedbackType)[keyof typeof FeedbackType]

/**
 *
 * @export
 * @interface GetTicketPriceRequestDto
 */
export interface GetTicketPriceRequestDto {
  /**
   * Value of NPK UUID
   * @type {string}
   * @memberof GetTicketPriceRequestDto
   */
  npkId?: string
  /**
   * Value of BPK UUID
   * @type {string}
   * @memberof GetTicketPriceRequestDto
   */
  bpkId?: string
  /**
   *
   * @type {GetTicketPriceTicketInfoRequestDto}
   * @memberof GetTicketPriceRequestDto
   */
  ticket: GetTicketPriceTicketInfoRequestDto
}
/**
 *
 * @export
 * @interface GetTicketPriceResponseDto
 */
export interface GetTicketPriceResponseDto {
  /**
   * Total ticket price considering all discounts and credits. Tax inculded if there is any
   * @type {number}
   * @memberof GetTicketPriceResponseDto
   */
  priceTotal: number
  /**
   * Tax in euros from total price.
   * @type {number}
   * @memberof GetTicketPriceResponseDto
   */
  tax?: number
  /**
   * Total ticket price considering all discounts and credits.
   * @type {number}
   * @memberof GetTicketPriceResponseDto
   */
  priceWithoutTax?: number
  /**
   * Total price without discounts. Tax included if there is any
   * @type {number}
   * @memberof GetTicketPriceResponseDto
   */
  priceWithoutDiscount: number
  /**
   * Bonus minutes used
   * @type {string}
   * @memberof GetTicketPriceResponseDto
   */
  creditBPKUsed: string
  /**
   * NPK - Bonus minutes used
   * @type {string}
   * @memberof GetTicketPriceResponseDto
   */
  creditNpkUsed?: string
  /**
   * The date and time when parking starts (UTC time in ISO8601 format)
   * @type {string}
   * @memberof GetTicketPriceResponseDto
   */
  ticketStart: string
  /**
   * Parking only allowed up to this date/time. Can be different from requested ParkingEnd. Limited by maximum parking time in current parking regulation section.
   * @type {string}
   * @memberof GetTicketPriceResponseDto
   */
  ticketEnd: string
}
/**
 *
 * @export
 * @interface GetTicketPriceTicketInfoRequestDto
 */
export interface GetTicketPriceTicketInfoRequestDto {
  /**
   * Parking vehicle registration number
   * @type {string}
   * @memberof GetTicketPriceTicketInfoRequestDto
   */
  ecv: string
  /**
   * Unique identification of parking slot (specific section of parking regulation)
   * @type {string}
   * @memberof GetTicketPriceTicketInfoRequestDto
   */
  udr: string
  /**
   * The date and time when parking ends (UTC time in ISO8601 format)
   * @type {string}
   * @memberof GetTicketPriceTicketInfoRequestDto
   */
  parkingEnd: string
}
/**
 *
 * @export
 * @interface GetTicketProlongationPriceRequestDto
 */
export interface GetTicketProlongationPriceRequestDto {
  /**
   * The date and time when parking ends (UTC time in ISO8601 format)
   * @type {string}
   * @memberof GetTicketProlongationPriceRequestDto
   */
  newParkingEnd: string
  /**
   * Value of BPK UUID
   * @type {string}
   * @memberof GetTicketProlongationPriceRequestDto
   */
  bpkId?: string
  /**
   * Id of the ticket to be prolonged
   * @type {number}
   * @memberof GetTicketProlongationPriceRequestDto
   */
  ticketId: number
}
/**
 *
 * @export
 * @interface InitiatePaymentRequestDto
 */
export interface InitiatePaymentRequestDto {
  /**
   *
   * @type {GetTicketPriceRequestDto}
   * @memberof InitiatePaymentRequestDto
   */
  ticket: GetTicketPriceRequestDto
  /**
   * Price coming from the FE what the user seen last time and accepted to pay for the ticket
   * @type {number}
   * @memberof InitiatePaymentRequestDto
   */
  price: number
  /**
   * Price coming from the FE what the user seen last time and accepted to pay for the ticket from the BPK credit
   * @type {string}
   * @memberof InitiatePaymentRequestDto
   */
  priceBpk: string
  /**
   * Price coming from the FE what the user seen last time and accepted to pay for the ticket from the NPK credit
   * @type {string}
   * @memberof InitiatePaymentRequestDto
   */
  priceNpk: string
}
/**
 *
 * @export
 * @interface PaginationInfo
 */
export interface PaginationInfo {
  /**
   * Total number of entities
   * @type {number}
   * @memberof PaginationInfo
   */
  total: number
  /**
   * Current page
   * @type {number}
   * @memberof PaginationInfo
   */
  currentPage: number
  /**
   * Current page size
   * @type {number}
   * @memberof PaginationInfo
   */
  pageSize: number
}
/**
 *
 * @export
 * @interface ParkingCardDetail
 */
export interface ParkingCardDetail {
  /**
   * Name of the card cheme
   * @type {string}
   * @memberof ParkingCardDetail
   */
  cardSchemeName?: string
  /**
   * The vehicle plate number for which the card was issued. (Some cards are not issued to the vehicle. Therefore, it may be missing.)
   * @type {string}
   * @memberof ParkingCardDetail
   */
  vehiclePlateNumber?: string
  /**
   * Start of card validity. ISO8601 formatted UTC timestamp
   * @type {string}
   * @memberof ParkingCardDetail
   */
  validFrom?: string
  /**
   * End of card validity. ISO8601 formatted UTC timestamp.
   * @type {string}
   * @memberof ParkingCardDetail
   */
  validTo?: string
  /**
   * Balance available on the visitor card (ISO8601 duration)
   * @type {string}
   * @memberof ParkingCardDetail
   */
  balance?: string
  /**
   * List of Internal ids of the parking space.
   * @type {Array<string>}
   * @memberof ParkingCardDetail
   */
  parkingSpaces?: Array<string>
}
/**
 *
 * @export
 * @interface ParkingCardDto
 */
export interface ParkingCardDto {
  /**
   * Database id of the verified email
   * @type {number}
   * @memberof ParkingCardDto
   */
  id: number
  /**
   * Identificator from parkdots (npkid)
   * @type {string}
   * @memberof ParkingCardDto
   */
  identificator: string
  /**
   *
   * @type {ParkingCardType}
   * @memberof ParkingCardDto
   */
  type: ParkingCardType
  /**
   * Date of the creation
   * @type {string}
   * @memberof ParkingCardDto
   */
  createdAt: string
  /**
   * Date of the last change
   * @type {string}
   * @memberof ParkingCardDto
   */
  updatedAt: string
}

/**
 *
 * @export
 * @interface ParkingCardFullDto
 */
export interface ParkingCardFullDto {
  /**
   * Database id of the verified email
   * @type {number}
   * @memberof ParkingCardFullDto
   */
  id: number
  /**
   * Identificator from parkdots (npkid)
   * @type {string}
   * @memberof ParkingCardFullDto
   */
  identificator: string
  /**
   *
   * @type {ParkingCardType}
   * @memberof ParkingCardFullDto
   */
  type: ParkingCardType
  /**
   * Date of the creation
   * @type {string}
   * @memberof ParkingCardFullDto
   */
  createdAt: string
  /**
   * Date of the last change
   * @type {string}
   * @memberof ParkingCardFullDto
   */
  updatedAt: string
  /**
   *
   * @type {VerifiedEmailDto}
   * @memberof ParkingCardFullDto
   */
  verifiedEmail: VerifiedEmailDto
  /**
   *
   * @type {ParkingCardDetail}
   * @memberof ParkingCardFullDto
   */
  details: ParkingCardDetail
}

/**
 *
 * @export
 * @enum {string}
 */

export const ParkingCardType = {
  Abonent: 'ABONENT',
  Rezident: 'REZIDENT',
  Bpk: 'BPK',
  Npk: 'NPK',
  Tzp: 'TZP',
  Elektromobil: 'ELEKTROMOBIL',
  Other: 'OTHER',
} as const

export type ParkingCardType = (typeof ParkingCardType)[keyof typeof ParkingCardType]

/**
 *
 * @export
 * @interface ParkingCardsResponseDto
 */
export interface ParkingCardsResponseDto {
  /**
   * List of parking cards
   * @type {Array<ParkingCardFullDto>}
   * @memberof ParkingCardsResponseDto
   */
  parkingCards: Array<ParkingCardFullDto>
  /**
   *
   * @type {PaginationInfo}
   * @memberof ParkingCardsResponseDto
   */
  paginationInfo: PaginationInfo
}
/**
 *
 * @export
 * @interface SaveAnnouncementDto
 */
export interface SaveAnnouncementDto {
  /**
   * Title of the announcement
   * @type {string}
   * @memberof SaveAnnouncementDto
   */
  title: string
  /**
   * Content of the announcement
   * @type {string}
   * @memberof SaveAnnouncementDto
   */
  content: string
  /**
   * External url to route the user on CTA
   * @type {object}
   * @memberof SaveAnnouncementDto
   */
  externalUrl?: object
}
/**
 *
 * @export
 * @interface SaveUserSettingsDto
 */
export interface SaveUserSettingsDto {
  /**
   * Set true to send push notifications for tickets about to end
   * @type {boolean}
   * @memberof SaveUserSettingsDto
   */
  pushNotificationsAboutToEnd: boolean
  /**
   * Set true to send push notifications for tickets about to end
   * @type {boolean}
   * @memberof SaveUserSettingsDto
   */
  pushNotificationsToEnd: boolean
  /**
   * Set true to send push notifications for tickets about to end
   * @type {boolean}
   * @memberof SaveUserSettingsDto
   */
  emailNotificationsAboutToEnd: boolean
  /**
   * Set true to send push notifications for tickets about to end
   * @type {boolean}
   * @memberof SaveUserSettingsDto
   */
  emailNotificationsToEnd: boolean
}
/**
 *
 * @export
 * @interface SaveVehicleDto
 */
export interface SaveVehicleDto {
  /**
   * License plate number
   * @type {string}
   * @memberof SaveVehicleDto
   */
  vehiclePlateNumber: string
  /**
   * Name of the vehicle (user input)
   * @type {string}
   * @memberof SaveVehicleDto
   */
  name: string
  /**
   * Set to true to be the default car
   * @type {boolean}
   * @memberof SaveVehicleDto
   */
  isDefault: boolean
}
/**
 *
 * @export
 * @interface TicketDto
 */
export interface TicketDto {
  /**
   * Unique identification of parking slot (specific section of parking regulation)
   * @type {string}
   * @memberof TicketDto
   */
  udr: string
  /**
   * Start of the parking
   * @type {string}
   * @memberof TicketDto
   */
  parkingStart: string
  /**
   * End of the parking
   * @type {string}
   * @memberof TicketDto
   */
  parkingEnd: string
  /**
   * Price of the parking
   * @type {object}
   * @memberof TicketDto
   */
  price?: object
  /**
   * Credits used in case of bonnus parking
   * @type {object}
   * @memberof TicketDto
   */
  bpkCreditUsed?: object
  /**
   * Credits used in case of visitor parking
   * @type {object}
   * @memberof TicketDto
   */
  npkCreditUsed?: object
  /**
   * ID of the visitor card (GUID)
   * @type {object}
   * @memberof TicketDto
   */
  npkId?: object
  /**
   * ID of the bonus card (GUID)
   * @type {object}
   * @memberof TicketDto
   */
  bpkId?: object
  /**
   * Date of the last change
   * @type {string}
   * @memberof TicketDto
   */
  updatedAt: string
  /**
   * Date of the creation
   * @type {string}
   * @memberof TicketDto
   */
  createdAt: string
}
/**
 *
 * @export
 * @interface TicketsResponseDto
 */
export interface TicketsResponseDto {
  /**
   * List of tickets
   * @type {Array<TicketDto>}
   * @memberof TicketsResponseDto
   */
  tickets: Array<TicketDto>
  /**
   *
   * @type {PaginationInfo}
   * @memberof TicketsResponseDto
   */
  paginationInfo: PaginationInfo
}
/**
 *
 * @export
 * @interface UnexpectedErrorDto
 */
export interface UnexpectedErrorDto {
  /**
   * Status Code
   * @type {number}
   * @memberof UnexpectedErrorDto
   */
  statusCode: number
  /**
   * Status in text
   * @type {string}
   * @memberof UnexpectedErrorDto
   */
  status: string
  /**
   * Detail error message
   * @type {string}
   * @memberof UnexpectedErrorDto
   */
  message: string
  /**
   * Exact error name
   * @type {string}
   * @memberof UnexpectedErrorDto
   */
  errorName: string
}
/**
 *
 * @export
 * @interface UserSettingsDto
 */
export interface UserSettingsDto {
  /**
   * Set true to send push notifications for tickets about to end
   * @type {boolean}
   * @memberof UserSettingsDto
   */
  pushNotificationsAboutToEnd: boolean
  /**
   * Set true to send push notifications for tickets about to end
   * @type {boolean}
   * @memberof UserSettingsDto
   */
  pushNotificationsToEnd: boolean
  /**
   * Set true to send push notifications for tickets about to end
   * @type {boolean}
   * @memberof UserSettingsDto
   */
  emailNotificationsAboutToEnd: boolean
  /**
   * Set true to send push notifications for tickets about to end
   * @type {boolean}
   * @memberof UserSettingsDto
   */
  emailNotificationsToEnd: boolean
  /**
   * Date of the first creation
   * @type {string}
   * @memberof UserSettingsDto
   */
  createdAt: string
  /**
   * Date of the last modificaiton
   * @type {string}
   * @memberof UserSettingsDto
   */
  updatedAt: string
}
/**
 *
 * @export
 * @interface VehicleDto
 */
export interface VehicleDto {
  /**
   * License plate number
   * @type {string}
   * @memberof VehicleDto
   */
  vehiclePlateNumber: string
  /**
   * Name of the vehicle (user input)
   * @type {string}
   * @memberof VehicleDto
   */
  name: string
  /**
   * Set to true to be the default car
   * @type {boolean}
   * @memberof VehicleDto
   */
  isDefault: boolean
  /**
   * Database id of the vehicle
   * @type {number}
   * @memberof VehicleDto
   */
  id: number
  /**
   * Date of the creation
   * @type {string}
   * @memberof VehicleDto
   */
  createdAt: string
  /**
   * Date of the last change
   * @type {string}
   * @memberof VehicleDto
   */
  updatedAt: string
}
/**
 *
 * @export
 * @interface VehiclesResponseDto
 */
export interface VehiclesResponseDto {
  /**
   * List of vehicles
   * @type {Array<VehicleDto>}
   * @memberof VehiclesResponseDto
   */
  vehicles: Array<VehicleDto>
  /**
   *
   * @type {PaginationInfo}
   * @memberof VehiclesResponseDto
   */
  paginationInfo: PaginationInfo
}
/**
 *
 * @export
 * @interface VerifiedEmailDto
 */
export interface VerifiedEmailDto {
  /**
   * Database id of the verified email
   * @type {number}
   * @memberof VerifiedEmailDto
   */
  id: number
  /**
   * Email address
   * @type {string}
   * @memberof VerifiedEmailDto
   */
  email: string
  /**
   * Date of the creation
   * @type {string}
   * @memberof VerifiedEmailDto
   */
  createdAt: string
  /**
   * Date of the last change
   * @type {string}
   * @memberof VerifiedEmailDto
   */
  updatedAt: string
}
/**
 *
 * @export
 * @interface VerifiedEmailsResponseDto
 */
export interface VerifiedEmailsResponseDto {
  /**
   * List of verified emails
   * @type {Array<VerifiedEmailDto>}
   * @memberof VerifiedEmailsResponseDto
   */
  verifiedEmails: Array<VerifiedEmailDto>
  /**
   *
   * @type {PaginationInfo}
   * @memberof VerifiedEmailsResponseDto
   */
  paginationInfo: PaginationInfo
}
/**
 *
 * @export
 * @interface VerifyEmailsDto
 */
export interface VerifyEmailsDto {
  /**
   * List of emails to verify
   * @type {Array<string>}
   * @memberof VerifyEmailsDto
   */
  emails: Array<string>
}

/**
 * AnnouncementsApi - axios parameter creator
 * @export
 */
export const AnnouncementsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get all announcements paginated
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    announcementsControllerAnnouncementsGetMany: async (
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/announcements`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Delete a specific announcement
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    announcementsControllerDeleteAnnouncement: async (
      id: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('announcementsControllerDeleteAnnouncement', 'id', id)
      const localVarPath = `/announcements/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication azure required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Inserts new vehicle
     * @param {SaveAnnouncementDto} saveAnnouncementDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    announcementsControllerInsertAnnouncement: async (
      saveAnnouncementDto: SaveAnnouncementDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'saveAnnouncementDto' is not null or undefined
      assertParamExists(
        'announcementsControllerInsertAnnouncement',
        'saveAnnouncementDto',
        saveAnnouncementDto,
      )
      const localVarPath = `/announcements`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication azure required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        saveAnnouncementDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AnnouncementsApi - functional programming interface
 * @export
 */
export const AnnouncementsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AnnouncementsApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Get all announcements paginated
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async announcementsControllerAnnouncementsGetMany(
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouncementsResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.announcementsControllerAnnouncementsGetMany(
          page,
          pageSize,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Delete a specific announcement
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async announcementsControllerDeleteAnnouncement(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteResponseDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.announcementsControllerDeleteAnnouncement(id, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Inserts new vehicle
     * @param {SaveAnnouncementDto} saveAnnouncementDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async announcementsControllerInsertAnnouncement(
      saveAnnouncementDto: SaveAnnouncementDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouncementDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.announcementsControllerInsertAnnouncement(
          saveAnnouncementDto,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * AnnouncementsApi - factory interface
 * @export
 */
export const AnnouncementsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AnnouncementsApiFp(configuration)
  return {
    /**
     *
     * @summary Get all announcements paginated
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    announcementsControllerAnnouncementsGetMany(
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<AnnouncementsResponseDto> {
      return localVarFp
        .announcementsControllerAnnouncementsGetMany(page, pageSize, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Delete a specific announcement
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    announcementsControllerDeleteAnnouncement(
      id: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<DeleteResponseDto> {
      return localVarFp
        .announcementsControllerDeleteAnnouncement(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Inserts new vehicle
     * @param {SaveAnnouncementDto} saveAnnouncementDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    announcementsControllerInsertAnnouncement(
      saveAnnouncementDto: SaveAnnouncementDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<AnnouncementDto> {
      return localVarFp
        .announcementsControllerInsertAnnouncement(saveAnnouncementDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * AnnouncementsApi - object-oriented interface
 * @export
 * @class AnnouncementsApi
 * @extends {BaseAPI}
 */
export class AnnouncementsApi extends BaseAPI {
  /**
   *
   * @summary Get all announcements paginated
   * @param {number} [page] Page number
   * @param {number} [pageSize] Items per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AnnouncementsApi
   */
  public announcementsControllerAnnouncementsGetMany(
    page?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return AnnouncementsApiFp(this.configuration)
      .announcementsControllerAnnouncementsGetMany(page, pageSize, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Delete a specific announcement
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AnnouncementsApi
   */
  public announcementsControllerDeleteAnnouncement(id: number, options?: AxiosRequestConfig) {
    return AnnouncementsApiFp(this.configuration)
      .announcementsControllerDeleteAnnouncement(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Inserts new vehicle
   * @param {SaveAnnouncementDto} saveAnnouncementDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AnnouncementsApi
   */
  public announcementsControllerInsertAnnouncement(
    saveAnnouncementDto: SaveAnnouncementDto,
    options?: AxiosRequestConfig,
  ) {
    return AnnouncementsApiFp(this.configuration)
      .announcementsControllerInsertAnnouncement(saveAnnouncementDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * See if nest is working!
     * @summary Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerHealth: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/healthcheck`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
  return {
    /**
     * See if nest is working!
     * @summary Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async appControllerHealth(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerHealth(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DefaultApiFp(configuration)
  return {
    /**
     * See if nest is working!
     * @summary Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerHealth(options?: AxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.appControllerHealth(options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   * See if nest is working!
   * @summary Healthcheck
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public appControllerHealth(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .appControllerHealth(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ParkingCardsApi - axios parameter creator
 * @export
 */
export const ParkingCardsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get all parking cards associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    parkingCardsControllerGetParkingCards: async (
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/parking-cards`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ParkingCardsApi - functional programming interface
 * @export
 */
export const ParkingCardsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ParkingCardsApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Get all parking cards associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async parkingCardsControllerGetParkingCards(
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParkingCardsResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.parkingCardsControllerGetParkingCards(
          page,
          pageSize,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * ParkingCardsApi - factory interface
 * @export
 */
export const ParkingCardsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ParkingCardsApiFp(configuration)
  return {
    /**
     *
     * @summary Get all parking cards associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    parkingCardsControllerGetParkingCards(
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<ParkingCardsResponseDto> {
      return localVarFp
        .parkingCardsControllerGetParkingCards(page, pageSize, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ParkingCardsApi - object-oriented interface
 * @export
 * @class ParkingCardsApi
 * @extends {BaseAPI}
 */
export class ParkingCardsApi extends BaseAPI {
  /**
   *
   * @summary Get all parking cards associated with the user
   * @param {number} [page] Page number
   * @param {number} [pageSize] Items per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ParkingCardsApi
   */
  public parkingCardsControllerGetParkingCards(
    page?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return ParkingCardsApiFp(this.configuration)
      .parkingCardsControllerGetParkingCards(page, pageSize, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * SystemApi - axios parameter creator
 * @export
 */
export const SystemApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Send feedback
     * @param {FeedbackDto} feedbackDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    systemControllerSendFeedback: async (
      feedbackDto: FeedbackDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'feedbackDto' is not null or undefined
      assertParamExists('systemControllerSendFeedback', 'feedbackDto', feedbackDto)
      const localVarPath = `/system`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        feedbackDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SystemApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Send feedback
     * @param {FeedbackDto} feedbackDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async systemControllerSendFeedback(
      feedbackDto: FeedbackDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.systemControllerSendFeedback(
        feedbackDto,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SystemApiFp(configuration)
  return {
    /**
     *
     * @summary Send feedback
     * @param {FeedbackDto} feedbackDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    systemControllerSendFeedback(
      feedbackDto: FeedbackDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<boolean> {
      return localVarFp
        .systemControllerSendFeedback(feedbackDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
  /**
   *
   * @summary Send feedback
   * @param {FeedbackDto} feedbackDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public systemControllerSendFeedback(feedbackDto: FeedbackDto, options?: AxiosRequestConfig) {
    return SystemApiFp(this.configuration)
      .systemControllerSendFeedback(feedbackDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * TicketsApi - axios parameter creator
 * @export
 */
export const TicketsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get ticket price
     * @param {GetTicketPriceRequestDto} getTicketPriceRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerGetTicketPrice: async (
      getTicketPriceRequestDto: GetTicketPriceRequestDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getTicketPriceRequestDto' is not null or undefined
      assertParamExists(
        'ticketsControllerGetTicketPrice',
        'getTicketPriceRequestDto',
        getTicketPriceRequestDto,
      )
      const localVarPath = `/tickets/price`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        getTicketPriceRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get ticket prolongation price
     * @param {GetTicketProlongationPriceRequestDto} getTicketProlongationPriceRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerGetTicketProlongationPrice: async (
      getTicketProlongationPriceRequestDto: GetTicketProlongationPriceRequestDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getTicketProlongationPriceRequestDto' is not null or undefined
      assertParamExists(
        'ticketsControllerGetTicketProlongationPrice',
        'getTicketProlongationPriceRequestDto',
        getTicketProlongationPriceRequestDto,
      )
      const localVarPath = `/tickets/prolongation/price`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        getTicketProlongationPriceRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Initiate ticket payment
     * @param {InitiatePaymentRequestDto} initiatePaymentRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerInitiateTicketPayment: async (
      initiatePaymentRequestDto: InitiatePaymentRequestDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'initiatePaymentRequestDto' is not null or undefined
      assertParamExists(
        'ticketsControllerInitiateTicketPayment',
        'initiatePaymentRequestDto',
        initiatePaymentRequestDto,
      )
      const localVarPath = `/tickets/payment`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        initiatePaymentRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Process ticket payment
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerProcessTicketPayment: async (
      body: object,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('ticketsControllerProcessTicketPayment', 'body', body)
      const localVarPath = `/tickets/payment/process`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get tickets paginated
     * @param {boolean} active True to load active tickets, false to load past tickets
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerTicketsGetMany: async (
      active: boolean,
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'active' is not null or undefined
      assertParamExists('ticketsControllerTicketsGetMany', 'active', active)
      const localVarPath = `/tickets`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (active !== undefined) {
        localVarQueryParameter['active'] = active
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * TicketsApi - functional programming interface
 * @export
 */
export const TicketsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TicketsApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Get ticket price
     * @param {GetTicketPriceRequestDto} getTicketPriceRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerGetTicketPrice(
      getTicketPriceRequestDto: GetTicketPriceRequestDto,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTicketPriceResponseDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ticketsControllerGetTicketPrice(
        getTicketPriceRequestDto,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get ticket prolongation price
     * @param {GetTicketProlongationPriceRequestDto} getTicketProlongationPriceRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerGetTicketProlongationPrice(
      getTicketProlongationPriceRequestDto: GetTicketProlongationPriceRequestDto,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTicketPriceResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.ticketsControllerGetTicketProlongationPrice(
          getTicketProlongationPriceRequestDto,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Initiate ticket payment
     * @param {InitiatePaymentRequestDto} initiatePaymentRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerInitiateTicketPayment(
      initiatePaymentRequestDto: InitiatePaymentRequestDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.ticketsControllerInitiateTicketPayment(
          initiatePaymentRequestDto,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Process ticket payment
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerProcessTicketPayment(
      body: object,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.ticketsControllerProcessTicketPayment(body, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get tickets paginated
     * @param {boolean} active True to load active tickets, false to load past tickets
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerTicketsGetMany(
      active: boolean,
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketsResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ticketsControllerTicketsGetMany(
        active,
        page,
        pageSize,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * TicketsApi - factory interface
 * @export
 */
export const TicketsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = TicketsApiFp(configuration)
  return {
    /**
     *
     * @summary Get ticket price
     * @param {GetTicketPriceRequestDto} getTicketPriceRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerGetTicketPrice(
      getTicketPriceRequestDto: GetTicketPriceRequestDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<GetTicketPriceResponseDto> {
      return localVarFp
        .ticketsControllerGetTicketPrice(getTicketPriceRequestDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get ticket prolongation price
     * @param {GetTicketProlongationPriceRequestDto} getTicketProlongationPriceRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerGetTicketProlongationPrice(
      getTicketProlongationPriceRequestDto: GetTicketProlongationPriceRequestDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<GetTicketPriceResponseDto> {
      return localVarFp
        .ticketsControllerGetTicketProlongationPrice(getTicketProlongationPriceRequestDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Initiate ticket payment
     * @param {InitiatePaymentRequestDto} initiatePaymentRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerInitiateTicketPayment(
      initiatePaymentRequestDto: InitiatePaymentRequestDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<TicketDto> {
      return localVarFp
        .ticketsControllerInitiateTicketPayment(initiatePaymentRequestDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Process ticket payment
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerProcessTicketPayment(
      body: object,
      options?: AxiosRequestConfig,
    ): AxiosPromise<TicketDto> {
      return localVarFp
        .ticketsControllerProcessTicketPayment(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get tickets paginated
     * @param {boolean} active True to load active tickets, false to load past tickets
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerTicketsGetMany(
      active: boolean,
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<TicketsResponseDto> {
      return localVarFp
        .ticketsControllerTicketsGetMany(active, page, pageSize, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * TicketsApi - object-oriented interface
 * @export
 * @class TicketsApi
 * @extends {BaseAPI}
 */
export class TicketsApi extends BaseAPI {
  /**
   *
   * @summary Get ticket price
   * @param {GetTicketPriceRequestDto} getTicketPriceRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerGetTicketPrice(
    getTicketPriceRequestDto: GetTicketPriceRequestDto,
    options?: AxiosRequestConfig,
  ) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerGetTicketPrice(getTicketPriceRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get ticket prolongation price
   * @param {GetTicketProlongationPriceRequestDto} getTicketProlongationPriceRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerGetTicketProlongationPrice(
    getTicketProlongationPriceRequestDto: GetTicketProlongationPriceRequestDto,
    options?: AxiosRequestConfig,
  ) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerGetTicketProlongationPrice(getTicketProlongationPriceRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Initiate ticket payment
   * @param {InitiatePaymentRequestDto} initiatePaymentRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerInitiateTicketPayment(
    initiatePaymentRequestDto: InitiatePaymentRequestDto,
    options?: AxiosRequestConfig,
  ) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerInitiateTicketPayment(initiatePaymentRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Process ticket payment
   * @param {object} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerProcessTicketPayment(body: object, options?: AxiosRequestConfig) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerProcessTicketPayment(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get tickets paginated
   * @param {boolean} active True to load active tickets, false to load past tickets
   * @param {number} [page] Page number
   * @param {number} [pageSize] Items per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerTicketsGetMany(
    active: boolean,
    page?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerTicketsGetMany(active, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get user settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerGetUserSettings: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/user/settings`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Save user settings
     * @param {SaveUserSettingsDto} saveUserSettingsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerSaveUserSettings: async (
      saveUserSettingsDto: SaveUserSettingsDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'saveUserSettingsDto' is not null or undefined
      assertParamExists(
        'usersControllerSaveUserSettings',
        'saveUserSettingsDto',
        saveUserSettingsDto,
      )
      const localVarPath = `/user/settings`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        saveUserSettingsDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Get user settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersControllerGetUserSettings(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSettingsDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetUserSettings(
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Save user settings
     * @param {SaveUserSettingsDto} saveUserSettingsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersControllerSaveUserSettings(
      saveUserSettingsDto: SaveUserSettingsDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSettingsDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerSaveUserSettings(
        saveUserSettingsDto,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UserApiFp(configuration)
  return {
    /**
     *
     * @summary Get user settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerGetUserSettings(options?: AxiosRequestConfig): AxiosPromise<UserSettingsDto> {
      return localVarFp
        .usersControllerGetUserSettings(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Save user settings
     * @param {SaveUserSettingsDto} saveUserSettingsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerSaveUserSettings(
      saveUserSettingsDto: SaveUserSettingsDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<UserSettingsDto> {
      return localVarFp
        .usersControllerSaveUserSettings(saveUserSettingsDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
  /**
   *
   * @summary Get user settings
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public usersControllerGetUserSettings(options?: AxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .usersControllerGetUserSettings(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Save user settings
   * @param {SaveUserSettingsDto} saveUserSettingsDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public usersControllerSaveUserSettings(
    saveUserSettingsDto: SaveUserSettingsDto,
    options?: AxiosRequestConfig,
  ) {
    return UserApiFp(this.configuration)
      .usersControllerSaveUserSettings(saveUserSettingsDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * VehiclesApi - axios parameter creator
 * @export
 */
export const VehiclesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete a specific vehicle
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehiclesControllerDeleteVehicle: async (
      id: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('vehiclesControllerDeleteVehicle', 'id', id)
      const localVarPath = `/vehicles/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Inserts new vehicle
     * @param {SaveVehicleDto} saveVehicleDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehiclesControllerInsertVehicle: async (
      saveVehicleDto: SaveVehicleDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'saveVehicleDto' is not null or undefined
      assertParamExists('vehiclesControllerInsertVehicle', 'saveVehicleDto', saveVehicleDto)
      const localVarPath = `/vehicles`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        saveVehicleDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Updates a specific vehicle
     * @param {number} id
     * @param {SaveVehicleDto} saveVehicleDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehiclesControllerUpdateVehicle: async (
      id: number,
      saveVehicleDto: SaveVehicleDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('vehiclesControllerUpdateVehicle', 'id', id)
      // verify required parameter 'saveVehicleDto' is not null or undefined
      assertParamExists('vehiclesControllerUpdateVehicle', 'saveVehicleDto', saveVehicleDto)
      const localVarPath = `/vehicles/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        saveVehicleDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get all vehicles associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehiclesControllerVehiclesGetMany: async (
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/vehicles`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * VehiclesApi - functional programming interface
 * @export
 */
export const VehiclesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = VehiclesApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Delete a specific vehicle
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vehiclesControllerDeleteVehicle(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.vehiclesControllerDeleteVehicle(
        id,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Inserts new vehicle
     * @param {SaveVehicleDto} saveVehicleDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vehiclesControllerInsertVehicle(
      saveVehicleDto: SaveVehicleDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VehicleDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.vehiclesControllerInsertVehicle(
        saveVehicleDto,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Updates a specific vehicle
     * @param {number} id
     * @param {SaveVehicleDto} saveVehicleDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vehiclesControllerUpdateVehicle(
      id: number,
      saveVehicleDto: SaveVehicleDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VehicleDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.vehiclesControllerUpdateVehicle(
        id,
        saveVehicleDto,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all vehicles associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vehiclesControllerVehiclesGetMany(
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VehiclesResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.vehiclesControllerVehiclesGetMany(
        page,
        pageSize,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * VehiclesApi - factory interface
 * @export
 */
export const VehiclesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = VehiclesApiFp(configuration)
  return {
    /**
     *
     * @summary Delete a specific vehicle
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehiclesControllerDeleteVehicle(
      id: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<DeleteResponseDto> {
      return localVarFp
        .vehiclesControllerDeleteVehicle(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Inserts new vehicle
     * @param {SaveVehicleDto} saveVehicleDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehiclesControllerInsertVehicle(
      saveVehicleDto: SaveVehicleDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<VehicleDto> {
      return localVarFp
        .vehiclesControllerInsertVehicle(saveVehicleDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Updates a specific vehicle
     * @param {number} id
     * @param {SaveVehicleDto} saveVehicleDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehiclesControllerUpdateVehicle(
      id: number,
      saveVehicleDto: SaveVehicleDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<VehicleDto> {
      return localVarFp
        .vehiclesControllerUpdateVehicle(id, saveVehicleDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get all vehicles associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehiclesControllerVehiclesGetMany(
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<VehiclesResponseDto> {
      return localVarFp
        .vehiclesControllerVehiclesGetMany(page, pageSize, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * VehiclesApi - object-oriented interface
 * @export
 * @class VehiclesApi
 * @extends {BaseAPI}
 */
export class VehiclesApi extends BaseAPI {
  /**
   *
   * @summary Delete a specific vehicle
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VehiclesApi
   */
  public vehiclesControllerDeleteVehicle(id: number, options?: AxiosRequestConfig) {
    return VehiclesApiFp(this.configuration)
      .vehiclesControllerDeleteVehicle(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Inserts new vehicle
   * @param {SaveVehicleDto} saveVehicleDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VehiclesApi
   */
  public vehiclesControllerInsertVehicle(
    saveVehicleDto: SaveVehicleDto,
    options?: AxiosRequestConfig,
  ) {
    return VehiclesApiFp(this.configuration)
      .vehiclesControllerInsertVehicle(saveVehicleDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Updates a specific vehicle
   * @param {number} id
   * @param {SaveVehicleDto} saveVehicleDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VehiclesApi
   */
  public vehiclesControllerUpdateVehicle(
    id: number,
    saveVehicleDto: SaveVehicleDto,
    options?: AxiosRequestConfig,
  ) {
    return VehiclesApiFp(this.configuration)
      .vehiclesControllerUpdateVehicle(id, saveVehicleDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all vehicles associated with the user
   * @param {number} [page] Page number
   * @param {number} [pageSize] Items per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VehiclesApi
   */
  public vehiclesControllerVehiclesGetMany(
    page?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return VehiclesApiFp(this.configuration)
      .vehiclesControllerVehiclesGetMany(page, pageSize, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * VerifiedEmailsApi - axios parameter creator
 * @export
 */
export const VerifiedEmailsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete a specific verified email
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerDeleteVerifiedEmail: async (
      id: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('verifiedEmailsControllerDeleteVerifiedEmail', 'id', id)
      const localVarPath = `/verified-emails/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Send out emails for each email for verification
     * @param {VerifyEmailsDto} verifyEmailsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerSendEmailVerificationEmails: async (
      verifyEmailsDto: VerifyEmailsDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'verifyEmailsDto' is not null or undefined
      assertParamExists(
        'verifiedEmailsControllerSendEmailVerificationEmails',
        'verifyEmailsDto',
        verifyEmailsDto,
      )
      const localVarPath = `/verified-emails`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        verifyEmailsDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get all verified emails associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerVerifiedEmailsGetMany: async (
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/verified-emails`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Verifies an email with token
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerVerifyEmail: async (
      token: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'token' is not null or undefined
      assertParamExists('verifiedEmailsControllerVerifyEmail', 'token', token)
      const localVarPath = `/verified-emails/verify`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (token !== undefined) {
        localVarQueryParameter['token'] = token
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * VerifiedEmailsApi - functional programming interface
 * @export
 */
export const VerifiedEmailsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = VerifiedEmailsApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Delete a specific verified email
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verifiedEmailsControllerDeleteVerifiedEmail(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteResponseDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.verifiedEmailsControllerDeleteVerifiedEmail(id, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Send out emails for each email for verification
     * @param {VerifyEmailsDto} verifyEmailsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verifiedEmailsControllerSendEmailVerificationEmails(
      verifyEmailsDto: VerifyEmailsDto,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EmailVerificationResult>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.verifiedEmailsControllerSendEmailVerificationEmails(
          verifyEmailsDto,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all verified emails associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verifiedEmailsControllerVerifiedEmailsGetMany(
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerifiedEmailsResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.verifiedEmailsControllerVerifiedEmailsGetMany(
          page,
          pageSize,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Verifies an email with token
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verifiedEmailsControllerVerifyEmail(
      token: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ParkingCardDto>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.verifiedEmailsControllerVerifyEmail(
        token,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * VerifiedEmailsApi - factory interface
 * @export
 */
export const VerifiedEmailsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = VerifiedEmailsApiFp(configuration)
  return {
    /**
     *
     * @summary Delete a specific verified email
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerDeleteVerifiedEmail(
      id: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<DeleteResponseDto> {
      return localVarFp
        .verifiedEmailsControllerDeleteVerifiedEmail(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Send out emails for each email for verification
     * @param {VerifyEmailsDto} verifyEmailsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerSendEmailVerificationEmails(
      verifyEmailsDto: VerifyEmailsDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<Array<EmailVerificationResult>> {
      return localVarFp
        .verifiedEmailsControllerSendEmailVerificationEmails(verifyEmailsDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get all verified emails associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerVerifiedEmailsGetMany(
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<VerifiedEmailsResponseDto> {
      return localVarFp
        .verifiedEmailsControllerVerifiedEmailsGetMany(page, pageSize, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Verifies an email with token
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerVerifyEmail(
      token: string,
      options?: AxiosRequestConfig,
    ): AxiosPromise<Array<ParkingCardDto>> {
      return localVarFp
        .verifiedEmailsControllerVerifyEmail(token, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * VerifiedEmailsApi - object-oriented interface
 * @export
 * @class VerifiedEmailsApi
 * @extends {BaseAPI}
 */
export class VerifiedEmailsApi extends BaseAPI {
  /**
   *
   * @summary Delete a specific verified email
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VerifiedEmailsApi
   */
  public verifiedEmailsControllerDeleteVerifiedEmail(id: number, options?: AxiosRequestConfig) {
    return VerifiedEmailsApiFp(this.configuration)
      .verifiedEmailsControllerDeleteVerifiedEmail(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Send out emails for each email for verification
   * @param {VerifyEmailsDto} verifyEmailsDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VerifiedEmailsApi
   */
  public verifiedEmailsControllerSendEmailVerificationEmails(
    verifyEmailsDto: VerifyEmailsDto,
    options?: AxiosRequestConfig,
  ) {
    return VerifiedEmailsApiFp(this.configuration)
      .verifiedEmailsControllerSendEmailVerificationEmails(verifyEmailsDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all verified emails associated with the user
   * @param {number} [page] Page number
   * @param {number} [pageSize] Items per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VerifiedEmailsApi
   */
  public verifiedEmailsControllerVerifiedEmailsGetMany(
    page?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return VerifiedEmailsApiFp(this.configuration)
      .verifiedEmailsControllerVerifiedEmailsGetMany(page, pageSize, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Verifies an email with token
   * @param {string} token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VerifiedEmailsApi
   */
  public verifiedEmailsControllerVerifyEmail(token: string, options?: AxiosRequestConfig) {
    return VerifiedEmailsApiFp(this.configuration)
      .verifiedEmailsControllerVerifyEmail(token, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
