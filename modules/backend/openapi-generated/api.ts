/* tslint:disable */
/* eslint-disable */
/**
 * PAAS MPA backend
 * MPA
 *
 * The version of the OpenAPI document: 1.0
 * Contact: inovacie@bratislava.sk
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base'

/**
 *
 * @export
 * @interface AnnouncementDto
 */
export interface AnnouncementDto {
  /**
   * Title of the announcement
   * @type {string}
   * @memberof AnnouncementDto
   */
  title: string
  /**
   * Content of the announcement
   * @type {string}
   * @memberof AnnouncementDto
   */
  content: string
  /**
   * Language of the announcement in ISO 639-1 language code
   * @type {string}
   * @memberof AnnouncementDto
   */
  language: string
  /**
   *
   * @type {AnnouncementType}
   * @memberof AnnouncementDto
   */
  type: AnnouncementType
  /**
   * External url to route the user on CTA
   * @type {string}
   * @memberof AnnouncementDto
   */
  externalUrl?: string
  /**
   * Database id of the announcement
   * @type {number}
   * @memberof AnnouncementDto
   */
  id: number
  /**
   * Date of the creation
   * @type {string}
   * @memberof AnnouncementDto
   */
  createdAt: string
}

/**
 * Type of the announcement
 * @export
 * @enum {string}
 */

export const AnnouncementType = {
  Info: 'INFO',
  Warn: 'WARN',
  Error: 'ERROR',
} as const

export type AnnouncementType = (typeof AnnouncementType)[keyof typeof AnnouncementType]

/**
 *
 * @export
 * @interface AnnouncementsResponseDto
 */
export interface AnnouncementsResponseDto {
  /**
   * List of announcements
   * @type {Array<AnnouncementDto>}
   * @memberof AnnouncementsResponseDto
   */
  announcements: Array<AnnouncementDto>
  /**
   *
   * @type {PaginationInfo}
   * @memberof AnnouncementsResponseDto
   */
  paginationInfo: PaginationInfo
}
/**
 *
 * @export
 * @interface CaptureUncapturedPaymentsRequestDto
 */
export interface CaptureUncapturedPaymentsRequestDto {
  /**
   * Ticket ids to process
   * @type {Array<number>}
   * @memberof CaptureUncapturedPaymentsRequestDto
   */
  ids: Array<number>
}
/**
 *
 * @export
 * @interface CreatePushNotificationAnnouncementDto
 */
export interface CreatePushNotificationAnnouncementDto {
  /**
   * Title of the push notification
   * @type {string}
   * @memberof CreatePushNotificationAnnouncementDto
   */
  title: string
  /**
   * Content of the push notification
   * @type {string}
   * @memberof CreatePushNotificationAnnouncementDto
   */
  content: string
  /**
   * Deep link URL for the notification
   * @type {string}
   * @memberof CreatePushNotificationAnnouncementDto
   */
  link?: string
}
/**
 *
 * @export
 * @interface CreateVehicleDto
 */
export interface CreateVehicleDto {
  /**
   * License plate number
   * @type {string}
   * @memberof CreateVehicleDto
   */
  vehiclePlateNumber: string
  /**
   * Name of the vehicle (user input)
   * @type {string}
   * @memberof CreateVehicleDto
   */
  name?: string
  /**
   * Set to true to be the default car
   * @type {boolean}
   * @memberof CreateVehicleDto
   */
  isDefault: boolean
}
/**
 *
 * @export
 * @interface DeleteResponseDto
 */
export interface DeleteResponseDto {
  /**
   * ID of the deleted object
   * @type {number}
   * @memberof DeleteResponseDto
   */
  id: number
  /**
   * True if the delete was successful
   * @type {boolean}
   * @memberof DeleteResponseDto
   */
  deleted: boolean
}
/**
 *
 * @export
 * @interface EmailVerificationResult
 */
export interface EmailVerificationResult {
  /**
   * Verified email address
   * @type {string}
   * @memberof EmailVerificationResult
   */
  email: string
  /**
   * Status signaling if the email was sent successfuly
   * @type {boolean}
   * @memberof EmailVerificationResult
   */
  sent: boolean
}
/**
 *
 * @export
 * @interface FeedbackFormDto
 */
export interface FeedbackFormDto {
  /**
   * Database id of the feedback form
   * @type {number}
   * @memberof FeedbackFormDto
   */
  id: number
  /**
   * Title of the feedback form
   * @type {string}
   * @memberof FeedbackFormDto
   */
  title: string
  /**
   * Description of the feedback form
   * @type {string}
   * @memberof FeedbackFormDto
   */
  description?: string
  /**
   * CTA text of the feedback form
   * @type {string}
   * @memberof FeedbackFormDto
   */
  ctaText: string
  /**
   * Secondary CTA text of the feedback form
   * @type {string}
   * @memberof FeedbackFormDto
   */
  secondaryCtaText: string
  /**
   * External URL where the form is hosted
   * @type {string}
   * @memberof FeedbackFormDto
   */
  externalUrl: string
  /**
   * Date when the form becomes active
   * @type {string}
   * @memberof FeedbackFormDto
   */
  from: string
  /**
   * Date when the form becomes inactive
   * @type {string}
   * @memberof FeedbackFormDto
   */
  to: string
  /**
   * Language code of the feedback form
   * @type {string}
   * @memberof FeedbackFormDto
   */
  language: FeedbackFormDtoLanguageEnum
  /**
   * Date of the creation
   * @type {string}
   * @memberof FeedbackFormDto
   */
  createdAt: string
  /**
   * Date of the last update
   * @type {string}
   * @memberof FeedbackFormDto
   */
  updatedAt: string
}

export const FeedbackFormDtoLanguageEnum = {
  Sk: 'SK',
  En: 'EN',
} as const

export type FeedbackFormDtoLanguageEnum =
  (typeof FeedbackFormDtoLanguageEnum)[keyof typeof FeedbackFormDtoLanguageEnum]

/**
 *
 * @export
 * @interface FeedbackFormsResponseDto
 */
export interface FeedbackFormsResponseDto {
  /**
   * List of feedback forms
   * @type {Array<FeedbackFormDto>}
   * @memberof FeedbackFormsResponseDto
   */
  feedbackForms: Array<FeedbackFormDto>
  /**
   *
   * @type {PaginationInfo}
   * @memberof FeedbackFormsResponseDto
   */
  paginationInfo: PaginationInfo
}
/**
 *
 * @export
 * @interface GetTicketPriceRequestDto
 */
export interface GetTicketPriceRequestDto {
  /**
   * Value of NPK UUID
   * @type {string}
   * @memberof GetTicketPriceRequestDto
   */
  npkId?: string
  /**
   *
   * @type {GetTicketPriceTicketInfoRequestDto}
   * @memberof GetTicketPriceRequestDto
   */
  ticket: GetTicketPriceTicketInfoRequestDto
}
/**
 *
 * @export
 * @interface GetTicketPriceResponseDto
 */
export interface GetTicketPriceResponseDto {
  /**
   * Total ticket price considering all discounts and credits. Tax inculded if there is any
   * @type {number}
   * @memberof GetTicketPriceResponseDto
   */
  priceTotal: number
  /**
   * Tax in euros from total price.
   * @type {number}
   * @memberof GetTicketPriceResponseDto
   */
  tax?: number
  /**
   * Total ticket price considering all discounts and credits.
   * @type {number}
   * @memberof GetTicketPriceResponseDto
   */
  priceWithoutTax?: number
  /**
   * Total price without discounts. Tax included if there is any
   * @type {number}
   * @memberof GetTicketPriceResponseDto
   */
  priceWithoutDiscount: number
  /**
   * Credits used in case of bonus parking in seconds
   * @type {number}
   * @memberof GetTicketPriceResponseDto
   */
  creditBpkUsedSeconds: number
  /**
   * Credits remaining in case of bonus parking in seconds
   * @type {number}
   * @memberof GetTicketPriceResponseDto
   */
  creditBpkRemaining: number
  /**
   * Credits used in case of bonus parking in seconds
   * @type {number}
   * @memberof GetTicketPriceResponseDto
   */
  creditNpkUsedSeconds: number
  /**
   * Credits remaining in case of bonus parking in seconds
   * @type {number}
   * @memberof GetTicketPriceResponseDto
   */
  creditNpkRemaining: number
  /**
   * The date and time when parking starts (UTC time in ISO8601 format)
   * @type {string}
   * @memberof GetTicketPriceResponseDto
   */
  ticketStart: string
  /**
   * Parking only allowed up to this date/time. Can be different from requested ParkingEnd. Limited by maximum parking time in current parking regulation section.
   * @type {string}
   * @memberof GetTicketPriceResponseDto
   */
  ticketEnd: string
  /**
   * UUID
   * @type {string}
   * @memberof GetTicketPriceResponseDto
   */
  bpkId?: string
  /**
   * End of card validity. ISO8601 formatted UTC timestamp.
   * @type {string}
   * @memberof GetTicketPriceResponseDto
   */
  bpkValidTo?: string
  /**
   * Original balance available on the visitor card in seconds
   * @type {number}
   * @memberof GetTicketPriceResponseDto
   */
  bpkOriginalBalanceSeconds?: number
}
/**
 *
 * @export
 * @interface GetTicketPriceTicketInfoRequestDto
 */
export interface GetTicketPriceTicketInfoRequestDto {
  /**
   * Parking vehicle registration number
   * @type {string}
   * @memberof GetTicketPriceTicketInfoRequestDto
   */
  ecv: string
  /**
   * Unique identification of parking slot (specific section of parking regulation)
   * @type {string}
   * @memberof GetTicketPriceTicketInfoRequestDto
   */
  udr: string
  /**
   * GUID - Unique identification of parking slot (specific section of parking regulation)
   * @type {string}
   * @memberof GetTicketPriceTicketInfoRequestDto
   */
  udrUuid?: string
  /**
   * The date and time when parking ends (UTC time in ISO8601 format)
   * @type {string}
   * @memberof GetTicketPriceTicketInfoRequestDto
   */
  parkingEnd: string
  /**
   * The date and time when parking ends (UTC time in ISO8601 format)
   * @type {string}
   * @memberof GetTicketPriceTicketInfoRequestDto
   */
  parkingStart: string
}
/**
 *
 * @export
 * @interface GetTicketProlongationPriceRequestDto
 */
export interface GetTicketProlongationPriceRequestDto {
  /**
   * The date and time when parking ends (UTC time in ISO8601 format)
   * @type {string}
   * @memberof GetTicketProlongationPriceRequestDto
   */
  newParkingEnd: string
  /**
   * Id of the ticket to be prolonged
   * @type {number}
   * @memberof GetTicketProlongationPriceRequestDto
   */
  ticketId: number
}
/**
 *
 * @export
 * @interface InitiatePaymentRequestDto
 */
export interface InitiatePaymentRequestDto {
  /**
   * Value of NPK UUID
   * @type {string}
   * @memberof InitiatePaymentRequestDto
   */
  npkId?: string
  /**
   *
   * @type {GetTicketPriceTicketInfoRequestDto}
   * @memberof InitiatePaymentRequestDto
   */
  ticket: GetTicketPriceTicketInfoRequestDto
  /**
   * Latitude of the parking pin from the application
   * @type {number}
   * @memberof InitiatePaymentRequestDto
   */
  latitude?: number
  /**
   * Longitude of the parking pin from the application
   * @type {number}
   * @memberof InitiatePaymentRequestDto
   */
  longitude?: number
  /**
   * Indicates if the user would like to store the credit card info in the payment gateway
   * @type {boolean}
   * @memberof InitiatePaymentRequestDto
   */
  rememberCard?: boolean
  /**
   *
   * @type {Language}
   * @memberof InitiatePaymentRequestDto
   */
  paygateLanguage?: Language
}

/**
 *
 * @export
 * @interface InitiateProlongationRequestDto
 */
export interface InitiateProlongationRequestDto {
  /**
   * The date and time when parking ends (UTC time in ISO8601 format)
   * @type {string}
   * @memberof InitiateProlongationRequestDto
   */
  newParkingEnd: string
  /**
   * Id of the ticket to be prolonged
   * @type {number}
   * @memberof InitiateProlongationRequestDto
   */
  ticketId: number
  /**
   * Indicates if the user would like to store the credit card info in the payment gateway
   * @type {boolean}
   * @memberof InitiateProlongationRequestDto
   */
  rememberCard?: boolean
  /**
   *
   * @type {Language}
   * @memberof InitiateProlongationRequestDto
   */
  paygateLanguage?: Language
}

/**
 * Language code of the feedback form
 * @export
 * @enum {string}
 */

export const Language = {
  Sk: 'SK',
  En: 'EN',
} as const

export type Language = (typeof Language)[keyof typeof Language]

/**
 *
 * @export
 * @interface MobileAppVersionUpdateDto
 */
export interface MobileAppVersionUpdateDto {
  /**
   * Version required from the user
   * @type {string}
   * @memberof MobileAppVersionUpdateDto
   */
  version: string
}
/**
 *
 * @export
 * @interface MobileDeviceDto
 */
export interface MobileDeviceDto {
  /**
   * Mobile device token for sending push messages
   * @type {string}
   * @memberof MobileDeviceDto
   */
  token: string
  /**
   *
   * @type {MobileDevicePlatform}
   * @memberof MobileDeviceDto
   */
  platform: MobileDevicePlatform
  /**
   * Database id of the mobile device
   * @type {number}
   * @memberof MobileDeviceDto
   */
  id: number
  /**
   * Date of the creation
   * @type {string}
   * @memberof MobileDeviceDto
   */
  createdAt: string
  /**
   * Date of the last change
   * @type {string}
   * @memberof MobileDeviceDto
   */
  updatedAt: string
}

/**
 * Platform of the mobile device
 * @export
 * @enum {string}
 */

export const MobileDevicePlatform = {
  Apple: 'APPLE',
  Android: 'ANDROID',
} as const

export type MobileDevicePlatform = (typeof MobileDevicePlatform)[keyof typeof MobileDevicePlatform]

/**
 *
 * @export
 * @interface MobileDeviceResponseDto
 */
export interface MobileDeviceResponseDto {
  /**
   * List of mobile devices
   * @type {Array<MobileDeviceDto>}
   * @memberof MobileDeviceResponseDto
   */
  devices: Array<MobileDeviceDto>
  /**
   *
   * @type {PaginationInfo}
   * @memberof MobileDeviceResponseDto
   */
  paginationInfo: PaginationInfo
}
/**
 * Exact error name
 * @export
 * @enum {string}
 */

export const PRICINGAPIERROR = {
  InvalidParkingStart: 'InvalidParkingStart',
  InvalidParkingEnd: 'InvalidParkingEnd',
  InvalidParkingTime: 'InvalidParkingTime',
  TooLongParkingTime: 'TooLongParkingTime',
  TooShortParkingTime: 'TooShortParkingTime',
  FreeTicket: 'FreeTicket',
  InsufficientCredit: 'InsufficientCredit',
  NoUsableParkingCardFound: 'NoUsableParkingCardFound',
  PermitCardActive: 'PermitCardActive',
  TicketAlreadyExists: 'TicketAlreadyExists',
  BadDateFormat: 'BadDateFormat',
  CardNotValid: 'CardNotValid',
  TicketAlreadyShortened: 'TicketAlreadyShortened',
  BadRequest: 'BadRequest',
} as const

export type PRICINGAPIERROR = (typeof PRICINGAPIERROR)[keyof typeof PRICINGAPIERROR]

/**
 *
 * @export
 * @interface PaginationInfo
 */
export interface PaginationInfo {
  /**
   * Total number of entities
   * @type {number}
   * @memberof PaginationInfo
   */
  total: number
  /**
   * Current page
   * @type {number}
   * @memberof PaginationInfo
   */
  currentPage: number
  /**
   * Current page size
   * @type {number}
   * @memberof PaginationInfo
   */
  pageSize: number
}
/**
 *
 * @export
 * @interface ParkingCardDto
 */
export interface ParkingCardDto {
  /**
   * Database id of the verified email
   * @type {number}
   * @memberof ParkingCardDto
   */
  id: number
  /**
   * Identificator from parkdots (npkid)
   * @type {string}
   * @memberof ParkingCardDto
   */
  identificator: string
  /**
   *
   * @type {ParkingCardType}
   * @memberof ParkingCardDto
   */
  type: ParkingCardType
  /**
   * Name of the card cheme
   * @type {string}
   * @memberof ParkingCardDto
   */
  name?: string
  /**
   * The vehicle plate number for which the card was issued. (Some cards are not issued to the vehicle. Therefore, it may be missing.)
   * @type {string}
   * @memberof ParkingCardDto
   */
  vehiclePlateNumber?: string
  /**
   * Start of card validity. ISO8601 formatted UTC timestamp
   * @type {string}
   * @memberof ParkingCardDto
   */
  validFrom?: string
  /**
   * End of card validity. ISO8601 formatted UTC timestamp.
   * @type {string}
   * @memberof ParkingCardDto
   */
  validTo?: string
  /**
   * Balance available on the visitor card (PT means \'Period of Time\'. The time format is standardized according to ISO 8601. For example PT1H30M15S - 1 hour 30 minutes 15 seconds.)
   * @type {string}
   * @memberof ParkingCardDto
   */
  balance?: string
  /**
   * Balance available on the visitor card in seconds
   * @type {number}
   * @memberof ParkingCardDto
   */
  balanceSeconds?: number
  /**
   * Original balance available on the visitor card (PT means \'Period of Time\'. The time format is standardized according to ISO 8601. For example PT1H30M15S - 1 hour 30 minutes 15 seconds.)
   * @type {string}
   * @memberof ParkingCardDto
   */
  originalBalance?: string
  /**
   * Original balance available on the visitor card in seconds
   * @type {number}
   * @memberof ParkingCardDto
   */
  originalBalanceSeconds?: number
  /**
   * List of Internal ids of the parking space.
   * @type {Array<string>}
   * @memberof ParkingCardDto
   */
  parkingZones?: Array<string>
  /**
   * Date of the creation
   * @type {string}
   * @memberof ParkingCardDto
   */
  createdAt: string
  /**
   * Date of the last change
   * @type {string}
   * @memberof ParkingCardDto
   */
  updatedAt: string
}

/**
 * Type of the parking card
 * @export
 * @enum {string}
 */

export const ParkingCardType = {
  Abonent: 'ABONENT',
  Rezident: 'REZIDENT',
  Bpk: 'BPK',
  Npk: 'NPK',
  Tzp: 'TZP',
  Elektromobil: 'ELEKTROMOBIL',
  Social: 'SOCIAL',
  Other: 'OTHER',
} as const

export type ParkingCardType = (typeof ParkingCardType)[keyof typeof ParkingCardType]

/**
 *
 * @export
 * @interface ParkingCardsResponseDto
 */
export interface ParkingCardsResponseDto {
  /**
   * List of parking cards
   * @type {Array<ParkingCardDto>}
   * @memberof ParkingCardsResponseDto
   */
  parkingCards: Array<ParkingCardDto>
  /**
   *
   * @type {PaginationInfo}
   * @memberof ParkingCardsResponseDto
   */
  paginationInfo: PaginationInfo
}
/**
 * Status of the payment
 * @export
 * @enum {string}
 */

export const PaymentStatus = {
  Success: 'SUCCESS',
  Pending: 'PENDING',
  Fail: 'FAIL',
  Error: 'ERROR',
} as const

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]

/**
 *
 * @export
 * @interface PaymentUrls
 */
export interface PaymentUrls {
  /**
   * URL address of the payment for Card
   * @type {string}
   * @memberof PaymentUrls
   */
  paymentUrlCard: string
  /**
   * URL address of the payment for APAY
   * @type {string}
   * @memberof PaymentUrls
   */
  paymentUrlAPAY: string
  /**
   * URL address of the payment for GPAY
   * @type {string}
   * @memberof PaymentUrls
   */
  paymentUrlGPAY: string
}
/**
 *
 * @export
 * @interface PushNotificationAnnouncementDto
 */
export interface PushNotificationAnnouncementDto {
  /**
   * Title of the push notification
   * @type {string}
   * @memberof PushNotificationAnnouncementDto
   */
  title: string
  /**
   * Content of the push notification
   * @type {string}
   * @memberof PushNotificationAnnouncementDto
   */
  content: string
  /**
   * Deep link URL for the notification
   * @type {string}
   * @memberof PushNotificationAnnouncementDto
   */
  link?: string
  /**
   * Database ID of the push notification announcement
   * @type {number}
   * @memberof PushNotificationAnnouncementDto
   */
  id: number
  /**
   * Creation timestamp
   * @type {string}
   * @memberof PushNotificationAnnouncementDto
   */
  createdAt: string
}
/**
 *
 * @export
 * @interface PushNotificationAnnouncementsResponseDto
 */
export interface PushNotificationAnnouncementsResponseDto {
  /**
   * List of push notification announcements
   * @type {Array<PushNotificationAnnouncementDto>}
   * @memberof PushNotificationAnnouncementsResponseDto
   */
  items: Array<PushNotificationAnnouncementDto>
  /**
   *
   * @type {PaginationInfo}
   * @memberof PushNotificationAnnouncementsResponseDto
   */
  pagination: PaginationInfo
}
/**
 *
 * @export
 * @interface ResourceDto
 */
export interface ResourceDto {
  /**
   * Key of the resource
   * @type {string}
   * @memberof ResourceDto
   */
  key: string
  /**
   * Language code of the resource
   * @type {string}
   * @memberof ResourceDto
   */
  language: ResourceDtoLanguageEnum
  /**
   * Value of the resource
   * @type {string}
   * @memberof ResourceDto
   */
  value: string
  /**
   * Date of the creation
   * @type {string}
   * @memberof ResourceDto
   */
  createdAt: string
}

export const ResourceDtoLanguageEnum = {
  Sk: 'SK',
  En: 'EN',
} as const

export type ResourceDtoLanguageEnum =
  (typeof ResourceDtoLanguageEnum)[keyof typeof ResourceDtoLanguageEnum]

/**
 *
 * @export
 * @interface ResourcesResponseDto
 */
export interface ResourcesResponseDto {
  /**
   * List of resources
   * @type {Array<ResourceDto>}
   * @memberof ResourcesResponseDto
   */
  resources: Array<ResourceDto>
}
/**
 * Exact error name
 * @export
 * @enum {string}
 */

export const SERVICEERROR = {
  PricingApiError: 'PRICING_API_ERROR',
  ParkdotsError: 'PARKDOTS_ERROR',
  ParkdotsTokenError: 'PARKDOTS_TOKEN_ERROR',
  PaymentInit: 'PAYMENT_INIT',
  PaymentValidation: 'PAYMENT_VALIDATION',
  EmailVerificationTokenIncorrect: 'EMAIL_VERIFICATION_TOKEN_INCORRECT',
  EmailVerificationTokenExpired: 'EMAIL_VERIFICATION_TOKEN_EXPIRED',
  EmailAlreadyVerified: 'EMAIL_ALREADY_VERIFIED',
  TicketProlongationNonActive: 'TICKET_PROLONGATION_NON_ACTIVE',
  TicketMissingParkdotsId: 'TICKET_MISSING_PARKDOTS_ID',
  PaymentResponseIncorrect: 'PAYMENT_RESPONSE_INCORRECT',
  UnsupportedFileType: 'UNSUPPORTED_FILE_TYPE',
} as const

export type SERVICEERROR = (typeof SERVICEERROR)[keyof typeof SERVICEERROR]

/**
 * Exact error name
 * @export
 * @enum {string}
 */

export const SYSTEMERROR = {
  DatabaseError: 'DATABASE_ERROR',
  MailgunError: 'MAILGUN_ERROR',
  RabbitMqError: 'RABBIT_MQ_ERROR',
  PdfGenerator: 'PDF_GENERATOR',
  Paygate: 'PAYGATE',
  Aws: 'AWS',
} as const

export type SYSTEMERROR = (typeof SYSTEMERROR)[keyof typeof SYSTEMERROR]

/**
 *
 * @export
 * @interface SaveAnnouncementDto
 */
export interface SaveAnnouncementDto {
  /**
   * Title of the announcement
   * @type {string}
   * @memberof SaveAnnouncementDto
   */
  title: string
  /**
   * Content of the announcement
   * @type {string}
   * @memberof SaveAnnouncementDto
   */
  content: string
  /**
   * Language of the announcement in ISO 639-1 language code
   * @type {string}
   * @memberof SaveAnnouncementDto
   */
  language: string
  /**
   *
   * @type {AnnouncementType}
   * @memberof SaveAnnouncementDto
   */
  type: AnnouncementType
  /**
   * External url to route the user on CTA
   * @type {string}
   * @memberof SaveAnnouncementDto
   */
  externalUrl?: string
}

/**
 *
 * @export
 * @interface SaveFeedbackFormDto
 */
export interface SaveFeedbackFormDto {
  /**
   * Title of the feedback form
   * @type {string}
   * @memberof SaveFeedbackFormDto
   */
  title: string
  /**
   * Description of the feedback form
   * @type {string}
   * @memberof SaveFeedbackFormDto
   */
  description?: string
  /**
   * CTA text of the feedback form
   * @type {string}
   * @memberof SaveFeedbackFormDto
   */
  ctaText?: string
  /**
   * Secondary CTA text of the feedback form
   * @type {string}
   * @memberof SaveFeedbackFormDto
   */
  secondaryCtaText?: string
  /**
   * External URL where the form is hosted
   * @type {string}
   * @memberof SaveFeedbackFormDto
   */
  externalUrl: string
  /**
   * Date when the form becomes active
   * @type {string}
   * @memberof SaveFeedbackFormDto
   */
  from: string
  /**
   * Date when the form becomes inactive
   * @type {string}
   * @memberof SaveFeedbackFormDto
   */
  to: string
  /**
   *
   * @type {Language}
   * @memberof SaveFeedbackFormDto
   */
  language: Language
}

/**
 *
 * @export
 * @interface SaveMobileDeviceDto
 */
export interface SaveMobileDeviceDto {
  /**
   * Mobile device token for sending push messages
   * @type {string}
   * @memberof SaveMobileDeviceDto
   */
  token: string
  /**
   *
   * @type {MobileDevicePlatform}
   * @memberof SaveMobileDeviceDto
   */
  platform: MobileDevicePlatform
}

/**
 *
 * @export
 * @interface SaveResourceDto
 */
export interface SaveResourceDto {
  /**
   * Key of the resource
   * @type {string}
   * @memberof SaveResourceDto
   */
  key: string
  /**
   * Language code of the resource
   * @type {string}
   * @memberof SaveResourceDto
   */
  language: SaveResourceDtoLanguageEnum
  /**
   * Value of the resource
   * @type {string}
   * @memberof SaveResourceDto
   */
  value: string
}

export const SaveResourceDtoLanguageEnum = {
  Sk: 'SK',
  En: 'EN',
} as const

export type SaveResourceDtoLanguageEnum =
  (typeof SaveResourceDtoLanguageEnum)[keyof typeof SaveResourceDtoLanguageEnum]

/**
 *
 * @export
 * @interface SaveUserSettingsDto
 */
export interface SaveUserSettingsDto {
  /**
   * Set true to send push notifications for tickets about to end
   * @type {boolean}
   * @memberof SaveUserSettingsDto
   */
  pushNotificationsAboutToEnd?: boolean
  /**
   * Set true to send push notifications for tickets about to end
   * @type {boolean}
   * @memberof SaveUserSettingsDto
   */
  pushNotificationsToEnd?: boolean
  /**
   * Set true to send push notifications for tickets about to end
   * @type {boolean}
   * @memberof SaveUserSettingsDto
   */
  emailNotificationsAboutToEnd?: boolean
  /**
   * Set true to send push notifications for tickets about to end
   * @type {boolean}
   * @memberof SaveUserSettingsDto
   */
  emailNotificationsToEnd?: boolean
  /**
   * Set language from front-end to match notifications
   * @type {string}
   * @memberof SaveUserSettingsDto
   */
  language?: string
}
/**
 *
 * @export
 * @interface ServiceErrorDto
 */
export interface ServiceErrorDto {
  /**
   * Status in text
   * @type {string}
   * @memberof ServiceErrorDto
   */
  status: string
  /**
   * Detail error message
   * @type {string}
   * @memberof ServiceErrorDto
   */
  message: string
  /**
   * Status Code
   * @type {number}
   * @memberof ServiceErrorDto
   */
  statusCode: number
  /**
   *
   * @type {SERVICEERROR}
   * @memberof ServiceErrorDto
   */
  errorName: SERVICEERROR
}

/**
 *
 * @export
 * @interface ServicePricingErrorDto
 */
export interface ServicePricingErrorDto {
  /**
   * Status in text
   * @type {string}
   * @memberof ServicePricingErrorDto
   */
  status: string
  /**
   * Detail error message
   * @type {string}
   * @memberof ServicePricingErrorDto
   */
  message: string
  /**
   * Status Code
   * @type {number}
   * @memberof ServicePricingErrorDto
   */
  statusCode: number
  /**
   *
   * @type {PRICINGAPIERROR}
   * @memberof ServicePricingErrorDto
   */
  errorName: PRICINGAPIERROR
}

/**
 *
 * @export
 * @interface StoredPaymentMethodDto
 */
export interface StoredPaymentMethodDto {
  /**
   * Status of the card
   * @type {string}
   * @memberof StoredPaymentMethodDto
   */
  status: string
  /**
   * Card brand name
   * @type {string}
   * @memberof StoredPaymentMethodDto
   */
  brandName?: string
  /**
   * Masked card number where the first 6 and last 4 digits are visible
   * @type {string}
   * @memberof StoredPaymentMethodDto
   */
  mask?: string
}
/**
 *
 * @export
 * @interface SystemErrorDto
 */
export interface SystemErrorDto {
  /**
   * Status in text
   * @type {string}
   * @memberof SystemErrorDto
   */
  status: string
  /**
   * Detail error message
   * @type {string}
   * @memberof SystemErrorDto
   */
  message: string
  /**
   * Status Code
   * @type {number}
   * @memberof SystemErrorDto
   */
  statusCode: number
  /**
   *
   * @type {SYSTEMERROR}
   * @memberof SystemErrorDto
   */
  errorName: SYSTEMERROR
}

/**
 *
 * @export
 * @interface TicketDto
 */
export interface TicketDto {
  /**
   * Database id of the vehicle
   * @type {number}
   * @memberof TicketDto
   */
  id: number
  /**
   * Unique identification of parking slot (specific section of parking regulation)
   * @type {string}
   * @memberof TicketDto
   */
  udr: string
  /**
   * Parking vehicle registration number
   * @type {string}
   * @memberof TicketDto
   */
  ecv: string
  /**
   * Start of the parking
   * @type {string}
   * @memberof TicketDto
   */
  parkingStart: string
  /**
   * End of the parking
   * @type {string}
   * @memberof TicketDto
   */
  parkingEnd: string
  /**
   * Price of the parking
   * @type {number}
   * @memberof TicketDto
   */
  price?: number
  /**
   * Credits used in case of bonus parking in seconds
   * @type {number}
   * @memberof TicketDto
   */
  bpkCreditUsedSeconds: number
  /**
   * Credits used in case of visitor parking in seconds
   * @type {number}
   * @memberof TicketDto
   */
  npkCreditUsedSeconds: number
  /**
   * ID of the visitor card (GUID)
   * @type {string}
   * @memberof TicketDto
   */
  npkId?: string
  /**
   * ID of the bonus card (GUID)
   * @type {string}
   * @memberof TicketDto
   */
  bpkId?: string
  /**
   * ID of the payment in paygate
   * @type {string}
   * @memberof TicketDto
   */
  paymentId?: string
  /**
   *
   * @type {PaymentStatus}
   * @memberof TicketDto
   */
  paymentStatus?: PaymentStatus
  /**
   * Reason of the payment failure. For example: The cardholder canceled the payment
   * @type {string}
   * @memberof TicketDto
   */
  paymentFailReason?: string
  /**
   * Date of the cancellation
   * @type {string}
   * @memberof TicketDto
   */
  canceledAt?: string
  /**
   * ID of the last prolongation ticket.
   * @type {number}
   * @memberof TicketDto
   */
  lastProlongationTicketId?: number
  /**
   * Status of the token registration
   * @type {string}
   * @memberof TicketDto
   */
  tokenRegistrationStatus?: string
  /**
   * Date of the last change
   * @type {string}
   * @memberof TicketDto
   */
  updatedAt: string
  /**
   * Date of the creation
   * @type {string}
   * @memberof TicketDto
   */
  createdAt: string
}

/**
 *
 * @export
 * @interface TicketInitDto
 */
export interface TicketInitDto {
  /**
   * Database id of the vehicle
   * @type {number}
   * @memberof TicketInitDto
   */
  id: number
  /**
   * Unique identification of parking slot (specific section of parking regulation)
   * @type {string}
   * @memberof TicketInitDto
   */
  udr: string
  /**
   * Parking vehicle registration number
   * @type {string}
   * @memberof TicketInitDto
   */
  ecv: string
  /**
   * Start of the parking
   * @type {string}
   * @memberof TicketInitDto
   */
  parkingStart: string
  /**
   * End of the parking
   * @type {string}
   * @memberof TicketInitDto
   */
  parkingEnd: string
  /**
   * Price of the parking
   * @type {number}
   * @memberof TicketInitDto
   */
  price?: number
  /**
   * Credits used in case of bonus parking in seconds
   * @type {number}
   * @memberof TicketInitDto
   */
  bpkCreditUsedSeconds: number
  /**
   * Credits used in case of visitor parking in seconds
   * @type {number}
   * @memberof TicketInitDto
   */
  npkCreditUsedSeconds: number
  /**
   * ID of the visitor card (GUID)
   * @type {string}
   * @memberof TicketInitDto
   */
  npkId?: string
  /**
   * ID of the bonus card (GUID)
   * @type {string}
   * @memberof TicketInitDto
   */
  bpkId?: string
  /**
   * ID of the payment in paygate
   * @type {string}
   * @memberof TicketInitDto
   */
  paymentId?: string
  /**
   *
   * @type {PaymentStatus}
   * @memberof TicketInitDto
   */
  paymentStatus?: PaymentStatus
  /**
   * Reason of the payment failure. For example: The cardholder canceled the payment
   * @type {string}
   * @memberof TicketInitDto
   */
  paymentFailReason?: string
  /**
   * Date of the cancellation
   * @type {string}
   * @memberof TicketInitDto
   */
  canceledAt?: string
  /**
   * ID of the last prolongation ticket.
   * @type {number}
   * @memberof TicketInitDto
   */
  lastProlongationTicketId?: number
  /**
   * Status of the token registration
   * @type {string}
   * @memberof TicketInitDto
   */
  tokenRegistrationStatus?: string
  /**
   * Date of the last change
   * @type {string}
   * @memberof TicketInitDto
   */
  updatedAt: string
  /**
   * Date of the creation
   * @type {string}
   * @memberof TicketInitDto
   */
  createdAt: string
  /**
   *
   * @type {PaymentUrls}
   * @memberof TicketInitDto
   */
  paymentUrls?: PaymentUrls
  /**
   * End of card validity. ISO8601 formatted UTC timestamp.
   * @type {string}
   * @memberof TicketInitDto
   */
  validTo?: string
  /**
   * Balance available on the visitor card in seconds
   * @type {number}
   * @memberof TicketInitDto
   */
  balanceSeconds?: number
  /**
   * Original balance available on the visitor card in seconds
   * @type {number}
   * @memberof TicketInitDto
   */
  originalBalanceSeconds?: number
}

/**
 *
 * @export
 * @interface TicketPaymentDto
 */
export interface TicketPaymentDto {
  /**
   * Main status of the payment. References in gpwebpay documentation.
   * @type {string}
   * @memberof TicketPaymentDto
   */
  status?: string
  /**
   * Substatus of the payment. References in gpwebpay documentation.
   * @type {string}
   * @memberof TicketPaymentDto
   */
  subStatus?: string
  /**
   * Payment method of the transaction. References in gpwebpay documentation.
   * @type {string}
   * @memberof TicketPaymentDto
   */
  paymentMethod?: string
}
/**
 *
 * @export
 * @interface TicketsControllerGetTicketPrice422Response
 */
export interface TicketsControllerGetTicketPrice422Response {
  /**
   * Status in text
   * @type {string}
   * @memberof TicketsControllerGetTicketPrice422Response
   */
  status: string
  /**
   * Detail error message
   * @type {string}
   * @memberof TicketsControllerGetTicketPrice422Response
   */
  message: string
  /**
   * Status Code
   * @type {number}
   * @memberof TicketsControllerGetTicketPrice422Response
   */
  statusCode: number
  /**
   *
   * @type {PRICINGAPIERROR}
   * @memberof TicketsControllerGetTicketPrice422Response
   */
  errorName: PRICINGAPIERROR
}

/**
 *
 * @export
 * @interface TicketsResponseDto
 */
export interface TicketsResponseDto {
  /**
   * List of tickets
   * @type {Array<TicketDto>}
   * @memberof TicketsResponseDto
   */
  tickets: Array<TicketDto>
  /**
   *
   * @type {PaginationInfo}
   * @memberof TicketsResponseDto
   */
  paginationInfo: PaginationInfo
}
/**
 *
 * @export
 * @interface UnexpectedErrorDto
 */
export interface UnexpectedErrorDto {
  /**
   * Status in text
   * @type {string}
   * @memberof UnexpectedErrorDto
   */
  status: string
  /**
   * Detail error message
   * @type {string}
   * @memberof UnexpectedErrorDto
   */
  message: string
  /**
   * Status Code
   * @type {number}
   * @memberof UnexpectedErrorDto
   */
  statusCode: number
  /**
   * Exact error name
   * @type {string}
   * @memberof UnexpectedErrorDto
   */
  errorName: string
}
/**
 *
 * @export
 * @interface UpdatePushNotificationAnnouncementDto
 */
export interface UpdatePushNotificationAnnouncementDto {
  /**
   * Title of the push notification
   * @type {string}
   * @memberof UpdatePushNotificationAnnouncementDto
   */
  title: string
  /**
   * Content of the push notification
   * @type {string}
   * @memberof UpdatePushNotificationAnnouncementDto
   */
  content: string
  /**
   * Deep link URL for the notification
   * @type {string}
   * @memberof UpdatePushNotificationAnnouncementDto
   */
  link?: string
  /**
   * Status of the announcement
   * @type {string}
   * @memberof UpdatePushNotificationAnnouncementDto
   */
  status?: UpdatePushNotificationAnnouncementDtoStatusEnum
}

export const UpdatePushNotificationAnnouncementDtoStatusEnum = {
  Draft: 'draft',
  Sent: 'sent',
} as const

export type UpdatePushNotificationAnnouncementDtoStatusEnum =
  (typeof UpdatePushNotificationAnnouncementDtoStatusEnum)[keyof typeof UpdatePushNotificationAnnouncementDtoStatusEnum]

/**
 *
 * @export
 * @interface UpdateVehicleDto
 */
export interface UpdateVehicleDto {
  /**
   * License plate number
   * @type {string}
   * @memberof UpdateVehicleDto
   */
  vehiclePlateNumber?: string
  /**
   * Name of the vehicle (user input)
   * @type {string}
   * @memberof UpdateVehicleDto
   */
  name?: string
  /**
   * Set to true to be the default car
   * @type {boolean}
   * @memberof UpdateVehicleDto
   */
  isDefault?: boolean
}
/**
 *
 * @export
 * @interface UserSettingsDto
 */
export interface UserSettingsDto {
  /**
   * Set true to send push notifications for tickets about to end
   * @type {boolean}
   * @memberof UserSettingsDto
   */
  pushNotificationsAboutToEnd: boolean
  /**
   * Set true to send push notifications for tickets about to end
   * @type {boolean}
   * @memberof UserSettingsDto
   */
  pushNotificationsToEnd: boolean
  /**
   * Set true to send push notifications for tickets about to end
   * @type {boolean}
   * @memberof UserSettingsDto
   */
  emailNotificationsAboutToEnd: boolean
  /**
   * Set true to send push notifications for tickets about to end
   * @type {boolean}
   * @memberof UserSettingsDto
   */
  emailNotificationsToEnd: boolean
  /**
   * Language of the application
   * @type {string}
   * @memberof UserSettingsDto
   */
  language?: string
  /**
   * Date of the first creation
   * @type {string}
   * @memberof UserSettingsDto
   */
  createdAt: string
  /**
   * Date of the last modificaiton
   * @type {string}
   * @memberof UserSettingsDto
   */
  updatedAt: string
}
/**
 *
 * @export
 * @interface VehicleDto
 */
export interface VehicleDto {
  /**
   * License plate number
   * @type {string}
   * @memberof VehicleDto
   */
  vehiclePlateNumber: string
  /**
   * Name of the vehicle (user input)
   * @type {string}
   * @memberof VehicleDto
   */
  name?: string
  /**
   * Set to true to be the default car
   * @type {boolean}
   * @memberof VehicleDto
   */
  isDefault: boolean
  /**
   * Database id of the vehicle
   * @type {number}
   * @memberof VehicleDto
   */
  id: number
  /**
   * Date of the creation
   * @type {string}
   * @memberof VehicleDto
   */
  createdAt: string
  /**
   * Date of the last change
   * @type {string}
   * @memberof VehicleDto
   */
  updatedAt: string
}
/**
 *
 * @export
 * @interface VehiclesResponseDto
 */
export interface VehiclesResponseDto {
  /**
   * List of vehicles
   * @type {Array<VehicleDto>}
   * @memberof VehiclesResponseDto
   */
  vehicles: Array<VehicleDto>
  /**
   *
   * @type {PaginationInfo}
   * @memberof VehiclesResponseDto
   */
  paginationInfo: PaginationInfo
}
/**
 *
 * @export
 * @interface VerifiedEmailDto
 */
export interface VerifiedEmailDto {
  /**
   * Database id of the verified email
   * @type {number}
   * @memberof VerifiedEmailDto
   */
  id: number
  /**
   * Email address
   * @type {string}
   * @memberof VerifiedEmailDto
   */
  email: string
  /**
   * Date of the creation
   * @type {string}
   * @memberof VerifiedEmailDto
   */
  createdAt: string
  /**
   * Date of the last change
   * @type {string}
   * @memberof VerifiedEmailDto
   */
  updatedAt: string
}
/**
 *
 * @export
 * @interface VerifiedEmailsResponseDto
 */
export interface VerifiedEmailsResponseDto {
  /**
   * List of verified emails
   * @type {Array<VerifiedEmailDto>}
   * @memberof VerifiedEmailsResponseDto
   */
  verifiedEmails: Array<VerifiedEmailDto>
  /**
   *
   * @type {PaginationInfo}
   * @memberof VerifiedEmailsResponseDto
   */
  paginationInfo: PaginationInfo
}
/**
 *
 * @export
 * @interface VerifyEmailsDto
 */
export interface VerifyEmailsDto {
  /**
   * List of emails to verify
   * @type {Array<string>}
   * @memberof VerifyEmailsDto
   */
  emails: Array<string>
  /**
   *
   * @type {ParkingCardType}
   * @memberof VerifyEmailsDto
   */
  type?: ParkingCardType
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Admin endpoint: Capture payment
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerCapturePayment: async (
      id: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('adminControllerCapturePayment', 'id', id)
      const localVarPath = `/admin/capture-payment/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication azure required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Capture tickets with given ids. If done because of tickets which are successful in our db but uncaptured in GPWebpay, get the unclaimed tickets ids by their paymentIds from GP admin.
     * @param {CaptureUncapturedPaymentsRequestDto} captureUncapturedPaymentsRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerCaptureUncapturedPayments: async (
      captureUncapturedPaymentsRequestDto: CaptureUncapturedPaymentsRequestDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'captureUncapturedPaymentsRequestDto' is not null or undefined
      assertParamExists(
        'adminControllerCaptureUncapturedPayments',
        'captureUncapturedPaymentsRequestDto',
        captureUncapturedPaymentsRequestDto,
      )
      const localVarPath = `/admin/capture-uncaptured-payments`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication azure required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        captureUncapturedPaymentsRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Method to get payment status and token status for a specific payment method
     * @param {string} paymentid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerGetPaymentDetails: async (
      paymentid: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'paymentid' is not null or undefined
      assertParamExists('adminControllerGetPaymentDetails', 'paymentid', paymentid)
      const localVarPath = `/admin/payment-detail`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication azure required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (paymentid !== undefined) {
        localVarQueryParameter['paymentid'] = paymentid
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Admin endpoint: Capture payment
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerCapturePayment(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminControllerCapturePayment(
        id,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Capture tickets with given ids. If done because of tickets which are successful in our db but uncaptured in GPWebpay, get the unclaimed tickets ids by their paymentIds from GP admin.
     * @param {CaptureUncapturedPaymentsRequestDto} captureUncapturedPaymentsRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerCaptureUncapturedPayments(
      captureUncapturedPaymentsRequestDto: CaptureUncapturedPaymentsRequestDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerCaptureUncapturedPayments(
          captureUncapturedPaymentsRequestDto,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Method to get payment status and token status for a specific payment method
     * @param {string} paymentid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerGetPaymentDetails(
      paymentid: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminControllerGetPaymentDetails(
        paymentid,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AdminApiFp(configuration)
  return {
    /**
     *
     * @summary Admin endpoint: Capture payment
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerCapturePayment(id: number, options?: AxiosRequestConfig): AxiosPromise<void> {
      return localVarFp
        .adminControllerCapturePayment(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Capture tickets with given ids. If done because of tickets which are successful in our db but uncaptured in GPWebpay, get the unclaimed tickets ids by their paymentIds from GP admin.
     * @param {CaptureUncapturedPaymentsRequestDto} captureUncapturedPaymentsRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerCaptureUncapturedPayments(
      captureUncapturedPaymentsRequestDto: CaptureUncapturedPaymentsRequestDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .adminControllerCaptureUncapturedPayments(captureUncapturedPaymentsRequestDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Method to get payment status and token status for a specific payment method
     * @param {string} paymentid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerGetPaymentDetails(
      paymentid: string,
      options?: AxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .adminControllerGetPaymentDetails(paymentid, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
  /**
   *
   * @summary Admin endpoint: Capture payment
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public adminControllerCapturePayment(id: number, options?: AxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .adminControllerCapturePayment(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Capture tickets with given ids. If done because of tickets which are successful in our db but uncaptured in GPWebpay, get the unclaimed tickets ids by their paymentIds from GP admin.
   * @param {CaptureUncapturedPaymentsRequestDto} captureUncapturedPaymentsRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public adminControllerCaptureUncapturedPayments(
    captureUncapturedPaymentsRequestDto: CaptureUncapturedPaymentsRequestDto,
    options?: AxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .adminControllerCaptureUncapturedPayments(captureUncapturedPaymentsRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Method to get payment status and token status for a specific payment method
   * @param {string} paymentid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public adminControllerGetPaymentDetails(paymentid: string, options?: AxiosRequestConfig) {
    return AdminApiFp(this.configuration)
      .adminControllerGetPaymentDetails(paymentid, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * AnnouncementsApi - axios parameter creator
 * @export
 */
export const AnnouncementsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get all announcements paginated
     * @param {string} language Language of the announcement in ISO 639-1 language code
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    announcementsControllerAnnouncementsGetMany: async (
      language: string,
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'language' is not null or undefined
      assertParamExists('announcementsControllerAnnouncementsGetMany', 'language', language)
      const localVarPath = `/announcements`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (language !== undefined) {
        localVarQueryParameter['language'] = language
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Delete a specific announcement
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    announcementsControllerDeleteAnnouncement: async (
      id: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('announcementsControllerDeleteAnnouncement', 'id', id)
      const localVarPath = `/announcements/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication azure required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Inserts new vehicle
     * @param {SaveAnnouncementDto} saveAnnouncementDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    announcementsControllerInsertAnnouncement: async (
      saveAnnouncementDto: SaveAnnouncementDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'saveAnnouncementDto' is not null or undefined
      assertParamExists(
        'announcementsControllerInsertAnnouncement',
        'saveAnnouncementDto',
        saveAnnouncementDto,
      )
      const localVarPath = `/announcements`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication azure required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        saveAnnouncementDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AnnouncementsApi - functional programming interface
 * @export
 */
export const AnnouncementsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AnnouncementsApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Get all announcements paginated
     * @param {string} language Language of the announcement in ISO 639-1 language code
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async announcementsControllerAnnouncementsGetMany(
      language: string,
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouncementsResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.announcementsControllerAnnouncementsGetMany(
          language,
          page,
          pageSize,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Delete a specific announcement
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async announcementsControllerDeleteAnnouncement(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteResponseDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.announcementsControllerDeleteAnnouncement(id, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Inserts new vehicle
     * @param {SaveAnnouncementDto} saveAnnouncementDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async announcementsControllerInsertAnnouncement(
      saveAnnouncementDto: SaveAnnouncementDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouncementDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.announcementsControllerInsertAnnouncement(
          saveAnnouncementDto,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * AnnouncementsApi - factory interface
 * @export
 */
export const AnnouncementsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AnnouncementsApiFp(configuration)
  return {
    /**
     *
     * @summary Get all announcements paginated
     * @param {string} language Language of the announcement in ISO 639-1 language code
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    announcementsControllerAnnouncementsGetMany(
      language: string,
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<AnnouncementsResponseDto> {
      return localVarFp
        .announcementsControllerAnnouncementsGetMany(language, page, pageSize, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Delete a specific announcement
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    announcementsControllerDeleteAnnouncement(
      id: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<DeleteResponseDto> {
      return localVarFp
        .announcementsControllerDeleteAnnouncement(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Inserts new vehicle
     * @param {SaveAnnouncementDto} saveAnnouncementDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    announcementsControllerInsertAnnouncement(
      saveAnnouncementDto: SaveAnnouncementDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<AnnouncementDto> {
      return localVarFp
        .announcementsControllerInsertAnnouncement(saveAnnouncementDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * AnnouncementsApi - object-oriented interface
 * @export
 * @class AnnouncementsApi
 * @extends {BaseAPI}
 */
export class AnnouncementsApi extends BaseAPI {
  /**
   *
   * @summary Get all announcements paginated
   * @param {string} language Language of the announcement in ISO 639-1 language code
   * @param {number} [page] Page number
   * @param {number} [pageSize] Items per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AnnouncementsApi
   */
  public announcementsControllerAnnouncementsGetMany(
    language: string,
    page?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return AnnouncementsApiFp(this.configuration)
      .announcementsControllerAnnouncementsGetMany(language, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Delete a specific announcement
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AnnouncementsApi
   */
  public announcementsControllerDeleteAnnouncement(id: number, options?: AxiosRequestConfig) {
    return AnnouncementsApiFp(this.configuration)
      .announcementsControllerDeleteAnnouncement(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Inserts new vehicle
   * @param {SaveAnnouncementDto} saveAnnouncementDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AnnouncementsApi
   */
  public announcementsControllerInsertAnnouncement(
    saveAnnouncementDto: SaveAnnouncementDto,
    options?: AxiosRequestConfig,
  ) {
    return AnnouncementsApiFp(this.configuration)
      .announcementsControllerInsertAnnouncement(saveAnnouncementDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Get information about the status of the mpa-backend.
     * @summary Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerHealth: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/healthcheck`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get information about the status of the parking system.
     * @summary Healthcheck for parking system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerHealthParkingSystem: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/healthcheck/parking-sytem`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
  return {
    /**
     * Get information about the status of the mpa-backend.
     * @summary Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async appControllerHealth(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerHealth(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get information about the status of the parking system.
     * @summary Healthcheck for parking system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async appControllerHealthParkingSystem(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.appControllerHealthParkingSystem(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DefaultApiFp(configuration)
  return {
    /**
     * Get information about the status of the mpa-backend.
     * @summary Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerHealth(options?: AxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.appControllerHealth(options).then((request) => request(axios, basePath))
    },
    /**
     * Get information about the status of the parking system.
     * @summary Healthcheck for parking system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerHealthParkingSystem(options?: AxiosRequestConfig): AxiosPromise<void> {
      return localVarFp
        .appControllerHealthParkingSystem(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   * Get information about the status of the mpa-backend.
   * @summary Healthcheck
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public appControllerHealth(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .appControllerHealth(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get information about the status of the parking system.
   * @summary Healthcheck for parking system
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public appControllerHealthParkingSystem(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .appControllerHealthParkingSystem(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * FeedbackFormsApi - axios parameter creator
 * @export
 */
export const FeedbackFormsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete a specific feedback form
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    feedbackFormsControllerDeleteFeedbackForm: async (
      id: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('feedbackFormsControllerDeleteFeedbackForm', 'id', id)
      const localVarPath = `/feedback-forms/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication azure required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get all feedback forms paginated with filtering options
     * @param {Language} [language] Language code to filter feedback forms by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    feedbackFormsControllerFeedbackFormsGetMany: async (
      language?: Language,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/feedback-forms`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (language !== undefined) {
        localVarQueryParameter['language'] = language
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get a specific feedback form by ID
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    feedbackFormsControllerGetFeedbackForm: async (
      id: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('feedbackFormsControllerGetFeedbackForm', 'id', id)
      const localVarPath = `/feedback-forms/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create a new feedback form
     * @param {SaveFeedbackFormDto} saveFeedbackFormDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    feedbackFormsControllerInsertFeedbackForm: async (
      saveFeedbackFormDto: SaveFeedbackFormDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'saveFeedbackFormDto' is not null or undefined
      assertParamExists(
        'feedbackFormsControllerInsertFeedbackForm',
        'saveFeedbackFormDto',
        saveFeedbackFormDto,
      )
      const localVarPath = `/feedback-forms`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication azure required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        saveFeedbackFormDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update an existing feedback form
     * @param {number} id
     * @param {SaveFeedbackFormDto} saveFeedbackFormDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    feedbackFormsControllerUpdateFeedbackForm: async (
      id: number,
      saveFeedbackFormDto: SaveFeedbackFormDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('feedbackFormsControllerUpdateFeedbackForm', 'id', id)
      // verify required parameter 'saveFeedbackFormDto' is not null or undefined
      assertParamExists(
        'feedbackFormsControllerUpdateFeedbackForm',
        'saveFeedbackFormDto',
        saveFeedbackFormDto,
      )
      const localVarPath = `/feedback-forms/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication azure required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        saveFeedbackFormDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * FeedbackFormsApi - functional programming interface
 * @export
 */
export const FeedbackFormsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FeedbackFormsApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Delete a specific feedback form
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async feedbackFormsControllerDeleteFeedbackForm(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteResponseDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.feedbackFormsControllerDeleteFeedbackForm(id, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all feedback forms paginated with filtering options
     * @param {Language} [language] Language code to filter feedback forms by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async feedbackFormsControllerFeedbackFormsGetMany(
      language?: Language,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeedbackFormsResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.feedbackFormsControllerFeedbackFormsGetMany(
          language,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get a specific feedback form by ID
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async feedbackFormsControllerGetFeedbackForm(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeedbackFormDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.feedbackFormsControllerGetFeedbackForm(id, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Create a new feedback form
     * @param {SaveFeedbackFormDto} saveFeedbackFormDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async feedbackFormsControllerInsertFeedbackForm(
      saveFeedbackFormDto: SaveFeedbackFormDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeedbackFormDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.feedbackFormsControllerInsertFeedbackForm(
          saveFeedbackFormDto,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Update an existing feedback form
     * @param {number} id
     * @param {SaveFeedbackFormDto} saveFeedbackFormDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async feedbackFormsControllerUpdateFeedbackForm(
      id: number,
      saveFeedbackFormDto: SaveFeedbackFormDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeedbackFormDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.feedbackFormsControllerUpdateFeedbackForm(
          id,
          saveFeedbackFormDto,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * FeedbackFormsApi - factory interface
 * @export
 */
export const FeedbackFormsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = FeedbackFormsApiFp(configuration)
  return {
    /**
     *
     * @summary Delete a specific feedback form
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    feedbackFormsControllerDeleteFeedbackForm(
      id: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<DeleteResponseDto> {
      return localVarFp
        .feedbackFormsControllerDeleteFeedbackForm(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get all feedback forms paginated with filtering options
     * @param {Language} [language] Language code to filter feedback forms by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    feedbackFormsControllerFeedbackFormsGetMany(
      language?: Language,
      options?: AxiosRequestConfig,
    ): AxiosPromise<FeedbackFormsResponseDto> {
      return localVarFp
        .feedbackFormsControllerFeedbackFormsGetMany(language, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get a specific feedback form by ID
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    feedbackFormsControllerGetFeedbackForm(
      id: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<FeedbackFormDto> {
      return localVarFp
        .feedbackFormsControllerGetFeedbackForm(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create a new feedback form
     * @param {SaveFeedbackFormDto} saveFeedbackFormDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    feedbackFormsControllerInsertFeedbackForm(
      saveFeedbackFormDto: SaveFeedbackFormDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<FeedbackFormDto> {
      return localVarFp
        .feedbackFormsControllerInsertFeedbackForm(saveFeedbackFormDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update an existing feedback form
     * @param {number} id
     * @param {SaveFeedbackFormDto} saveFeedbackFormDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    feedbackFormsControllerUpdateFeedbackForm(
      id: number,
      saveFeedbackFormDto: SaveFeedbackFormDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<FeedbackFormDto> {
      return localVarFp
        .feedbackFormsControllerUpdateFeedbackForm(id, saveFeedbackFormDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * FeedbackFormsApi - object-oriented interface
 * @export
 * @class FeedbackFormsApi
 * @extends {BaseAPI}
 */
export class FeedbackFormsApi extends BaseAPI {
  /**
   *
   * @summary Delete a specific feedback form
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FeedbackFormsApi
   */
  public feedbackFormsControllerDeleteFeedbackForm(id: number, options?: AxiosRequestConfig) {
    return FeedbackFormsApiFp(this.configuration)
      .feedbackFormsControllerDeleteFeedbackForm(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all feedback forms paginated with filtering options
   * @param {Language} [language] Language code to filter feedback forms by
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FeedbackFormsApi
   */
  public feedbackFormsControllerFeedbackFormsGetMany(
    language?: Language,
    options?: AxiosRequestConfig,
  ) {
    return FeedbackFormsApiFp(this.configuration)
      .feedbackFormsControllerFeedbackFormsGetMany(language, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get a specific feedback form by ID
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FeedbackFormsApi
   */
  public feedbackFormsControllerGetFeedbackForm(id: number, options?: AxiosRequestConfig) {
    return FeedbackFormsApiFp(this.configuration)
      .feedbackFormsControllerGetFeedbackForm(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create a new feedback form
   * @param {SaveFeedbackFormDto} saveFeedbackFormDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FeedbackFormsApi
   */
  public feedbackFormsControllerInsertFeedbackForm(
    saveFeedbackFormDto: SaveFeedbackFormDto,
    options?: AxiosRequestConfig,
  ) {
    return FeedbackFormsApiFp(this.configuration)
      .feedbackFormsControllerInsertFeedbackForm(saveFeedbackFormDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update an existing feedback form
   * @param {number} id
   * @param {SaveFeedbackFormDto} saveFeedbackFormDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FeedbackFormsApi
   */
  public feedbackFormsControllerUpdateFeedbackForm(
    id: number,
    saveFeedbackFormDto: SaveFeedbackFormDto,
    options?: AxiosRequestConfig,
  ) {
    return FeedbackFormsApiFp(this.configuration)
      .feedbackFormsControllerUpdateFeedbackForm(id, saveFeedbackFormDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * MobileDevicesApi - axios parameter creator
 * @export
 */
export const MobileDevicesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete a specific mobile device
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mobileDevicesControllerDeleteMobileDevice: async (
      id: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('mobileDevicesControllerDeleteMobileDevice', 'id', id)
      const localVarPath = `/mobile-devices/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Delete a specific mobile device by token
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mobileDevicesControllerDeleteMobileDeviceByToken: async (
      token: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'token' is not null or undefined
      assertParamExists('mobileDevicesControllerDeleteMobileDeviceByToken', 'token', token)
      const localVarPath = `/mobile-devices/token/{token}`.replace(
        `{${'token'}}`,
        encodeURIComponent(String(token)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get all mobile devices associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mobileDevicesControllerDevicesGetMany: async (
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/mobile-devices`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Inserts new mobile device if it does not exist. Returns the newly created or the existing one.
     * @param {SaveMobileDeviceDto} saveMobileDeviceDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mobileDevicesControllerInsertMobileDevice: async (
      saveMobileDeviceDto: SaveMobileDeviceDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'saveMobileDeviceDto' is not null or undefined
      assertParamExists(
        'mobileDevicesControllerInsertMobileDevice',
        'saveMobileDeviceDto',
        saveMobileDeviceDto,
      )
      const localVarPath = `/mobile-devices`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        saveMobileDeviceDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * MobileDevicesApi - functional programming interface
 * @export
 */
export const MobileDevicesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = MobileDevicesApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Delete a specific mobile device
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mobileDevicesControllerDeleteMobileDevice(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteResponseDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.mobileDevicesControllerDeleteMobileDevice(id, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Delete a specific mobile device by token
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mobileDevicesControllerDeleteMobileDeviceByToken(
      token: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteResponseDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.mobileDevicesControllerDeleteMobileDeviceByToken(
          token,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all mobile devices associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mobileDevicesControllerDevicesGetMany(
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MobileDeviceResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.mobileDevicesControllerDevicesGetMany(
          page,
          pageSize,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Inserts new mobile device if it does not exist. Returns the newly created or the existing one.
     * @param {SaveMobileDeviceDto} saveMobileDeviceDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mobileDevicesControllerInsertMobileDevice(
      saveMobileDeviceDto: SaveMobileDeviceDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MobileDeviceDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.mobileDevicesControllerInsertMobileDevice(
          saveMobileDeviceDto,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * MobileDevicesApi - factory interface
 * @export
 */
export const MobileDevicesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = MobileDevicesApiFp(configuration)
  return {
    /**
     *
     * @summary Delete a specific mobile device
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mobileDevicesControllerDeleteMobileDevice(
      id: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<DeleteResponseDto> {
      return localVarFp
        .mobileDevicesControllerDeleteMobileDevice(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Delete a specific mobile device by token
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mobileDevicesControllerDeleteMobileDeviceByToken(
      token: string,
      options?: AxiosRequestConfig,
    ): AxiosPromise<DeleteResponseDto> {
      return localVarFp
        .mobileDevicesControllerDeleteMobileDeviceByToken(token, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get all mobile devices associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mobileDevicesControllerDevicesGetMany(
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<MobileDeviceResponseDto> {
      return localVarFp
        .mobileDevicesControllerDevicesGetMany(page, pageSize, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Inserts new mobile device if it does not exist. Returns the newly created or the existing one.
     * @param {SaveMobileDeviceDto} saveMobileDeviceDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mobileDevicesControllerInsertMobileDevice(
      saveMobileDeviceDto: SaveMobileDeviceDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<MobileDeviceDto> {
      return localVarFp
        .mobileDevicesControllerInsertMobileDevice(saveMobileDeviceDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * MobileDevicesApi - object-oriented interface
 * @export
 * @class MobileDevicesApi
 * @extends {BaseAPI}
 */
export class MobileDevicesApi extends BaseAPI {
  /**
   *
   * @summary Delete a specific mobile device
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MobileDevicesApi
   */
  public mobileDevicesControllerDeleteMobileDevice(id: number, options?: AxiosRequestConfig) {
    return MobileDevicesApiFp(this.configuration)
      .mobileDevicesControllerDeleteMobileDevice(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Delete a specific mobile device by token
   * @param {string} token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MobileDevicesApi
   */
  public mobileDevicesControllerDeleteMobileDeviceByToken(
    token: string,
    options?: AxiosRequestConfig,
  ) {
    return MobileDevicesApiFp(this.configuration)
      .mobileDevicesControllerDeleteMobileDeviceByToken(token, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all mobile devices associated with the user
   * @param {number} [page] Page number
   * @param {number} [pageSize] Items per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MobileDevicesApi
   */
  public mobileDevicesControllerDevicesGetMany(
    page?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return MobileDevicesApiFp(this.configuration)
      .mobileDevicesControllerDevicesGetMany(page, pageSize, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Inserts new mobile device if it does not exist. Returns the newly created or the existing one.
   * @param {SaveMobileDeviceDto} saveMobileDeviceDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MobileDevicesApi
   */
  public mobileDevicesControllerInsertMobileDevice(
    saveMobileDeviceDto: SaveMobileDeviceDto,
    options?: AxiosRequestConfig,
  ) {
    return MobileDevicesApiFp(this.configuration)
      .mobileDevicesControllerInsertMobileDevice(saveMobileDeviceDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ParkingCardsApi - axios parameter creator
 * @export
 */
export const ParkingCardsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get all active visitor cards associated with the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    parkingCardsControllerGetActiveVisitorCards: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/parking-cards/visitor-cards`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get all parking cards associated with the user
     * @param {string} email Email
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {string} [validFromFrom] Lower bound for valid from
     * @param {string} [validFromTo] Upper bound for valid from
     * @param {string} [validToFrom] Lower bound for valid to
     * @param {string} [validToTo] Upper bound for valid to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    parkingCardsControllerGetParkingCards: async (
      email: string,
      page?: number,
      pageSize?: number,
      validFromFrom?: string,
      validFromTo?: string,
      validToFrom?: string,
      validToTo?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'email' is not null or undefined
      assertParamExists('parkingCardsControllerGetParkingCards', 'email', email)
      const localVarPath = `/parking-cards`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (email !== undefined) {
        localVarQueryParameter['email'] = email
      }

      if (validFromFrom !== undefined) {
        localVarQueryParameter['validFromFrom'] = validFromFrom
      }

      if (validFromTo !== undefined) {
        localVarQueryParameter['validFromTo'] = validFromTo
      }

      if (validToFrom !== undefined) {
        localVarQueryParameter['validToFrom'] = validToFrom
      }

      if (validToTo !== undefined) {
        localVarQueryParameter['validToTo'] = validToTo
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ParkingCardsApi - functional programming interface
 * @export
 */
export const ParkingCardsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ParkingCardsApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Get all active visitor cards associated with the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async parkingCardsControllerGetActiveVisitorCards(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ParkingCardDto>>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.parkingCardsControllerGetActiveVisitorCards(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all parking cards associated with the user
     * @param {string} email Email
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {string} [validFromFrom] Lower bound for valid from
     * @param {string} [validFromTo] Upper bound for valid from
     * @param {string} [validToFrom] Lower bound for valid to
     * @param {string} [validToTo] Upper bound for valid to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async parkingCardsControllerGetParkingCards(
      email: string,
      page?: number,
      pageSize?: number,
      validFromFrom?: string,
      validFromTo?: string,
      validToFrom?: string,
      validToTo?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParkingCardsResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.parkingCardsControllerGetParkingCards(
          email,
          page,
          pageSize,
          validFromFrom,
          validFromTo,
          validToFrom,
          validToTo,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * ParkingCardsApi - factory interface
 * @export
 */
export const ParkingCardsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ParkingCardsApiFp(configuration)
  return {
    /**
     *
     * @summary Get all active visitor cards associated with the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    parkingCardsControllerGetActiveVisitorCards(
      options?: AxiosRequestConfig,
    ): AxiosPromise<Array<ParkingCardDto>> {
      return localVarFp
        .parkingCardsControllerGetActiveVisitorCards(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get all parking cards associated with the user
     * @param {string} email Email
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {string} [validFromFrom] Lower bound for valid from
     * @param {string} [validFromTo] Upper bound for valid from
     * @param {string} [validToFrom] Lower bound for valid to
     * @param {string} [validToTo] Upper bound for valid to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    parkingCardsControllerGetParkingCards(
      email: string,
      page?: number,
      pageSize?: number,
      validFromFrom?: string,
      validFromTo?: string,
      validToFrom?: string,
      validToTo?: string,
      options?: AxiosRequestConfig,
    ): AxiosPromise<ParkingCardsResponseDto> {
      return localVarFp
        .parkingCardsControllerGetParkingCards(
          email,
          page,
          pageSize,
          validFromFrom,
          validFromTo,
          validToFrom,
          validToTo,
          options,
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ParkingCardsApi - object-oriented interface
 * @export
 * @class ParkingCardsApi
 * @extends {BaseAPI}
 */
export class ParkingCardsApi extends BaseAPI {
  /**
   *
   * @summary Get all active visitor cards associated with the user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ParkingCardsApi
   */
  public parkingCardsControllerGetActiveVisitorCards(options?: AxiosRequestConfig) {
    return ParkingCardsApiFp(this.configuration)
      .parkingCardsControllerGetActiveVisitorCards(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all parking cards associated with the user
   * @param {string} email Email
   * @param {number} [page] Page number
   * @param {number} [pageSize] Items per page
   * @param {string} [validFromFrom] Lower bound for valid from
   * @param {string} [validFromTo] Upper bound for valid from
   * @param {string} [validToFrom] Lower bound for valid to
   * @param {string} [validToTo] Upper bound for valid to
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ParkingCardsApi
   */
  public parkingCardsControllerGetParkingCards(
    email: string,
    page?: number,
    pageSize?: number,
    validFromFrom?: string,
    validFromTo?: string,
    validToFrom?: string,
    validToTo?: string,
    options?: AxiosRequestConfig,
  ) {
    return ParkingCardsApiFp(this.configuration)
      .parkingCardsControllerGetParkingCards(
        email,
        page,
        pageSize,
        validFromFrom,
        validFromTo,
        validToFrom,
        validToTo,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * PushNotificationAnnouncementsApi - axios parameter creator
 * @export
 */
export const PushNotificationAnnouncementsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Creates a new push notification announcement
     * @summary Create a new push notification announcement
     * @param {CreatePushNotificationAnnouncementDto} createPushNotificationAnnouncementDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pushNotificationAnnouncementsControllerCreate: async (
      createPushNotificationAnnouncementDto: CreatePushNotificationAnnouncementDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createPushNotificationAnnouncementDto' is not null or undefined
      assertParamExists(
        'pushNotificationAnnouncementsControllerCreate',
        'createPushNotificationAnnouncementDto',
        createPushNotificationAnnouncementDto,
      )
      const localVarPath = `/push-notification-announcements`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication azure required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createPushNotificationAnnouncementDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns a paginated list of push notification announcements
     * @summary Get all push notification announcements
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pushNotificationAnnouncementsControllerGetMany: async (
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/push-notification-announcements`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication azure required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns a single push notification announcement
     * @summary Get a push notification announcement by ID
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pushNotificationAnnouncementsControllerGetOne: async (
      id: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('pushNotificationAnnouncementsControllerGetOne', 'id', id)
      const localVarPath = `/push-notification-announcements/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication azure required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Deletes a push notification announcement by ID
     * @summary Delete a push notification announcement
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pushNotificationAnnouncementsControllerRemove: async (
      id: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('pushNotificationAnnouncementsControllerRemove', 'id', id)
      const localVarPath = `/push-notification-announcements/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication azure required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Queues a push notification announcement for sending to all devices
     * @summary Send a push notification announcement
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pushNotificationAnnouncementsControllerSend: async (
      id: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('pushNotificationAnnouncementsControllerSend', 'id', id)
      const localVarPath = `/push-notification-announcements/{id}/send`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication azure required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Updates an existing push notification announcement
     * @summary Update a push notification announcement
     * @param {number} id
     * @param {UpdatePushNotificationAnnouncementDto} updatePushNotificationAnnouncementDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pushNotificationAnnouncementsControllerUpdate: async (
      id: number,
      updatePushNotificationAnnouncementDto: UpdatePushNotificationAnnouncementDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('pushNotificationAnnouncementsControllerUpdate', 'id', id)
      // verify required parameter 'updatePushNotificationAnnouncementDto' is not null or undefined
      assertParamExists(
        'pushNotificationAnnouncementsControllerUpdate',
        'updatePushNotificationAnnouncementDto',
        updatePushNotificationAnnouncementDto,
      )
      const localVarPath = `/push-notification-announcements/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication azure required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updatePushNotificationAnnouncementDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * PushNotificationAnnouncementsApi - functional programming interface
 * @export
 */
export const PushNotificationAnnouncementsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PushNotificationAnnouncementsApiAxiosParamCreator(configuration)
  return {
    /**
     * Creates a new push notification announcement
     * @summary Create a new push notification announcement
     * @param {CreatePushNotificationAnnouncementDto} createPushNotificationAnnouncementDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pushNotificationAnnouncementsControllerCreate(
      createPushNotificationAnnouncementDto: CreatePushNotificationAnnouncementDto,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PushNotificationAnnouncementDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.pushNotificationAnnouncementsControllerCreate(
          createPushNotificationAnnouncementDto,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Returns a paginated list of push notification announcements
     * @summary Get all push notification announcements
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pushNotificationAnnouncementsControllerGetMany(
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PushNotificationAnnouncementsResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.pushNotificationAnnouncementsControllerGetMany(
          page,
          pageSize,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Returns a single push notification announcement
     * @summary Get a push notification announcement by ID
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pushNotificationAnnouncementsControllerGetOne(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PushNotificationAnnouncementDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.pushNotificationAnnouncementsControllerGetOne(id, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Deletes a push notification announcement by ID
     * @summary Delete a push notification announcement
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pushNotificationAnnouncementsControllerRemove(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteResponseDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.pushNotificationAnnouncementsControllerRemove(id, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Queues a push notification announcement for sending to all devices
     * @summary Send a push notification announcement
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pushNotificationAnnouncementsControllerSend(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.pushNotificationAnnouncementsControllerSend(id, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Updates an existing push notification announcement
     * @summary Update a push notification announcement
     * @param {number} id
     * @param {UpdatePushNotificationAnnouncementDto} updatePushNotificationAnnouncementDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pushNotificationAnnouncementsControllerUpdate(
      id: number,
      updatePushNotificationAnnouncementDto: UpdatePushNotificationAnnouncementDto,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PushNotificationAnnouncementDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.pushNotificationAnnouncementsControllerUpdate(
          id,
          updatePushNotificationAnnouncementDto,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * PushNotificationAnnouncementsApi - factory interface
 * @export
 */
export const PushNotificationAnnouncementsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PushNotificationAnnouncementsApiFp(configuration)
  return {
    /**
     * Creates a new push notification announcement
     * @summary Create a new push notification announcement
     * @param {CreatePushNotificationAnnouncementDto} createPushNotificationAnnouncementDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pushNotificationAnnouncementsControllerCreate(
      createPushNotificationAnnouncementDto: CreatePushNotificationAnnouncementDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<PushNotificationAnnouncementDto> {
      return localVarFp
        .pushNotificationAnnouncementsControllerCreate(
          createPushNotificationAnnouncementDto,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns a paginated list of push notification announcements
     * @summary Get all push notification announcements
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pushNotificationAnnouncementsControllerGetMany(
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<PushNotificationAnnouncementsResponseDto> {
      return localVarFp
        .pushNotificationAnnouncementsControllerGetMany(page, pageSize, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns a single push notification announcement
     * @summary Get a push notification announcement by ID
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pushNotificationAnnouncementsControllerGetOne(
      id: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<PushNotificationAnnouncementDto> {
      return localVarFp
        .pushNotificationAnnouncementsControllerGetOne(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Deletes a push notification announcement by ID
     * @summary Delete a push notification announcement
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pushNotificationAnnouncementsControllerRemove(
      id: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<DeleteResponseDto> {
      return localVarFp
        .pushNotificationAnnouncementsControllerRemove(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Queues a push notification announcement for sending to all devices
     * @summary Send a push notification announcement
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pushNotificationAnnouncementsControllerSend(
      id: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .pushNotificationAnnouncementsControllerSend(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Updates an existing push notification announcement
     * @summary Update a push notification announcement
     * @param {number} id
     * @param {UpdatePushNotificationAnnouncementDto} updatePushNotificationAnnouncementDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pushNotificationAnnouncementsControllerUpdate(
      id: number,
      updatePushNotificationAnnouncementDto: UpdatePushNotificationAnnouncementDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<PushNotificationAnnouncementDto> {
      return localVarFp
        .pushNotificationAnnouncementsControllerUpdate(
          id,
          updatePushNotificationAnnouncementDto,
          options,
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * PushNotificationAnnouncementsApi - object-oriented interface
 * @export
 * @class PushNotificationAnnouncementsApi
 * @extends {BaseAPI}
 */
export class PushNotificationAnnouncementsApi extends BaseAPI {
  /**
   * Creates a new push notification announcement
   * @summary Create a new push notification announcement
   * @param {CreatePushNotificationAnnouncementDto} createPushNotificationAnnouncementDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PushNotificationAnnouncementsApi
   */
  public pushNotificationAnnouncementsControllerCreate(
    createPushNotificationAnnouncementDto: CreatePushNotificationAnnouncementDto,
    options?: AxiosRequestConfig,
  ) {
    return PushNotificationAnnouncementsApiFp(this.configuration)
      .pushNotificationAnnouncementsControllerCreate(createPushNotificationAnnouncementDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns a paginated list of push notification announcements
   * @summary Get all push notification announcements
   * @param {number} [page] Page number
   * @param {number} [pageSize] Items per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PushNotificationAnnouncementsApi
   */
  public pushNotificationAnnouncementsControllerGetMany(
    page?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return PushNotificationAnnouncementsApiFp(this.configuration)
      .pushNotificationAnnouncementsControllerGetMany(page, pageSize, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns a single push notification announcement
   * @summary Get a push notification announcement by ID
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PushNotificationAnnouncementsApi
   */
  public pushNotificationAnnouncementsControllerGetOne(id: number, options?: AxiosRequestConfig) {
    return PushNotificationAnnouncementsApiFp(this.configuration)
      .pushNotificationAnnouncementsControllerGetOne(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Deletes a push notification announcement by ID
   * @summary Delete a push notification announcement
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PushNotificationAnnouncementsApi
   */
  public pushNotificationAnnouncementsControllerRemove(id: number, options?: AxiosRequestConfig) {
    return PushNotificationAnnouncementsApiFp(this.configuration)
      .pushNotificationAnnouncementsControllerRemove(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Queues a push notification announcement for sending to all devices
   * @summary Send a push notification announcement
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PushNotificationAnnouncementsApi
   */
  public pushNotificationAnnouncementsControllerSend(id: number, options?: AxiosRequestConfig) {
    return PushNotificationAnnouncementsApiFp(this.configuration)
      .pushNotificationAnnouncementsControllerSend(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Updates an existing push notification announcement
   * @summary Update a push notification announcement
   * @param {number} id
   * @param {UpdatePushNotificationAnnouncementDto} updatePushNotificationAnnouncementDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PushNotificationAnnouncementsApi
   */
  public pushNotificationAnnouncementsControllerUpdate(
    id: number,
    updatePushNotificationAnnouncementDto: UpdatePushNotificationAnnouncementDto,
    options?: AxiosRequestConfig,
  ) {
    return PushNotificationAnnouncementsApiFp(this.configuration)
      .pushNotificationAnnouncementsControllerUpdate(
        id,
        updatePushNotificationAnnouncementDto,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ResourcesApi - axios parameter creator
 * @export
 */
export const ResourcesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get all resources for a specific language
     * @param {Language} language Language code to filter resources by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resourcesControllerGetResources: async (
      language: Language,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'language' is not null or undefined
      assertParamExists('resourcesControllerGetResources', 'language', language)
      const localVarPath = `/resources`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (language !== undefined) {
        localVarQueryParameter['language'] = language
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create or update a resource
     * @param {SaveResourceDto} saveResourceDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resourcesControllerUpsertResource: async (
      saveResourceDto: SaveResourceDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'saveResourceDto' is not null or undefined
      assertParamExists('resourcesControllerUpsertResource', 'saveResourceDto', saveResourceDto)
      const localVarPath = `/resources`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication azure required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        saveResourceDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ResourcesApi - functional programming interface
 * @export
 */
export const ResourcesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ResourcesApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Get all resources for a specific language
     * @param {Language} language Language code to filter resources by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async resourcesControllerGetResources(
      language: Language,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourcesResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.resourcesControllerGetResources(
        language,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Create or update a resource
     * @param {SaveResourceDto} saveResourceDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async resourcesControllerUpsertResource(
      saveResourceDto: SaveResourceDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.resourcesControllerUpsertResource(
        saveResourceDto,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * ResourcesApi - factory interface
 * @export
 */
export const ResourcesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ResourcesApiFp(configuration)
  return {
    /**
     *
     * @summary Get all resources for a specific language
     * @param {Language} language Language code to filter resources by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resourcesControllerGetResources(
      language: Language,
      options?: AxiosRequestConfig,
    ): AxiosPromise<ResourcesResponseDto> {
      return localVarFp
        .resourcesControllerGetResources(language, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create or update a resource
     * @param {SaveResourceDto} saveResourceDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resourcesControllerUpsertResource(
      saveResourceDto: SaveResourceDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<ResourceDto> {
      return localVarFp
        .resourcesControllerUpsertResource(saveResourceDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ResourcesApi - object-oriented interface
 * @export
 * @class ResourcesApi
 * @extends {BaseAPI}
 */
export class ResourcesApi extends BaseAPI {
  /**
   *
   * @summary Get all resources for a specific language
   * @param {Language} language Language code to filter resources by
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public resourcesControllerGetResources(language: Language, options?: AxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .resourcesControllerGetResources(language, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create or update a resource
   * @param {SaveResourceDto} saveResourceDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public resourcesControllerUpsertResource(
    saveResourceDto: SaveResourceDto,
    options?: AxiosRequestConfig,
  ) {
    return ResourcesApiFp(this.configuration)
      .resourcesControllerUpsertResource(saveResourceDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * SystemApi - axios parameter creator
 * @export
 */
export const SystemApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get mobile app version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    systemControllerGetMobileAppVersion: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/system/version`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Send feedback
     * @param {string} feedbackType Type of the feedback
     * @param {string} email Email of the feedback reporter
     * @param {string} message Message of the feedback
     * @param {string | null} [type] DEPRECATED: Use the feedbackType property instead. Type of the feedback
     * @param {string} [appVersion] Version of the aplication
     * @param {Array<File>} [files]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    systemControllerSendFeedback: async (
      feedbackType: string,
      email: string,
      message: string,
      type?: string | null,
      appVersion?: string,
      files?: Array<File>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'feedbackType' is not null or undefined
      assertParamExists('systemControllerSendFeedback', 'feedbackType', feedbackType)
      // verify required parameter 'email' is not null or undefined
      assertParamExists('systemControllerSendFeedback', 'email', email)
      // verify required parameter 'message' is not null or undefined
      assertParamExists('systemControllerSendFeedback', 'message', message)
      const localVarPath = `/system/feedback`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)()

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (type !== undefined) {
        localVarFormParams.append('type', type as any)
      }

      if (feedbackType !== undefined) {
        localVarFormParams.append('feedbackType', feedbackType as any)
      }

      if (email !== undefined) {
        localVarFormParams.append('email', email as any)
      }

      if (message !== undefined) {
        localVarFormParams.append('message', message as any)
      }

      if (appVersion !== undefined) {
        localVarFormParams.append('appVersion', appVersion as any)
      }
      if (files) {
        files.forEach((element) => {
          localVarFormParams.append('files', element as any)
        })
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update mobile app version
     * @param {MobileAppVersionUpdateDto} mobileAppVersionUpdateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    systemControllerUpdateMobileAppVersion: async (
      mobileAppVersionUpdateDto: MobileAppVersionUpdateDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'mobileAppVersionUpdateDto' is not null or undefined
      assertParamExists(
        'systemControllerUpdateMobileAppVersion',
        'mobileAppVersionUpdateDto',
        mobileAppVersionUpdateDto,
      )
      const localVarPath = `/system/version`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication azure required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        mobileAppVersionUpdateDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SystemApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Get mobile app version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async systemControllerGetMobileAppVersion(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.systemControllerGetMobileAppVersion(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Send feedback
     * @param {string} feedbackType Type of the feedback
     * @param {string} email Email of the feedback reporter
     * @param {string} message Message of the feedback
     * @param {string | null} [type] DEPRECATED: Use the feedbackType property instead. Type of the feedback
     * @param {string} [appVersion] Version of the aplication
     * @param {Array<File>} [files]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async systemControllerSendFeedback(
      feedbackType: string,
      email: string,
      message: string,
      type?: string | null,
      appVersion?: string,
      files?: Array<File>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.systemControllerSendFeedback(
        feedbackType,
        email,
        message,
        type,
        appVersion,
        files,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Update mobile app version
     * @param {MobileAppVersionUpdateDto} mobileAppVersionUpdateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async systemControllerUpdateMobileAppVersion(
      mobileAppVersionUpdateDto: MobileAppVersionUpdateDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.systemControllerUpdateMobileAppVersion(
          mobileAppVersionUpdateDto,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SystemApiFp(configuration)
  return {
    /**
     *
     * @summary Get mobile app version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    systemControllerGetMobileAppVersion(options?: AxiosRequestConfig): AxiosPromise<string> {
      return localVarFp
        .systemControllerGetMobileAppVersion(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Send feedback
     * @param {string} feedbackType Type of the feedback
     * @param {string} email Email of the feedback reporter
     * @param {string} message Message of the feedback
     * @param {string | null} [type] DEPRECATED: Use the feedbackType property instead. Type of the feedback
     * @param {string} [appVersion] Version of the aplication
     * @param {Array<File>} [files]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    systemControllerSendFeedback(
      feedbackType: string,
      email: string,
      message: string,
      type?: string | null,
      appVersion?: string,
      files?: Array<File>,
      options?: AxiosRequestConfig,
    ): AxiosPromise<boolean> {
      return localVarFp
        .systemControllerSendFeedback(
          feedbackType,
          email,
          message,
          type,
          appVersion,
          files,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update mobile app version
     * @param {MobileAppVersionUpdateDto} mobileAppVersionUpdateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    systemControllerUpdateMobileAppVersion(
      mobileAppVersionUpdateDto: MobileAppVersionUpdateDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<string> {
      return localVarFp
        .systemControllerUpdateMobileAppVersion(mobileAppVersionUpdateDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
  /**
   *
   * @summary Get mobile app version
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public systemControllerGetMobileAppVersion(options?: AxiosRequestConfig) {
    return SystemApiFp(this.configuration)
      .systemControllerGetMobileAppVersion(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Send feedback
   * @param {string} feedbackType Type of the feedback
   * @param {string} email Email of the feedback reporter
   * @param {string} message Message of the feedback
   * @param {string | null} [type] DEPRECATED: Use the feedbackType property instead. Type of the feedback
   * @param {string} [appVersion] Version of the aplication
   * @param {Array<File>} [files]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public systemControllerSendFeedback(
    feedbackType: string,
    email: string,
    message: string,
    type?: string | null,
    appVersion?: string,
    files?: Array<File>,
    options?: AxiosRequestConfig,
  ) {
    return SystemApiFp(this.configuration)
      .systemControllerSendFeedback(feedbackType, email, message, type, appVersion, files, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update mobile app version
   * @param {MobileAppVersionUpdateDto} mobileAppVersionUpdateDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public systemControllerUpdateMobileAppVersion(
    mobileAppVersionUpdateDto: MobileAppVersionUpdateDto,
    options?: AxiosRequestConfig,
  ) {
    return SystemApiFp(this.configuration)
      .systemControllerUpdateMobileAppVersion(mobileAppVersionUpdateDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * TicketsApi - axios parameter creator
 * @export
 */
export const TicketsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get URL to ticket receipt
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerGetReceipt: async (
      id: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('ticketsControllerGetReceipt', 'id', id)
      const localVarPath = `/tickets/receipt/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get price of the ticket after a potenial ticket shortening
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerGetShortenTicketPrice: async (
      id: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('ticketsControllerGetShortenTicketPrice', 'id', id)
      const localVarPath = `/tickets/shorten/{id}/price`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get information about the status of the current saved payment method availability
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerGetStoredPaymentMethodAvailability: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/tickets/payment/stored-payment-method-availability`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get ticket\'s last payment status
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerGetTicketLastPaymentStatus: async (
      id: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('ticketsControllerGetTicketLastPaymentStatus', 'id', id)
      const localVarPath = `/tickets/payment-status/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get ticket price
     * @param {GetTicketPriceRequestDto} getTicketPriceRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerGetTicketPrice: async (
      getTicketPriceRequestDto: GetTicketPriceRequestDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getTicketPriceRequestDto' is not null or undefined
      assertParamExists(
        'ticketsControllerGetTicketPrice',
        'getTicketPriceRequestDto',
        getTicketPriceRequestDto,
      )
      const localVarPath = `/tickets/price`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        getTicketPriceRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get ticket prolongation price
     * @param {GetTicketProlongationPriceRequestDto} getTicketProlongationPriceRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerGetTicketProlongationPrice: async (
      getTicketProlongationPriceRequestDto: GetTicketProlongationPriceRequestDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getTicketProlongationPriceRequestDto' is not null or undefined
      assertParamExists(
        'ticketsControllerGetTicketProlongationPrice',
        'getTicketProlongationPriceRequestDto',
        getTicketProlongationPriceRequestDto,
      )
      const localVarPath = `/tickets/prolongation/price`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        getTicketProlongationPriceRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Initiate ticket payment
     * @param {InitiatePaymentRequestDto} initiatePaymentRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerInitiateTicketPayment: async (
      initiatePaymentRequestDto: InitiatePaymentRequestDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'initiatePaymentRequestDto' is not null or undefined
      assertParamExists(
        'ticketsControllerInitiateTicketPayment',
        'initiatePaymentRequestDto',
        initiatePaymentRequestDto,
      )
      const localVarPath = `/tickets/payment`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        initiatePaymentRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Initiate prolongation ticket payment
     * @param {InitiateProlongationRequestDto} initiateProlongationRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerInitiateTicketProlongationPayment: async (
      initiateProlongationRequestDto: InitiateProlongationRequestDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'initiateProlongationRequestDto' is not null or undefined
      assertParamExists(
        'ticketsControllerInitiateTicketProlongationPayment',
        'initiateProlongationRequestDto',
        initiateProlongationRequestDto,
      )
      const localVarPath = `/tickets/prolongation/payment`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        initiateProlongationRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Process ticket payment. This endpoint is called by the payment gate.
     * @param {string} oPERATION Operation text coming from the paygate return url query param
     * @param {string} oRDERNUMBER Ordernumber text coming from the paygate return url query param (13 characters long number)
     * @param {string} pRCODE Prcode text coming from the paygate return url query param
     * @param {string} sRCODE Srcode text coming from the paygate return url query param
     * @param {string} dIGEST Digest text coming from the paygate return url query param
     * @param {string} dIGEST1 Digest1 text coming from the paygate return url query param
     * @param {string} [rESULTTEXT] Result text coming from the paygate return url query param
     * @param {string} [mD] Custom data
     * @param {string} [tOKENREGSTATUS] State of token registration
     * @param {string} [tOKEN] Unique identifier of the card
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerProcessTicketPayment: async (
      oPERATION: string,
      oRDERNUMBER: string,
      pRCODE: string,
      sRCODE: string,
      dIGEST: string,
      dIGEST1: string,
      rESULTTEXT?: string,
      mD?: string,
      tOKENREGSTATUS?: string,
      tOKEN?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'oPERATION' is not null or undefined
      assertParamExists('ticketsControllerProcessTicketPayment', 'oPERATION', oPERATION)
      // verify required parameter 'oRDERNUMBER' is not null or undefined
      assertParamExists('ticketsControllerProcessTicketPayment', 'oRDERNUMBER', oRDERNUMBER)
      // verify required parameter 'pRCODE' is not null or undefined
      assertParamExists('ticketsControllerProcessTicketPayment', 'pRCODE', pRCODE)
      // verify required parameter 'sRCODE' is not null or undefined
      assertParamExists('ticketsControllerProcessTicketPayment', 'sRCODE', sRCODE)
      // verify required parameter 'dIGEST' is not null or undefined
      assertParamExists('ticketsControllerProcessTicketPayment', 'dIGEST', dIGEST)
      // verify required parameter 'dIGEST1' is not null or undefined
      assertParamExists('ticketsControllerProcessTicketPayment', 'dIGEST1', dIGEST1)
      const localVarPath = `/tickets/payment/process`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (oPERATION !== undefined) {
        localVarQueryParameter['OPERATION'] = oPERATION
      }

      if (oRDERNUMBER !== undefined) {
        localVarQueryParameter['ORDERNUMBER'] = oRDERNUMBER
      }

      if (pRCODE !== undefined) {
        localVarQueryParameter['PRCODE'] = pRCODE
      }

      if (sRCODE !== undefined) {
        localVarQueryParameter['SRCODE'] = sRCODE
      }

      if (dIGEST !== undefined) {
        localVarQueryParameter['DIGEST'] = dIGEST
      }

      if (dIGEST1 !== undefined) {
        localVarQueryParameter['DIGEST1'] = dIGEST1
      }

      if (rESULTTEXT !== undefined) {
        localVarQueryParameter['RESULTTEXT'] = rESULTTEXT
      }

      if (mD !== undefined) {
        localVarQueryParameter['MD'] = mD
      }

      if (tOKENREGSTATUS !== undefined) {
        localVarQueryParameter['TOKENREGSTATUS'] = tOKENREGSTATUS
      }

      if (tOKEN !== undefined) {
        localVarQueryParameter['TOKEN'] = tOKEN
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Process ticket prolongation payment. This endpoint is called by the payment gate.
     * @param {string} oPERATION Operation text coming from the paygate return url query param
     * @param {string} oRDERNUMBER Ordernumber text coming from the paygate return url query param (13 characters long number)
     * @param {string} pRCODE Prcode text coming from the paygate return url query param
     * @param {string} sRCODE Srcode text coming from the paygate return url query param
     * @param {string} dIGEST Digest text coming from the paygate return url query param
     * @param {string} dIGEST1 Digest1 text coming from the paygate return url query param
     * @param {string} [rESULTTEXT] Result text coming from the paygate return url query param
     * @param {string} [mD] Custom data
     * @param {string} [tOKENREGSTATUS] State of token registration
     * @param {string} [tOKEN] Unique identifier of the card
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerProcessTicketProlongationPayment: async (
      oPERATION: string,
      oRDERNUMBER: string,
      pRCODE: string,
      sRCODE: string,
      dIGEST: string,
      dIGEST1: string,
      rESULTTEXT?: string,
      mD?: string,
      tOKENREGSTATUS?: string,
      tOKEN?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'oPERATION' is not null or undefined
      assertParamExists('ticketsControllerProcessTicketProlongationPayment', 'oPERATION', oPERATION)
      // verify required parameter 'oRDERNUMBER' is not null or undefined
      assertParamExists(
        'ticketsControllerProcessTicketProlongationPayment',
        'oRDERNUMBER',
        oRDERNUMBER,
      )
      // verify required parameter 'pRCODE' is not null or undefined
      assertParamExists('ticketsControllerProcessTicketProlongationPayment', 'pRCODE', pRCODE)
      // verify required parameter 'sRCODE' is not null or undefined
      assertParamExists('ticketsControllerProcessTicketProlongationPayment', 'sRCODE', sRCODE)
      // verify required parameter 'dIGEST' is not null or undefined
      assertParamExists('ticketsControllerProcessTicketProlongationPayment', 'dIGEST', dIGEST)
      // verify required parameter 'dIGEST1' is not null or undefined
      assertParamExists('ticketsControllerProcessTicketProlongationPayment', 'dIGEST1', dIGEST1)
      const localVarPath = `/tickets/payment/prolongation/process`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (oPERATION !== undefined) {
        localVarQueryParameter['OPERATION'] = oPERATION
      }

      if (oRDERNUMBER !== undefined) {
        localVarQueryParameter['ORDERNUMBER'] = oRDERNUMBER
      }

      if (pRCODE !== undefined) {
        localVarQueryParameter['PRCODE'] = pRCODE
      }

      if (sRCODE !== undefined) {
        localVarQueryParameter['SRCODE'] = sRCODE
      }

      if (dIGEST !== undefined) {
        localVarQueryParameter['DIGEST'] = dIGEST
      }

      if (dIGEST1 !== undefined) {
        localVarQueryParameter['DIGEST1'] = dIGEST1
      }

      if (rESULTTEXT !== undefined) {
        localVarQueryParameter['RESULTTEXT'] = rESULTTEXT
      }

      if (mD !== undefined) {
        localVarQueryParameter['MD'] = mD
      }

      if (tOKENREGSTATUS !== undefined) {
        localVarQueryParameter['TOKENREGSTATUS'] = tOKENREGSTATUS
      }

      if (tOKEN !== undefined) {
        localVarQueryParameter['TOKEN'] = tOKEN
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Revoke the stored payment method
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerRevokePaymentMethod: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/tickets/payment/revoke-payment-method`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Shorten existing ticket
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerShortenTicket: async (
      id: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('ticketsControllerShortenTicket', 'id', id)
      const localVarPath = `/tickets/shorten/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get tickets paginated
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {string} [ecv] ECV of the vehicle which has the ticket (support a list of values, separated by comma)
     * @param {string} [parkingStartFrom] Lower bound for parking start
     * @param {string} [parkingStartTo] Upper bound for parking start
     * @param {string} [parkingEndFrom] Lower bound for parking end
     * @param {string} [parkingEndTo] Upper bound for parking end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerTicketsGetMany: async (
      page?: number,
      pageSize?: number,
      ecv?: string,
      parkingStartFrom?: string,
      parkingStartTo?: string,
      parkingEndFrom?: string,
      parkingEndTo?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/tickets`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      if (ecv !== undefined) {
        localVarQueryParameter['ecv'] = ecv
      }

      if (parkingStartFrom !== undefined) {
        localVarQueryParameter['parkingStartFrom'] = parkingStartFrom
      }

      if (parkingStartTo !== undefined) {
        localVarQueryParameter['parkingStartTo'] = parkingStartTo
      }

      if (parkingEndFrom !== undefined) {
        localVarQueryParameter['parkingEndFrom'] = parkingEndFrom
      }

      if (parkingEndTo !== undefined) {
        localVarQueryParameter['parkingEndTo'] = parkingEndTo
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get single ticket
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerTicketsGetOne: async (
      id: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('ticketsControllerTicketsGetOne', 'id', id)
      const localVarPath = `/tickets/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * TicketsApi - functional programming interface
 * @export
 */
export const TicketsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TicketsApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Get URL to ticket receipt
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerGetReceipt(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ticketsControllerGetReceipt(
        id,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get price of the ticket after a potenial ticket shortening
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerGetShortenTicketPrice(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTicketPriceResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.ticketsControllerGetShortenTicketPrice(id, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get information about the status of the current saved payment method availability
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerGetStoredPaymentMethodAvailability(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoredPaymentMethodDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.ticketsControllerGetStoredPaymentMethodAvailability(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get ticket\'s last payment status
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerGetTicketLastPaymentStatus(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketPaymentDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.ticketsControllerGetTicketLastPaymentStatus(id, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get ticket price
     * @param {GetTicketPriceRequestDto} getTicketPriceRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerGetTicketPrice(
      getTicketPriceRequestDto: GetTicketPriceRequestDto,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTicketPriceResponseDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ticketsControllerGetTicketPrice(
        getTicketPriceRequestDto,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get ticket prolongation price
     * @param {GetTicketProlongationPriceRequestDto} getTicketProlongationPriceRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerGetTicketProlongationPrice(
      getTicketProlongationPriceRequestDto: GetTicketProlongationPriceRequestDto,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTicketPriceResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.ticketsControllerGetTicketProlongationPrice(
          getTicketProlongationPriceRequestDto,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Initiate ticket payment
     * @param {InitiatePaymentRequestDto} initiatePaymentRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerInitiateTicketPayment(
      initiatePaymentRequestDto: InitiatePaymentRequestDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketInitDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.ticketsControllerInitiateTicketPayment(
          initiatePaymentRequestDto,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Initiate prolongation ticket payment
     * @param {InitiateProlongationRequestDto} initiateProlongationRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerInitiateTicketProlongationPayment(
      initiateProlongationRequestDto: InitiateProlongationRequestDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketInitDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.ticketsControllerInitiateTicketProlongationPayment(
          initiateProlongationRequestDto,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Process ticket payment. This endpoint is called by the payment gate.
     * @param {string} oPERATION Operation text coming from the paygate return url query param
     * @param {string} oRDERNUMBER Ordernumber text coming from the paygate return url query param (13 characters long number)
     * @param {string} pRCODE Prcode text coming from the paygate return url query param
     * @param {string} sRCODE Srcode text coming from the paygate return url query param
     * @param {string} dIGEST Digest text coming from the paygate return url query param
     * @param {string} dIGEST1 Digest1 text coming from the paygate return url query param
     * @param {string} [rESULTTEXT] Result text coming from the paygate return url query param
     * @param {string} [mD] Custom data
     * @param {string} [tOKENREGSTATUS] State of token registration
     * @param {string} [tOKEN] Unique identifier of the card
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerProcessTicketPayment(
      oPERATION: string,
      oRDERNUMBER: string,
      pRCODE: string,
      sRCODE: string,
      dIGEST: string,
      dIGEST1: string,
      rESULTTEXT?: string,
      mD?: string,
      tOKENREGSTATUS?: string,
      tOKEN?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.ticketsControllerProcessTicketPayment(
          oPERATION,
          oRDERNUMBER,
          pRCODE,
          sRCODE,
          dIGEST,
          dIGEST1,
          rESULTTEXT,
          mD,
          tOKENREGSTATUS,
          tOKEN,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Process ticket prolongation payment. This endpoint is called by the payment gate.
     * @param {string} oPERATION Operation text coming from the paygate return url query param
     * @param {string} oRDERNUMBER Ordernumber text coming from the paygate return url query param (13 characters long number)
     * @param {string} pRCODE Prcode text coming from the paygate return url query param
     * @param {string} sRCODE Srcode text coming from the paygate return url query param
     * @param {string} dIGEST Digest text coming from the paygate return url query param
     * @param {string} dIGEST1 Digest1 text coming from the paygate return url query param
     * @param {string} [rESULTTEXT] Result text coming from the paygate return url query param
     * @param {string} [mD] Custom data
     * @param {string} [tOKENREGSTATUS] State of token registration
     * @param {string} [tOKEN] Unique identifier of the card
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerProcessTicketProlongationPayment(
      oPERATION: string,
      oRDERNUMBER: string,
      pRCODE: string,
      sRCODE: string,
      dIGEST: string,
      dIGEST1: string,
      rESULTTEXT?: string,
      mD?: string,
      tOKENREGSTATUS?: string,
      tOKEN?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.ticketsControllerProcessTicketProlongationPayment(
          oPERATION,
          oRDERNUMBER,
          pRCODE,
          sRCODE,
          dIGEST,
          dIGEST1,
          rESULTTEXT,
          mD,
          tOKENREGSTATUS,
          tOKEN,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Revoke the stored payment method
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerRevokePaymentMethod(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.ticketsControllerRevokePaymentMethod(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Shorten existing ticket
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerShortenTicket(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ticketsControllerShortenTicket(
        id,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get tickets paginated
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {string} [ecv] ECV of the vehicle which has the ticket (support a list of values, separated by comma)
     * @param {string} [parkingStartFrom] Lower bound for parking start
     * @param {string} [parkingStartTo] Upper bound for parking start
     * @param {string} [parkingEndFrom] Lower bound for parking end
     * @param {string} [parkingEndTo] Upper bound for parking end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerTicketsGetMany(
      page?: number,
      pageSize?: number,
      ecv?: string,
      parkingStartFrom?: string,
      parkingStartTo?: string,
      parkingEndFrom?: string,
      parkingEndTo?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketsResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ticketsControllerTicketsGetMany(
        page,
        pageSize,
        ecv,
        parkingStartFrom,
        parkingStartTo,
        parkingEndFrom,
        parkingEndTo,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get single ticket
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketsControllerTicketsGetOne(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ticketsControllerTicketsGetOne(
        id,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * TicketsApi - factory interface
 * @export
 */
export const TicketsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = TicketsApiFp(configuration)
  return {
    /**
     *
     * @summary Get URL to ticket receipt
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerGetReceipt(id: number, options?: AxiosRequestConfig): AxiosPromise<string> {
      return localVarFp
        .ticketsControllerGetReceipt(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get price of the ticket after a potenial ticket shortening
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerGetShortenTicketPrice(
      id: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<GetTicketPriceResponseDto> {
      return localVarFp
        .ticketsControllerGetShortenTicketPrice(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get information about the status of the current saved payment method availability
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerGetStoredPaymentMethodAvailability(
      options?: AxiosRequestConfig,
    ): AxiosPromise<StoredPaymentMethodDto> {
      return localVarFp
        .ticketsControllerGetStoredPaymentMethodAvailability(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get ticket\'s last payment status
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerGetTicketLastPaymentStatus(
      id: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<TicketPaymentDto> {
      return localVarFp
        .ticketsControllerGetTicketLastPaymentStatus(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get ticket price
     * @param {GetTicketPriceRequestDto} getTicketPriceRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerGetTicketPrice(
      getTicketPriceRequestDto: GetTicketPriceRequestDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<GetTicketPriceResponseDto> {
      return localVarFp
        .ticketsControllerGetTicketPrice(getTicketPriceRequestDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get ticket prolongation price
     * @param {GetTicketProlongationPriceRequestDto} getTicketProlongationPriceRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerGetTicketProlongationPrice(
      getTicketProlongationPriceRequestDto: GetTicketProlongationPriceRequestDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<GetTicketPriceResponseDto> {
      return localVarFp
        .ticketsControllerGetTicketProlongationPrice(getTicketProlongationPriceRequestDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Initiate ticket payment
     * @param {InitiatePaymentRequestDto} initiatePaymentRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerInitiateTicketPayment(
      initiatePaymentRequestDto: InitiatePaymentRequestDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<TicketInitDto> {
      return localVarFp
        .ticketsControllerInitiateTicketPayment(initiatePaymentRequestDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Initiate prolongation ticket payment
     * @param {InitiateProlongationRequestDto} initiateProlongationRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerInitiateTicketProlongationPayment(
      initiateProlongationRequestDto: InitiateProlongationRequestDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<TicketInitDto> {
      return localVarFp
        .ticketsControllerInitiateTicketProlongationPayment(initiateProlongationRequestDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Process ticket payment. This endpoint is called by the payment gate.
     * @param {string} oPERATION Operation text coming from the paygate return url query param
     * @param {string} oRDERNUMBER Ordernumber text coming from the paygate return url query param (13 characters long number)
     * @param {string} pRCODE Prcode text coming from the paygate return url query param
     * @param {string} sRCODE Srcode text coming from the paygate return url query param
     * @param {string} dIGEST Digest text coming from the paygate return url query param
     * @param {string} dIGEST1 Digest1 text coming from the paygate return url query param
     * @param {string} [rESULTTEXT] Result text coming from the paygate return url query param
     * @param {string} [mD] Custom data
     * @param {string} [tOKENREGSTATUS] State of token registration
     * @param {string} [tOKEN] Unique identifier of the card
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerProcessTicketPayment(
      oPERATION: string,
      oRDERNUMBER: string,
      pRCODE: string,
      sRCODE: string,
      dIGEST: string,
      dIGEST1: string,
      rESULTTEXT?: string,
      mD?: string,
      tOKENREGSTATUS?: string,
      tOKEN?: string,
      options?: AxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .ticketsControllerProcessTicketPayment(
          oPERATION,
          oRDERNUMBER,
          pRCODE,
          sRCODE,
          dIGEST,
          dIGEST1,
          rESULTTEXT,
          mD,
          tOKENREGSTATUS,
          tOKEN,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Process ticket prolongation payment. This endpoint is called by the payment gate.
     * @param {string} oPERATION Operation text coming from the paygate return url query param
     * @param {string} oRDERNUMBER Ordernumber text coming from the paygate return url query param (13 characters long number)
     * @param {string} pRCODE Prcode text coming from the paygate return url query param
     * @param {string} sRCODE Srcode text coming from the paygate return url query param
     * @param {string} dIGEST Digest text coming from the paygate return url query param
     * @param {string} dIGEST1 Digest1 text coming from the paygate return url query param
     * @param {string} [rESULTTEXT] Result text coming from the paygate return url query param
     * @param {string} [mD] Custom data
     * @param {string} [tOKENREGSTATUS] State of token registration
     * @param {string} [tOKEN] Unique identifier of the card
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerProcessTicketProlongationPayment(
      oPERATION: string,
      oRDERNUMBER: string,
      pRCODE: string,
      sRCODE: string,
      dIGEST: string,
      dIGEST1: string,
      rESULTTEXT?: string,
      mD?: string,
      tOKENREGSTATUS?: string,
      tOKEN?: string,
      options?: AxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .ticketsControllerProcessTicketProlongationPayment(
          oPERATION,
          oRDERNUMBER,
          pRCODE,
          sRCODE,
          dIGEST,
          dIGEST1,
          rESULTTEXT,
          mD,
          tOKENREGSTATUS,
          tOKEN,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Revoke the stored payment method
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerRevokePaymentMethod(options?: AxiosRequestConfig): AxiosPromise<string> {
      return localVarFp
        .ticketsControllerRevokePaymentMethod(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Shorten existing ticket
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerShortenTicket(
      id: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<TicketDto> {
      return localVarFp
        .ticketsControllerShortenTicket(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get tickets paginated
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {string} [ecv] ECV of the vehicle which has the ticket (support a list of values, separated by comma)
     * @param {string} [parkingStartFrom] Lower bound for parking start
     * @param {string} [parkingStartTo] Upper bound for parking start
     * @param {string} [parkingEndFrom] Lower bound for parking end
     * @param {string} [parkingEndTo] Upper bound for parking end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerTicketsGetMany(
      page?: number,
      pageSize?: number,
      ecv?: string,
      parkingStartFrom?: string,
      parkingStartTo?: string,
      parkingEndFrom?: string,
      parkingEndTo?: string,
      options?: AxiosRequestConfig,
    ): AxiosPromise<TicketsResponseDto> {
      return localVarFp
        .ticketsControllerTicketsGetMany(
          page,
          pageSize,
          ecv,
          parkingStartFrom,
          parkingStartTo,
          parkingEndFrom,
          parkingEndTo,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get single ticket
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketsControllerTicketsGetOne(
      id: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<TicketDto> {
      return localVarFp
        .ticketsControllerTicketsGetOne(id, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * TicketsApi - object-oriented interface
 * @export
 * @class TicketsApi
 * @extends {BaseAPI}
 */
export class TicketsApi extends BaseAPI {
  /**
   *
   * @summary Get URL to ticket receipt
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerGetReceipt(id: number, options?: AxiosRequestConfig) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerGetReceipt(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get price of the ticket after a potenial ticket shortening
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerGetShortenTicketPrice(id: number, options?: AxiosRequestConfig) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerGetShortenTicketPrice(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get information about the status of the current saved payment method availability
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerGetStoredPaymentMethodAvailability(options?: AxiosRequestConfig) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerGetStoredPaymentMethodAvailability(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get ticket\'s last payment status
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerGetTicketLastPaymentStatus(id: number, options?: AxiosRequestConfig) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerGetTicketLastPaymentStatus(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get ticket price
   * @param {GetTicketPriceRequestDto} getTicketPriceRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerGetTicketPrice(
    getTicketPriceRequestDto: GetTicketPriceRequestDto,
    options?: AxiosRequestConfig,
  ) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerGetTicketPrice(getTicketPriceRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get ticket prolongation price
   * @param {GetTicketProlongationPriceRequestDto} getTicketProlongationPriceRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerGetTicketProlongationPrice(
    getTicketProlongationPriceRequestDto: GetTicketProlongationPriceRequestDto,
    options?: AxiosRequestConfig,
  ) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerGetTicketProlongationPrice(getTicketProlongationPriceRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Initiate ticket payment
   * @param {InitiatePaymentRequestDto} initiatePaymentRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerInitiateTicketPayment(
    initiatePaymentRequestDto: InitiatePaymentRequestDto,
    options?: AxiosRequestConfig,
  ) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerInitiateTicketPayment(initiatePaymentRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Initiate prolongation ticket payment
   * @param {InitiateProlongationRequestDto} initiateProlongationRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerInitiateTicketProlongationPayment(
    initiateProlongationRequestDto: InitiateProlongationRequestDto,
    options?: AxiosRequestConfig,
  ) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerInitiateTicketProlongationPayment(initiateProlongationRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Process ticket payment. This endpoint is called by the payment gate.
   * @param {string} oPERATION Operation text coming from the paygate return url query param
   * @param {string} oRDERNUMBER Ordernumber text coming from the paygate return url query param (13 characters long number)
   * @param {string} pRCODE Prcode text coming from the paygate return url query param
   * @param {string} sRCODE Srcode text coming from the paygate return url query param
   * @param {string} dIGEST Digest text coming from the paygate return url query param
   * @param {string} dIGEST1 Digest1 text coming from the paygate return url query param
   * @param {string} [rESULTTEXT] Result text coming from the paygate return url query param
   * @param {string} [mD] Custom data
   * @param {string} [tOKENREGSTATUS] State of token registration
   * @param {string} [tOKEN] Unique identifier of the card
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerProcessTicketPayment(
    oPERATION: string,
    oRDERNUMBER: string,
    pRCODE: string,
    sRCODE: string,
    dIGEST: string,
    dIGEST1: string,
    rESULTTEXT?: string,
    mD?: string,
    tOKENREGSTATUS?: string,
    tOKEN?: string,
    options?: AxiosRequestConfig,
  ) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerProcessTicketPayment(
        oPERATION,
        oRDERNUMBER,
        pRCODE,
        sRCODE,
        dIGEST,
        dIGEST1,
        rESULTTEXT,
        mD,
        tOKENREGSTATUS,
        tOKEN,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Process ticket prolongation payment. This endpoint is called by the payment gate.
   * @param {string} oPERATION Operation text coming from the paygate return url query param
   * @param {string} oRDERNUMBER Ordernumber text coming from the paygate return url query param (13 characters long number)
   * @param {string} pRCODE Prcode text coming from the paygate return url query param
   * @param {string} sRCODE Srcode text coming from the paygate return url query param
   * @param {string} dIGEST Digest text coming from the paygate return url query param
   * @param {string} dIGEST1 Digest1 text coming from the paygate return url query param
   * @param {string} [rESULTTEXT] Result text coming from the paygate return url query param
   * @param {string} [mD] Custom data
   * @param {string} [tOKENREGSTATUS] State of token registration
   * @param {string} [tOKEN] Unique identifier of the card
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerProcessTicketProlongationPayment(
    oPERATION: string,
    oRDERNUMBER: string,
    pRCODE: string,
    sRCODE: string,
    dIGEST: string,
    dIGEST1: string,
    rESULTTEXT?: string,
    mD?: string,
    tOKENREGSTATUS?: string,
    tOKEN?: string,
    options?: AxiosRequestConfig,
  ) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerProcessTicketProlongationPayment(
        oPERATION,
        oRDERNUMBER,
        pRCODE,
        sRCODE,
        dIGEST,
        dIGEST1,
        rESULTTEXT,
        mD,
        tOKENREGSTATUS,
        tOKEN,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Revoke the stored payment method
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerRevokePaymentMethod(options?: AxiosRequestConfig) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerRevokePaymentMethod(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Shorten existing ticket
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerShortenTicket(id: number, options?: AxiosRequestConfig) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerShortenTicket(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get tickets paginated
   * @param {number} [page] Page number
   * @param {number} [pageSize] Items per page
   * @param {string} [ecv] ECV of the vehicle which has the ticket (support a list of values, separated by comma)
   * @param {string} [parkingStartFrom] Lower bound for parking start
   * @param {string} [parkingStartTo] Upper bound for parking start
   * @param {string} [parkingEndFrom] Lower bound for parking end
   * @param {string} [parkingEndTo] Upper bound for parking end
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerTicketsGetMany(
    page?: number,
    pageSize?: number,
    ecv?: string,
    parkingStartFrom?: string,
    parkingStartTo?: string,
    parkingEndFrom?: string,
    parkingEndTo?: string,
    options?: AxiosRequestConfig,
  ) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerTicketsGetMany(
        page,
        pageSize,
        ecv,
        parkingStartFrom,
        parkingStartTo,
        parkingEndFrom,
        parkingEndTo,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get single ticket
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsApi
   */
  public ticketsControllerTicketsGetOne(id: number, options?: AxiosRequestConfig) {
    return TicketsApiFp(this.configuration)
      .ticketsControllerTicketsGetOne(id, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerDeleteUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/user`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get user settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerGetUserSettings: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/user/settings`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Save user settings
     * @param {SaveUserSettingsDto} saveUserSettingsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerSaveUserSettings: async (
      saveUserSettingsDto: SaveUserSettingsDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'saveUserSettingsDto' is not null or undefined
      assertParamExists(
        'usersControllerSaveUserSettings',
        'saveUserSettingsDto',
        saveUserSettingsDto,
      )
      const localVarPath = `/user/settings`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        saveUserSettingsDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Delete user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersControllerDeleteUser(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerDeleteUser(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get user settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersControllerGetUserSettings(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSettingsDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.usersControllerGetUserSettings(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Save user settings
     * @param {SaveUserSettingsDto} saveUserSettingsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersControllerSaveUserSettings(
      saveUserSettingsDto: SaveUserSettingsDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSettingsDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerSaveUserSettings(
        saveUserSettingsDto,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UserApiFp(configuration)
  return {
    /**
     *
     * @summary Delete user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerDeleteUser(options?: AxiosRequestConfig): AxiosPromise<boolean> {
      return localVarFp
        .usersControllerDeleteUser(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get user settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerGetUserSettings(options?: AxiosRequestConfig): AxiosPromise<UserSettingsDto> {
      return localVarFp
        .usersControllerGetUserSettings(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Save user settings
     * @param {SaveUserSettingsDto} saveUserSettingsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersControllerSaveUserSettings(
      saveUserSettingsDto: SaveUserSettingsDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<UserSettingsDto> {
      return localVarFp
        .usersControllerSaveUserSettings(saveUserSettingsDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
  /**
   *
   * @summary Delete user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public usersControllerDeleteUser(options?: AxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .usersControllerDeleteUser(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get user settings
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public usersControllerGetUserSettings(options?: AxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .usersControllerGetUserSettings(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Save user settings
   * @param {SaveUserSettingsDto} saveUserSettingsDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public usersControllerSaveUserSettings(
    saveUserSettingsDto: SaveUserSettingsDto,
    options?: AxiosRequestConfig,
  ) {
    return UserApiFp(this.configuration)
      .usersControllerSaveUserSettings(saveUserSettingsDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * VehiclesApi - axios parameter creator
 * @export
 */
export const VehiclesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete a specific vehicle
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehiclesControllerDeleteVehicle: async (
      id: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('vehiclesControllerDeleteVehicle', 'id', id)
      const localVarPath = `/vehicles/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Inserts new vehicle
     * @param {CreateVehicleDto} createVehicleDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehiclesControllerInsertVehicle: async (
      createVehicleDto: CreateVehicleDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createVehicleDto' is not null or undefined
      assertParamExists('vehiclesControllerInsertVehicle', 'createVehicleDto', createVehicleDto)
      const localVarPath = `/vehicles`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createVehicleDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Updates a specific vehicle
     * @param {number} id
     * @param {UpdateVehicleDto} updateVehicleDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehiclesControllerUpdateVehicle: async (
      id: number,
      updateVehicleDto: UpdateVehicleDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('vehiclesControllerUpdateVehicle', 'id', id)
      // verify required parameter 'updateVehicleDto' is not null or undefined
      assertParamExists('vehiclesControllerUpdateVehicle', 'updateVehicleDto', updateVehicleDto)
      const localVarPath = `/vehicles/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateVehicleDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get all vehicles associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehiclesControllerVehiclesGetMany: async (
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/vehicles`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * VehiclesApi - functional programming interface
 * @export
 */
export const VehiclesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = VehiclesApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Delete a specific vehicle
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vehiclesControllerDeleteVehicle(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.vehiclesControllerDeleteVehicle(
        id,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Inserts new vehicle
     * @param {CreateVehicleDto} createVehicleDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vehiclesControllerInsertVehicle(
      createVehicleDto: CreateVehicleDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VehicleDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.vehiclesControllerInsertVehicle(
        createVehicleDto,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Updates a specific vehicle
     * @param {number} id
     * @param {UpdateVehicleDto} updateVehicleDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vehiclesControllerUpdateVehicle(
      id: number,
      updateVehicleDto: UpdateVehicleDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VehicleDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.vehiclesControllerUpdateVehicle(
        id,
        updateVehicleDto,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all vehicles associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vehiclesControllerVehiclesGetMany(
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VehiclesResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.vehiclesControllerVehiclesGetMany(
        page,
        pageSize,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * VehiclesApi - factory interface
 * @export
 */
export const VehiclesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = VehiclesApiFp(configuration)
  return {
    /**
     *
     * @summary Delete a specific vehicle
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehiclesControllerDeleteVehicle(
      id: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<DeleteResponseDto> {
      return localVarFp
        .vehiclesControllerDeleteVehicle(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Inserts new vehicle
     * @param {CreateVehicleDto} createVehicleDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehiclesControllerInsertVehicle(
      createVehicleDto: CreateVehicleDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<VehicleDto> {
      return localVarFp
        .vehiclesControllerInsertVehicle(createVehicleDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Updates a specific vehicle
     * @param {number} id
     * @param {UpdateVehicleDto} updateVehicleDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehiclesControllerUpdateVehicle(
      id: number,
      updateVehicleDto: UpdateVehicleDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<VehicleDto> {
      return localVarFp
        .vehiclesControllerUpdateVehicle(id, updateVehicleDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get all vehicles associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vehiclesControllerVehiclesGetMany(
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<VehiclesResponseDto> {
      return localVarFp
        .vehiclesControllerVehiclesGetMany(page, pageSize, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * VehiclesApi - object-oriented interface
 * @export
 * @class VehiclesApi
 * @extends {BaseAPI}
 */
export class VehiclesApi extends BaseAPI {
  /**
   *
   * @summary Delete a specific vehicle
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VehiclesApi
   */
  public vehiclesControllerDeleteVehicle(id: number, options?: AxiosRequestConfig) {
    return VehiclesApiFp(this.configuration)
      .vehiclesControllerDeleteVehicle(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Inserts new vehicle
   * @param {CreateVehicleDto} createVehicleDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VehiclesApi
   */
  public vehiclesControllerInsertVehicle(
    createVehicleDto: CreateVehicleDto,
    options?: AxiosRequestConfig,
  ) {
    return VehiclesApiFp(this.configuration)
      .vehiclesControllerInsertVehicle(createVehicleDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Updates a specific vehicle
   * @param {number} id
   * @param {UpdateVehicleDto} updateVehicleDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VehiclesApi
   */
  public vehiclesControllerUpdateVehicle(
    id: number,
    updateVehicleDto: UpdateVehicleDto,
    options?: AxiosRequestConfig,
  ) {
    return VehiclesApiFp(this.configuration)
      .vehiclesControllerUpdateVehicle(id, updateVehicleDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all vehicles associated with the user
   * @param {number} [page] Page number
   * @param {number} [pageSize] Items per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VehiclesApi
   */
  public vehiclesControllerVehiclesGetMany(
    page?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return VehiclesApiFp(this.configuration)
      .vehiclesControllerVehiclesGetMany(page, pageSize, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * VerifiedEmailsApi - axios parameter creator
 * @export
 */
export const VerifiedEmailsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete a specific verified email
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerDeleteVerifiedEmail: async (
      id: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('verifiedEmailsControllerDeleteVerifiedEmail', 'id', id)
      const localVarPath = `/verified-emails/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Refreshes all parking cards for the email
     * @param {boolean} addVehicles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerRefreshVerifiedEmail: async (
      addVehicles: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addVehicles' is not null or undefined
      assertParamExists('verifiedEmailsControllerRefreshVerifiedEmail', 'addVehicles', addVehicles)
      const localVarPath = `/verified-emails/refresh`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (addVehicles !== undefined) {
        localVarQueryParameter['add-vehicles'] = addVehicles
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Send out emails for each email for verification
     * @param {VerifyEmailsDto} verifyEmailsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerSendEmailVerificationEmails: async (
      verifyEmailsDto: VerifyEmailsDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'verifyEmailsDto' is not null or undefined
      assertParamExists(
        'verifiedEmailsControllerSendEmailVerificationEmails',
        'verifyEmailsDto',
        verifyEmailsDto,
      )
      const localVarPath = `/verified-emails`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        verifyEmailsDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get all verified emails associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerVerifiedEmailsGetMany: async (
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/verified-emails`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Verifies an email with token
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerVerifyEmail: async (
      token: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'token' is not null or undefined
      assertParamExists('verifiedEmailsControllerVerifyEmail', 'token', token)
      const localVarPath = `/verified-emails/verify`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognito required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (token !== undefined) {
        localVarQueryParameter['token'] = token
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * VerifiedEmailsApi - functional programming interface
 * @export
 */
export const VerifiedEmailsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = VerifiedEmailsApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Delete a specific verified email
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verifiedEmailsControllerDeleteVerifiedEmail(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteResponseDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.verifiedEmailsControllerDeleteVerifiedEmail(id, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Refreshes all parking cards for the email
     * @param {boolean} addVehicles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verifiedEmailsControllerRefreshVerifiedEmail(
      addVehicles: boolean,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.verifiedEmailsControllerRefreshVerifiedEmail(
          addVehicles,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Send out emails for each email for verification
     * @param {VerifyEmailsDto} verifyEmailsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verifiedEmailsControllerSendEmailVerificationEmails(
      verifyEmailsDto: VerifyEmailsDto,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EmailVerificationResult>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.verifiedEmailsControllerSendEmailVerificationEmails(
          verifyEmailsDto,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get all verified emails associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verifiedEmailsControllerVerifiedEmailsGetMany(
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerifiedEmailsResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.verifiedEmailsControllerVerifiedEmailsGetMany(
          page,
          pageSize,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Verifies an email with token
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verifiedEmailsControllerVerifyEmail(
      token: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ParkingCardDto>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.verifiedEmailsControllerVerifyEmail(
        token,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * VerifiedEmailsApi - factory interface
 * @export
 */
export const VerifiedEmailsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = VerifiedEmailsApiFp(configuration)
  return {
    /**
     *
     * @summary Delete a specific verified email
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerDeleteVerifiedEmail(
      id: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<DeleteResponseDto> {
      return localVarFp
        .verifiedEmailsControllerDeleteVerifiedEmail(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Refreshes all parking cards for the email
     * @param {boolean} addVehicles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerRefreshVerifiedEmail(
      addVehicles: boolean,
      options?: AxiosRequestConfig,
    ): AxiosPromise<boolean> {
      return localVarFp
        .verifiedEmailsControllerRefreshVerifiedEmail(addVehicles, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Send out emails for each email for verification
     * @param {VerifyEmailsDto} verifyEmailsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerSendEmailVerificationEmails(
      verifyEmailsDto: VerifyEmailsDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<Array<EmailVerificationResult>> {
      return localVarFp
        .verifiedEmailsControllerSendEmailVerificationEmails(verifyEmailsDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get all verified emails associated with the user
     * @param {number} [page] Page number
     * @param {number} [pageSize] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerVerifiedEmailsGetMany(
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<VerifiedEmailsResponseDto> {
      return localVarFp
        .verifiedEmailsControllerVerifiedEmailsGetMany(page, pageSize, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Verifies an email with token
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiedEmailsControllerVerifyEmail(
      token: string,
      options?: AxiosRequestConfig,
    ): AxiosPromise<Array<ParkingCardDto>> {
      return localVarFp
        .verifiedEmailsControllerVerifyEmail(token, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * VerifiedEmailsApi - object-oriented interface
 * @export
 * @class VerifiedEmailsApi
 * @extends {BaseAPI}
 */
export class VerifiedEmailsApi extends BaseAPI {
  /**
   *
   * @summary Delete a specific verified email
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VerifiedEmailsApi
   */
  public verifiedEmailsControllerDeleteVerifiedEmail(id: number, options?: AxiosRequestConfig) {
    return VerifiedEmailsApiFp(this.configuration)
      .verifiedEmailsControllerDeleteVerifiedEmail(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Refreshes all parking cards for the email
   * @param {boolean} addVehicles
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VerifiedEmailsApi
   */
  public verifiedEmailsControllerRefreshVerifiedEmail(
    addVehicles: boolean,
    options?: AxiosRequestConfig,
  ) {
    return VerifiedEmailsApiFp(this.configuration)
      .verifiedEmailsControllerRefreshVerifiedEmail(addVehicles, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Send out emails for each email for verification
   * @param {VerifyEmailsDto} verifyEmailsDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VerifiedEmailsApi
   */
  public verifiedEmailsControllerSendEmailVerificationEmails(
    verifyEmailsDto: VerifyEmailsDto,
    options?: AxiosRequestConfig,
  ) {
    return VerifiedEmailsApiFp(this.configuration)
      .verifiedEmailsControllerSendEmailVerificationEmails(verifyEmailsDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all verified emails associated with the user
   * @param {number} [page] Page number
   * @param {number} [pageSize] Items per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VerifiedEmailsApi
   */
  public verifiedEmailsControllerVerifiedEmailsGetMany(
    page?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return VerifiedEmailsApiFp(this.configuration)
      .verifiedEmailsControllerVerifiedEmailsGetMany(page, pageSize, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Verifies an email with token
   * @param {string} token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VerifiedEmailsApi
   */
  public verifiedEmailsControllerVerifyEmail(token: string, options?: AxiosRequestConfig) {
    return VerifiedEmailsApiFp(this.configuration)
      .verifiedEmailsControllerVerifyEmail(token, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
